var jQueryExists = !!window.jQuery;

define("jquery.noconflict", [ "jquery" ], function(jQuery) {
 var matched, browser, Ember;
 jQuery.uaMatch = function(ua) {
  ua = ua.toLowerCase();
  var match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
  return {
   browser:match[1] || "",
   version:match[2] || "0"
  };
 };
 matched = jQuery.uaMatch(navigator.userAgent);
 browser = {};
 if (matched.browser) {
  browser[matched.browser] = true;
  browser.version = matched.version;
 }
 if (browser.chrome) {
  browser.webkit = true;
 } else if (browser.webkit) {
  browser.safari = true;
 }
 jQuery.browser = browser;
 if (!jQuery.support.cors && window.XDomainRequest) {
  var httpRegEx = /^https?:\/\//i;
  var getOrPostRegEx = /^get|post$/i;
  var sameSchemeRegEx = new RegExp("^" + location.protocol, "i");
  var xmlRegEx = /\/xml/i;
  jQuery.ajaxTransport("text html xml json", function(options, userOptions, jqXHR) {
   if (options.crossDomain && options.async && getOrPostRegEx.test(options.type) && httpRegEx.test(userOptions.url) && sameSchemeRegEx.test(userOptions.url)) {
    var xdr = null;
    var userType = (userOptions.dataType || "").toLowerCase();
    return {
     send:function(headers, complete) {
      xdr = new XDomainRequest();
      if (/^\d+$/.test(userOptions.timeout)) {
       xdr.timeout = userOptions.timeout;
      }
      xdr.ontimeout = function() {
       complete(500, "timeout");
      };
      xdr.onload = function() {
       var allResponseHeaders = "Content-Length: " + xdr.responseText.length + "\r\nContent-Type: " + xdr.contentType;
       var status = {
        code:200,
        message:"success"
       };
       var responses = {
        text:xdr.responseText
       };
       try {
        if (userType === "json") {
         try {
          responses.json = JSON.parse(xdr.responseText);
         } catch (e) {
          status.code = 500;
          status.message = "parseerror";
         }
        } else if (userType === "xml" || userType !== "text" && xmlRegEx.test(xdr.contentType)) {
         var doc = new ActiveXObject("Microsoft.XMLDOM");
         doc.async = false;
         try {
          doc.loadXML(xdr.responseText);
         } catch (e) {
          doc = undefined;
         }
         if (!doc || !doc.documentElement || doc.getElementsByTagName("parsererror").length) {
          status.code = 500;
          status.message = "parseerror";
          throw new Error("Invalid XML: " + xdr.responseText);
         }
         responses.xml = doc;
        }
       } catch (parseMessage) {
        throw parseMessage;
       } finally {
        complete(status.code, status.message, responses, allResponseHeaders);
       }
      };
      xdr.onerror = function() {
       complete(500, "error", {
        text:xdr.responseText
       });
      };
      xdr.open(options.type, options.url);
      xdr.send();
     },
     abort:function() {
      if (xdr) {
       xdr.abort();
      }
     }
    };
   }
  });
 }
 Ember = {
  imports:{
   jQuery:jQuery
  }
 };
 if (typeof window !== "undefined") {
  if (typeof window.Ember === "undefined") {
   window.Ember = Ember;
  } else if (typeof window.Ember !== "undefined" && window.Ember.hasOwnProperty("imports")) {
   window.Ember.imports.jQuery = Ember.imports.jQuery;
  } else {
   window.Ember.imports = Ember.imports;
  }
  window.Ember.$ = Ember.imports.jQuery;
 }
 return jQueryExists ? jQuery.noConflict(true) :jQuery.noConflict();
});

(function() {
 var define, requireModule, require, requirejs;
 (function() {
  var registry = {}, seen = {};
  define = function(name, deps, callback) {
   registry[name] = {
    deps:deps,
    callback:callback
   };
  };
  requirejs = require = requireModule = function(name) {
   requirejs._eak_seen = registry;
   if (seen[name]) {
    return seen[name];
   }
   seen[name] = {};
   if (!registry[name]) {
    throw new Error("Could not find module " + name);
   }
   var mod = registry[name], deps = mod.deps, callback = mod.callback, reified = [], exports;
   for (var i = 0, l = deps.length; i < l; i++) {
    if (deps[i] === "exports") {
     reified.push(exports = {});
    } else {
     reified.push(requireModule(resolve(deps[i])));
    }
   }
   var value = callback.apply(this, reified);
   return seen[name] = exports || value;
   function resolve(child) {
    if (child.charAt(0) !== ".") {
     return child;
    }
    var parts = child.split("/");
    var parentBase = name.split("/").slice(0, -1);
    for (var i = 0, l = parts.length; i < l; i++) {
     var part = parts[i];
     if (part === "..") {
      parentBase.pop();
     } else if (part === ".") {
      continue;
     } else {
      parentBase.push(part);
     }
    }
    return parentBase.join("/");
   }
  };
 })();
 (function() {
  if ("undefined" === typeof Ember) {
   Ember = {};
  }
  var imports = Ember.imports = Ember.imports || this;
  var exports = Ember.exports = Ember.exports || this;
  var lookup = Ember.lookup = Ember.lookup || this;
  exports.Em = exports.Ember = Em = Ember;
  Ember.isNamespace = true;
  Ember.toString = function() {
   return "Ember";
  };
  Ember.VERSION = "1.4.0-beta.3";
  if (Ember.ENV) {} else if ("undefined" !== typeof EmberENV) {
   Ember.ENV = EmberENV;
  } else if ("undefined" !== typeof ENV) {
   Ember.ENV = ENV;
  } else {
   Ember.ENV = {};
  }
  Ember.config = Ember.config || {};
  if ("undefined" === typeof Ember.ENV.DISABLE_RANGE_API) {
   Ember.ENV.DISABLE_RANGE_API = true;
  }
  if ("undefined" === typeof MetamorphENV) {
   exports.MetamorphENV = {};
  }
  MetamorphENV.DISABLE_RANGE_API = Ember.ENV.DISABLE_RANGE_API;
  Ember.FEATURES = Ember.ENV.FEATURES || {};
  Ember.FEATURES.isEnabled = function(feature) {
   var featureValue = Ember.FEATURES[feature];
   if (Ember.ENV.ENABLE_ALL_FEATURES) {
    return true;
   } else if (featureValue === true || featureValue === false || featureValue === undefined) {
    return featureValue;
   } else if (Ember.ENV.ENABLE_OPTIONAL_FEATURES) {
    return true;
   } else {
    return false;
   }
  };
  Ember.EXTEND_PROTOTYPES = Ember.ENV.EXTEND_PROTOTYPES;
  if (typeof Ember.EXTEND_PROTOTYPES === "undefined") {
   Ember.EXTEND_PROTOTYPES = true;
  }
  Ember.LOG_STACKTRACE_ON_DEPRECATION = Ember.ENV.LOG_STACKTRACE_ON_DEPRECATION !== false;
  Ember.SHIM_ES5 = Ember.ENV.SHIM_ES5 === false ? false :Ember.EXTEND_PROTOTYPES;
  Ember.LOG_VERSION = Ember.ENV.LOG_VERSION === false ? false :true;
  Ember.K = function() {
   return this;
  };
  if ("undefined" === typeof Ember.assert) {
   Ember.assert = Ember.K;
  }
  if ("undefined" === typeof Ember.warn) {
   Ember.warn = Ember.K;
  }
  if ("undefined" === typeof Ember.debug) {
   Ember.debug = Ember.K;
  }
  if ("undefined" === typeof Ember.deprecate) {
   Ember.deprecate = Ember.K;
  }
  if ("undefined" === typeof Ember.deprecateFunc) {
   Ember.deprecateFunc = function(_, func) {
    return func;
   };
  }
  Ember.uuid = 0;
  Ember.merge = function(original, updates) {
   for (var prop in updates) {
    if (!updates.hasOwnProperty(prop)) {
     continue;
    }
    original[prop] = updates[prop];
   }
   return original;
  };
  Ember.isNone = function(obj) {
   return obj === null || obj === undefined;
  };
  Ember.none = Ember.deprecateFunc("Ember.none is deprecated. Please use Ember.isNone instead.", Ember.isNone);
  Ember.isEmpty = function(obj) {
   return Ember.isNone(obj) || obj.length === 0 && typeof obj !== "function" || typeof obj === "object" && Ember.get(obj, "length") === 0;
  };
  Ember.empty = Ember.deprecateFunc("Ember.empty is deprecated. Please use Ember.isEmpty instead.", Ember.isEmpty);
 })();
 (function() {
  var platform = Ember.platform = {};
  Ember.create = Object.create;
  if (Ember.create) {
   if (Ember.create({
    a:1
   }, {
    a:{
     value:2
    }
   }).a !== 2) {
    Ember.create = null;
   }
  }
  if (!Ember.create || Ember.ENV.STUB_OBJECT_CREATE) {
   var K = function() {};
   Ember.create = function(obj, props) {
    K.prototype = obj;
    obj = new K();
    if (props) {
     K.prototype = obj;
     for (var prop in props) {
      K.prototype[prop] = props[prop].value;
     }
     obj = new K();
    }
    K.prototype = null;
    return obj;
   };
   Ember.create.isSimulated = true;
  }
  var defineProperty = Object.defineProperty;
  var canRedefineProperties, canDefinePropertyOnDOM;
  if (defineProperty) {
   try {
    defineProperty({}, "a", {
     get:function() {}
    });
   } catch (e) {
    defineProperty = null;
   }
  }
  if (defineProperty) {
   canRedefineProperties = function() {
    var obj = {};
    defineProperty(obj, "a", {
     configurable:true,
     enumerable:true,
     get:function() {},
     set:function() {}
    });
    defineProperty(obj, "a", {
     configurable:true,
     enumerable:true,
     writable:true,
     value:true
    });
    return obj.a === true;
   }();
   canDefinePropertyOnDOM = function() {
    try {
     defineProperty(document.createElement("div"), "definePropertyOnDOM", {});
     return true;
    } catch (e) {}
    return false;
   }();
   if (!canRedefineProperties) {
    defineProperty = null;
   } else if (!canDefinePropertyOnDOM) {
    defineProperty = function(obj, keyName, desc) {
     var isNode;
     if (typeof Node === "object") {
      isNode = obj instanceof Node;
     } else {
      isNode = typeof obj === "object" && typeof obj.nodeType === "number" && typeof obj.nodeName === "string";
     }
     if (isNode) {
      return obj[keyName] = desc.value;
     } else {
      return Object.defineProperty(obj, keyName, desc);
     }
    };
   }
  }
  platform.defineProperty = defineProperty;
  platform.hasPropertyAccessors = true;
  if (!platform.defineProperty) {
   platform.hasPropertyAccessors = false;
   platform.defineProperty = function(obj, keyName, desc) {
    if (!desc.get) {
     obj[keyName] = desc.value;
    }
   };
   platform.defineProperty.isSimulated = true;
  }
  if (Ember.ENV.MANDATORY_SETTER && !platform.hasPropertyAccessors) {
   Ember.ENV.MANDATORY_SETTER = false;
  }
 })();
 (function() {
  var isNativeFunc = function(func) {
   return func && Function.prototype.toString.call(func).indexOf("[native code]") > -1;
  };
  var arrayMap = isNativeFunc(Array.prototype.map) ? Array.prototype.map :function(fun) {
   if (this === void 0 || this === null) {
    throw new TypeError();
   }
   var t = Object(this);
   var len = t.length >>> 0;
   if (typeof fun !== "function") {
    throw new TypeError();
   }
   var res = new Array(len);
   var thisp = arguments[1];
   for (var i = 0; i < len; i++) {
    if (i in t) {
     res[i] = fun.call(thisp, t[i], i, t);
    }
   }
   return res;
  };
  var arrayForEach = isNativeFunc(Array.prototype.forEach) ? Array.prototype.forEach :function(fun) {
   if (this === void 0 || this === null) {
    throw new TypeError();
   }
   var t = Object(this);
   var len = t.length >>> 0;
   if (typeof fun !== "function") {
    throw new TypeError();
   }
   var thisp = arguments[1];
   for (var i = 0; i < len; i++) {
    if (i in t) {
     fun.call(thisp, t[i], i, t);
    }
   }
  };
  var arrayIndexOf = isNativeFunc(Array.prototype.indexOf) ? Array.prototype.indexOf :function(obj, fromIndex) {
   if (fromIndex === null || fromIndex === undefined) {
    fromIndex = 0;
   } else if (fromIndex < 0) {
    fromIndex = Math.max(0, this.length + fromIndex);
   }
   for (var i = fromIndex, j = this.length; i < j; i++) {
    if (this[i] === obj) {
     return i;
    }
   }
   return -1;
  };
  Ember.ArrayPolyfills = {
   map:arrayMap,
   forEach:arrayForEach,
   indexOf:arrayIndexOf
  };
  if (Ember.SHIM_ES5) {
   if (!Array.prototype.map) {
    Array.prototype.map = arrayMap;
   }
   if (!Array.prototype.forEach) {
    Array.prototype.forEach = arrayForEach;
   }
   if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = arrayIndexOf;
   }
  }
 })();
 (function() {
  var errorProps = [ "description", "fileName", "lineNumber", "message", "name", "number", "stack" ];
  Ember.Error = function() {
   var tmp = Error.apply(this, arguments);
   if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Ember.Error);
   }
   for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
   }
  };
  Ember.Error.prototype = Ember.create(Error.prototype);
  Ember.onerror = null;
  Ember.handleErrors = function(func, context) {
   if ("function" === typeof Ember.onerror) {
    try {
     return func.call(context || this);
    } catch (error) {
     Ember.onerror(error);
    }
   } else {
    return func.call(context || this);
   }
  };
 })();
 (function() {
  Ember.GUID_PREFIX = "ember";
  var o_defineProperty = Ember.platform.defineProperty, o_create = Ember.create, GUID_KEY = "__ember" + +new Date(), uuid = 0, numberCache = [], stringCache = {};
  var MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER;
  Ember.GUID_KEY = GUID_KEY;
  var GUID_DESC = {
   writable:false,
   configurable:false,
   enumerable:false,
   value:null
  };
  Ember.generateGuid = function generateGuid(obj, prefix) {
   if (!prefix) prefix = Ember.GUID_PREFIX;
   var ret = prefix + uuid++;
   if (obj) {
    GUID_DESC.value = ret;
    o_defineProperty(obj, GUID_KEY, GUID_DESC);
   }
   return ret;
  };
  Ember.guidFor = function guidFor(obj) {
   if (obj === undefined) return "(undefined)";
   if (obj === null) return "(null)";
   var ret;
   var type = typeof obj;
   switch (type) {
   case "number":
    ret = numberCache[obj];
    if (!ret) ret = numberCache[obj] = "nu" + obj;
    return ret;

   case "string":
    ret = stringCache[obj];
    if (!ret) ret = stringCache[obj] = "st" + uuid++;
    return ret;

   case "boolean":
    return obj ? "(true)" :"(false)";

   default:
    if (obj[GUID_KEY]) return obj[GUID_KEY];
    if (obj === Object) return "(Object)";
    if (obj === Array) return "(Array)";
    ret = "ember" + uuid++;
    GUID_DESC.value = ret;
    o_defineProperty(obj, GUID_KEY, GUID_DESC);
    return ret;
   }
  };
  var META_DESC = Ember.META_DESC = {
   writable:true,
   configurable:false,
   enumerable:false,
   value:null
  };
  var META_KEY = Ember.GUID_KEY + "_meta";
  Ember.META_KEY = META_KEY;
  var isDefinePropertySimulated = Ember.platform.defineProperty.isSimulated;
  function Meta(obj) {
   this.descs = {};
   this.watching = {};
   this.cache = {};
   this.source = obj;
  }
  Meta.prototype = {
   descs:null,
   deps:null,
   watching:null,
   listeners:null,
   cache:null,
   source:null,
   mixins:null,
   bindings:null,
   chains:null,
   chainWatchers:null,
   values:null,
   proto:null
  };
  if (isDefinePropertySimulated) {
   Meta.prototype.__preventPlainObject__ = true;
   Meta.prototype.toJSON = function() {};
  }
  var EMPTY_META = new Meta(null);
  if (MANDATORY_SETTER) {
   EMPTY_META.values = {};
  }
  Ember.EMPTY_META = EMPTY_META;
  Ember.meta = function meta(obj, writable) {
   var ret = obj[META_KEY];
   if (writable === false) return ret || EMPTY_META;
   if (!ret) {
    if (!isDefinePropertySimulated) o_defineProperty(obj, META_KEY, META_DESC);
    ret = new Meta(obj);
    if (MANDATORY_SETTER) {
     ret.values = {};
    }
    obj[META_KEY] = ret;
    ret.descs.constructor = null;
   } else if (ret.source !== obj) {
    if (!isDefinePropertySimulated) o_defineProperty(obj, META_KEY, META_DESC);
    ret = o_create(ret);
    ret.descs = o_create(ret.descs);
    ret.watching = o_create(ret.watching);
    ret.cache = {};
    ret.source = obj;
    if (MANDATORY_SETTER) {
     ret.values = o_create(ret.values);
    }
    obj[META_KEY] = ret;
   }
   return ret;
  };
  Ember.getMeta = function getMeta(obj, property) {
   var meta = Ember.meta(obj, false);
   return meta[property];
  };
  Ember.setMeta = function setMeta(obj, property, value) {
   var meta = Ember.meta(obj, true);
   meta[property] = value;
   return value;
  };
  Ember.metaPath = function metaPath(obj, path, writable) {
   var meta = Ember.meta(obj, writable), keyName, value;
   for (var i = 0, l = path.length; i < l; i++) {
    keyName = path[i];
    value = meta[keyName];
    if (!value) {
     if (!writable) {
      return undefined;
     }
     value = meta[keyName] = {
      __ember_source__:obj
     };
    } else if (value.__ember_source__ !== obj) {
     if (!writable) {
      return undefined;
     }
     value = meta[keyName] = o_create(value);
     value.__ember_source__ = obj;
    }
    meta = value;
   }
   return value;
  };
  Ember.wrap = function(func, superFunc) {
   function K() {}
   function superWrapper() {
    var ret, sup = this._super;
    this._super = superFunc || K;
    ret = func.apply(this, arguments);
    this._super = sup;
    return ret;
   }
   superWrapper.wrappedFunction = func;
   superWrapper.__ember_observes__ = func.__ember_observes__;
   superWrapper.__ember_observesBefore__ = func.__ember_observesBefore__;
   superWrapper.__ember_listens__ = func.__ember_listens__;
   return superWrapper;
  };
  Ember.isArray = function(obj) {
   if (!obj || obj.setInterval) {
    return false;
   }
   if (Array.isArray && Array.isArray(obj)) {
    return true;
   }
   if (Ember.Array && Ember.Array.detect(obj)) {
    return true;
   }
   if (obj.length !== undefined && "object" === typeof obj) {
    return true;
   }
   return false;
  };
  Ember.makeArray = function(obj) {
   if (obj === null || obj === undefined) {
    return [];
   }
   return Ember.isArray(obj) ? obj :[ obj ];
  };
  function canInvoke(obj, methodName) {
   return !!(obj && typeof obj[methodName] === "function");
  }
  Ember.canInvoke = canInvoke;
  Ember.tryInvoke = function(obj, methodName, args) {
   if (canInvoke(obj, methodName)) {
    return obj[methodName].apply(obj, args || []);
   }
  };
  var needsFinallyFix = function() {
   var count = 0;
   try {
    try {} finally {
     count++;
     throw new Error("needsFinallyFixTest");
    }
   } catch (e) {}
   return count !== 1;
  }();
  if (needsFinallyFix) {
   Ember.tryFinally = function(tryable, finalizer, binding) {
    var result, finalResult, finalError;
    binding = binding || this;
    try {
     result = tryable.call(binding);
    } finally {
     try {
      finalResult = finalizer.call(binding);
     } catch (e) {
      finalError = e;
     }
    }
    if (finalError) {
     throw finalError;
    }
    return finalResult === undefined ? result :finalResult;
   };
  } else {
   Ember.tryFinally = function(tryable, finalizer, binding) {
    var result, finalResult;
    binding = binding || this;
    try {
     result = tryable.call(binding);
    } finally {
     finalResult = finalizer.call(binding);
    }
    return finalResult === undefined ? result :finalResult;
   };
  }
  if (needsFinallyFix) {
   Ember.tryCatchFinally = function(tryable, catchable, finalizer, binding) {
    var result, finalResult, finalError;
    binding = binding || this;
    try {
     result = tryable.call(binding);
    } catch (error) {
     result = catchable.call(binding, error);
    } finally {
     try {
      finalResult = finalizer.call(binding);
     } catch (e) {
      finalError = e;
     }
    }
    if (finalError) {
     throw finalError;
    }
    return finalResult === undefined ? result :finalResult;
   };
  } else {
   Ember.tryCatchFinally = function(tryable, catchable, finalizer, binding) {
    var result, finalResult;
    binding = binding || this;
    try {
     result = tryable.call(binding);
    } catch (error) {
     result = catchable.call(binding, error);
    } finally {
     finalResult = finalizer.call(binding);
    }
    return finalResult === undefined ? result :finalResult;
   };
  }
  var TYPE_MAP = {};
  var t = "Boolean Number String Function Array Date RegExp Object".split(" ");
  Ember.ArrayPolyfills.forEach.call(t, function(name) {
   TYPE_MAP["[object " + name + "]"] = name.toLowerCase();
  });
  var toString = Object.prototype.toString;
  Ember.typeOf = function(item) {
   var ret;
   ret = item === null || item === undefined ? String(item) :TYPE_MAP[toString.call(item)] || "object";
   if (ret === "function") {
    if (Ember.Object && Ember.Object.detect(item)) ret = "class";
   } else if (ret === "object") {
    if (item instanceof Error) ret = "error"; else if (Ember.Object && item instanceof Ember.Object) ret = "instance"; else if (item instanceof Date) ret = "date";
   }
   return ret;
  };
  Ember.inspect = function(obj) {
   var type = Ember.typeOf(obj);
   if (type === "array") {
    return "[" + obj + "]";
   }
   if (type !== "object") {
    return obj + "";
   }
   var v, ret = [];
   for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
     v = obj[key];
     if (v === "toString") {
      continue;
     }
     if (Ember.typeOf(v) === "function") {
      v = "function() { ... }";
     }
     ret.push(key + ": " + v);
    }
   }
   return "{" + ret.join(", ") + "}";
  };
 })();
 (function() {
  Ember.Instrumentation = {};
  var subscribers = [], cache = {};
  var populateListeners = function(name) {
   var listeners = [], subscriber;
   for (var i = 0, l = subscribers.length; i < l; i++) {
    subscriber = subscribers[i];
    if (subscriber.regex.test(name)) {
     listeners.push(subscriber.object);
    }
   }
   cache[name] = listeners;
   return listeners;
  };
  var time = function() {
   var perf = "undefined" !== typeof window ? window.performance || {} :{};
   var fn = perf.now || perf.mozNow || perf.webkitNow || perf.msNow || perf.oNow;
   return fn ? fn.bind(perf) :function() {
    return +new Date();
   };
  }();
  Ember.Instrumentation.instrument = function(name, payload, callback, binding) {
   var listeners = cache[name], timeName, ret;
   if (Ember.STRUCTURED_PROFILE) {
    timeName = name + ": " + payload.object;
    console.time(timeName);
   }
   if (!listeners) {
    listeners = populateListeners(name);
   }
   if (listeners.length === 0) {
    ret = callback.call(binding);
    if (Ember.STRUCTURED_PROFILE) {
     console.timeEnd(timeName);
    }
    return ret;
   }
   var beforeValues = [], listener, i, l;
   function tryable() {
    for (i = 0, l = listeners.length; i < l; i++) {
     listener = listeners[i];
     beforeValues[i] = listener.before(name, time(), payload);
    }
    return callback.call(binding);
   }
   function catchable(e) {
    payload = payload || {};
    payload.exception = e;
   }
   function finalizer() {
    for (i = 0, l = listeners.length; i < l; i++) {
     listener = listeners[i];
     listener.after(name, time(), payload, beforeValues[i]);
    }
    if (Ember.STRUCTURED_PROFILE) {
     console.timeEnd(timeName);
    }
   }
   return Ember.tryCatchFinally(tryable, catchable, finalizer);
  };
  Ember.Instrumentation.subscribe = function(pattern, object) {
   var paths = pattern.split("."), path, regex = [];
   for (var i = 0, l = paths.length; i < l; i++) {
    path = paths[i];
    if (path === "*") {
     regex.push("[^\\.]*");
    } else {
     regex.push(path);
    }
   }
   regex = regex.join("\\.");
   regex = regex + "(\\..*)?";
   var subscriber = {
    pattern:pattern,
    regex:new RegExp("^" + regex + "$"),
    object:object
   };
   subscribers.push(subscriber);
   cache = {};
   return subscriber;
  };
  Ember.Instrumentation.unsubscribe = function(subscriber) {
   var index;
   for (var i = 0, l = subscribers.length; i < l; i++) {
    if (subscribers[i] === subscriber) {
     index = i;
    }
   }
   subscribers.splice(index, 1);
   cache = {};
  };
  Ember.Instrumentation.reset = function() {
   subscribers = [];
   cache = {};
  };
  Ember.instrument = Ember.Instrumentation.instrument;
  Ember.subscribe = Ember.Instrumentation.subscribe;
 })();
 (function() {
  var map, forEach, indexOf, splice, filter;
  map = Array.prototype.map || Ember.ArrayPolyfills.map;
  forEach = Array.prototype.forEach || Ember.ArrayPolyfills.forEach;
  indexOf = Array.prototype.indexOf || Ember.ArrayPolyfills.indexOf;
  filter = Array.prototype.filter || Ember.ArrayPolyfills.filter;
  splice = Array.prototype.splice;
  var utils = Ember.EnumerableUtils = {
   map:function(obj, callback, thisArg) {
    return obj.map ? obj.map.call(obj, callback, thisArg) :map.call(obj, callback, thisArg);
   },
   forEach:function(obj, callback, thisArg) {
    return obj.forEach ? obj.forEach.call(obj, callback, thisArg) :forEach.call(obj, callback, thisArg);
   },
   filter:function(obj, callback, thisArg) {
    return obj.filter ? obj.filter.call(obj, callback, thisArg) :filter.call(obj, callback, thisArg);
   },
   indexOf:function(obj, element, index) {
    return obj.indexOf ? obj.indexOf.call(obj, element, index) :indexOf.call(obj, element, index);
   },
   indexesOf:function(obj, elements) {
    return elements === undefined ? [] :utils.map(elements, function(item) {
     return utils.indexOf(obj, item);
    });
   },
   addObject:function(array, item) {
    var index = utils.indexOf(array, item);
    if (index === -1) {
     array.push(item);
    }
   },
   removeObject:function(array, item) {
    var index = utils.indexOf(array, item);
    if (index !== -1) {
     array.splice(index, 1);
    }
   },
   _replace:function(array, idx, amt, objects) {
    var args = [].concat(objects), chunk, ret = [], size = 6e4, start = idx, ends = amt, count;
    while (args.length) {
     count = ends > size ? size :ends;
     if (count <= 0) {
      count = 0;
     }
     chunk = args.splice(0, size);
     chunk = [ start, count ].concat(chunk);
     start += size;
     ends -= count;
     ret = ret.concat(splice.apply(array, chunk));
    }
    return ret;
   },
   replace:function(array, idx, amt, objects) {
    if (array.replace) {
     return array.replace(idx, amt, objects);
    } else {
     return utils._replace(array, idx, amt, objects);
    }
   },
   intersection:function(array1, array2) {
    var intersection = [];
    utils.forEach(array1, function(element) {
     if (utils.indexOf(array2, element) >= 0) {
      intersection.push(element);
     }
    });
    return intersection;
   }
  };
 })();
 (function() {
  var META_KEY = Ember.META_KEY, get;
  var MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER;
  var IS_GLOBAL_PATH = /^([A-Z$]|([0-9][A-Z$])).*[\.\*]/;
  var HAS_THIS = /^this[\.\*]/;
  var FIRST_KEY = /^([^\.\*]+)/;
  get = function get(obj, keyName) {
   if (keyName === "") {
    return obj;
   }
   if (!keyName && "string" === typeof obj) {
    keyName = obj;
    obj = null;
   }
   if (obj === null || keyName.indexOf(".") !== -1) {
    return getPath(obj, keyName);
   }
   var meta = obj[META_KEY], desc = meta && meta.descs[keyName], ret;
   if (desc) {
    return desc.get(obj, keyName);
   } else {
    if (MANDATORY_SETTER && meta && meta.watching[keyName] > 0) {
     ret = meta.values[keyName];
    } else {
     ret = obj[keyName];
    }
    if (ret === undefined && "object" === typeof obj && !(keyName in obj) && "function" === typeof obj.unknownProperty) {
     return obj.unknownProperty(keyName);
    }
    return ret;
   }
  };
  if (Ember.config.overrideAccessors) {
   Ember.get = get;
   Ember.config.overrideAccessors();
   get = Ember.get;
  }
  var normalizeTuple = Ember.normalizeTuple = function(target, path) {
   var hasThis = HAS_THIS.test(path), isGlobal = !hasThis && IS_GLOBAL_PATH.test(path), key;
   if (!target || isGlobal) target = Ember.lookup;
   if (hasThis) path = path.slice(5);
   if (target === Ember.lookup) {
    key = path.match(FIRST_KEY)[0];
    target = get(target, key);
    path = path.slice(key.length + 1);
   }
   if (!path || path.length === 0) throw new Ember.Error("Path cannot be empty");
   return [ target, path ];
  };
  var getPath = Ember._getPath = function(root, path) {
   var hasThis, parts, tuple, idx, len;
   if (root === null && path.indexOf(".") === -1) {
    return get(Ember.lookup, path);
   }
   hasThis = HAS_THIS.test(path);
   if (!root || hasThis) {
    tuple = normalizeTuple(root, path);
    root = tuple[0];
    path = tuple[1];
    tuple.length = 0;
   }
   parts = path.split(".");
   len = parts.length;
   for (idx = 0; root != null && idx < len; idx++) {
    root = get(root, parts[idx], true);
    if (root && root.isDestroyed) {
     return undefined;
    }
   }
   return root;
  };
  Ember.getWithDefault = function(root, key, defaultValue) {
   var value = get(root, key);
   if (value === undefined) {
    return defaultValue;
   }
   return value;
  };
  Ember.get = get;
 })();
 (function() {
  var o_create = Ember.create, metaFor = Ember.meta, META_KEY = Ember.META_KEY, a_slice = [].slice, ONCE = 1, SUSPENDED = 2;
  function indexOf(array, target, method) {
   var index = -1;
   for (var i = 0, l = array.length; i < l; i += 3) {
    if (target === array[i] && method === array[i + 1]) {
     index = i;
     break;
    }
   }
   return index;
  }
  function actionsFor(obj, eventName) {
   var meta = metaFor(obj, true), actions;
   if (!meta.listeners) {
    meta.listeners = {};
   }
   if (!meta.hasOwnProperty("listeners")) {
    meta.listeners = o_create(meta.listeners);
   }
   actions = meta.listeners[eventName];
   if (actions && !meta.listeners.hasOwnProperty(eventName)) {
    actions = meta.listeners[eventName] = meta.listeners[eventName].slice();
   } else if (!actions) {
    actions = meta.listeners[eventName] = [];
   }
   return actions;
  }
  function actionsUnion(obj, eventName, otherActions) {
   var meta = obj[META_KEY], actions = meta && meta.listeners && meta.listeners[eventName];
   if (!actions) {
    return;
   }
   for (var i = actions.length - 3; i >= 0; i -= 3) {
    var target = actions[i], method = actions[i + 1], flags = actions[i + 2], actionIndex = indexOf(otherActions, target, method);
    if (actionIndex === -1) {
     otherActions.push(target, method, flags);
    }
   }
  }
  function actionsDiff(obj, eventName, otherActions) {
   var meta = obj[META_KEY], actions = meta && meta.listeners && meta.listeners[eventName], diffActions = [];
   if (!actions) {
    return;
   }
   for (var i = actions.length - 3; i >= 0; i -= 3) {
    var target = actions[i], method = actions[i + 1], flags = actions[i + 2], actionIndex = indexOf(otherActions, target, method);
    if (actionIndex !== -1) {
     continue;
    }
    otherActions.push(target, method, flags);
    diffActions.push(target, method, flags);
   }
   return diffActions;
  }
  function addListener(obj, eventName, target, method, once) {
   if (!method && "function" === typeof target) {
    method = target;
    target = null;
   }
   var actions = actionsFor(obj, eventName), actionIndex = indexOf(actions, target, method), flags = 0;
   if (once) flags |= ONCE;
   if (actionIndex !== -1) {
    return;
   }
   actions.push(target, method, flags);
   if ("function" === typeof obj.didAddListener) {
    obj.didAddListener(eventName, target, method);
   }
  }
  function removeListener(obj, eventName, target, method) {
   if (!method && "function" === typeof target) {
    method = target;
    target = null;
   }
   function _removeListener(target, method) {
    var actions = actionsFor(obj, eventName), actionIndex = indexOf(actions, target, method);
    if (actionIndex === -1) {
     return;
    }
    actions.splice(actionIndex, 3);
    if ("function" === typeof obj.didRemoveListener) {
     obj.didRemoveListener(eventName, target, method);
    }
   }
   if (method) {
    _removeListener(target, method);
   } else {
    var meta = obj[META_KEY], actions = meta && meta.listeners && meta.listeners[eventName];
    if (!actions) {
     return;
    }
    for (var i = actions.length - 3; i >= 0; i -= 3) {
     _removeListener(actions[i], actions[i + 1]);
    }
   }
  }
  function suspendListener(obj, eventName, target, method, callback) {
   if (!method && "function" === typeof target) {
    method = target;
    target = null;
   }
   var actions = actionsFor(obj, eventName), actionIndex = indexOf(actions, target, method);
   if (actionIndex !== -1) {
    actions[actionIndex + 2] |= SUSPENDED;
   }
   function tryable() {
    return callback.call(target);
   }
   function finalizer() {
    if (actionIndex !== -1) {
     actions[actionIndex + 2] &= ~SUSPENDED;
    }
   }
   return Ember.tryFinally(tryable, finalizer);
  }
  function suspendListeners(obj, eventNames, target, method, callback) {
   if (!method && "function" === typeof target) {
    method = target;
    target = null;
   }
   var suspendedActions = [], actionsList = [], eventName, actions, i, l;
   for (i = 0, l = eventNames.length; i < l; i++) {
    eventName = eventNames[i];
    actions = actionsFor(obj, eventName);
    var actionIndex = indexOf(actions, target, method);
    if (actionIndex !== -1) {
     actions[actionIndex + 2] |= SUSPENDED;
     suspendedActions.push(actionIndex);
     actionsList.push(actions);
    }
   }
   function tryable() {
    return callback.call(target);
   }
   function finalizer() {
    for (var i = 0, l = suspendedActions.length; i < l; i++) {
     var actionIndex = suspendedActions[i];
     actionsList[i][actionIndex + 2] &= ~SUSPENDED;
    }
   }
   return Ember.tryFinally(tryable, finalizer);
  }
  function watchedEvents(obj) {
   var listeners = obj[META_KEY].listeners, ret = [];
   if (listeners) {
    for (var eventName in listeners) {
     if (listeners[eventName]) {
      ret.push(eventName);
     }
    }
   }
   return ret;
  }
  function sendEvent(obj, eventName, params, actions) {
   if (obj !== Ember && "function" === typeof obj.sendEvent) {
    obj.sendEvent(eventName, params);
   }
   if (!actions) {
    var meta = obj[META_KEY];
    actions = meta && meta.listeners && meta.listeners[eventName];
   }
   if (!actions) {
    return;
   }
   for (var i = actions.length - 3; i >= 0; i -= 3) {
    var target = actions[i], method = actions[i + 1], flags = actions[i + 2];
    if (!method) {
     continue;
    }
    if (flags & SUSPENDED) {
     continue;
    }
    if (flags & ONCE) {
     removeListener(obj, eventName, target, method);
    }
    if (!target) {
     target = obj;
    }
    if ("string" === typeof method) {
     method = target[method];
    }
    if (params) {
     method.apply(target, params);
    } else {
     method.call(target);
    }
   }
   return true;
  }
  function hasListeners(obj, eventName) {
   var meta = obj[META_KEY], actions = meta && meta.listeners && meta.listeners[eventName];
   return !!(actions && actions.length);
  }
  function listenersFor(obj, eventName) {
   var ret = [];
   var meta = obj[META_KEY], actions = meta && meta.listeners && meta.listeners[eventName];
   if (!actions) {
    return ret;
   }
   for (var i = 0, l = actions.length; i < l; i += 3) {
    var target = actions[i], method = actions[i + 1];
    ret.push([ target, method ]);
   }
   return ret;
  }
  Ember.on = function() {
   var func = a_slice.call(arguments, -1)[0], events = a_slice.call(arguments, 0, -1);
   func.__ember_listens__ = events;
   return func;
  };
  Ember.addListener = addListener;
  Ember.removeListener = removeListener;
  Ember._suspendListener = suspendListener;
  Ember._suspendListeners = suspendListeners;
  Ember.sendEvent = sendEvent;
  Ember.hasListeners = hasListeners;
  Ember.watchedEvents = watchedEvents;
  Ember.listenersFor = listenersFor;
  Ember.listenersDiff = actionsDiff;
  Ember.listenersUnion = actionsUnion;
 })();
 (function() {
  var guidFor = Ember.guidFor, sendEvent = Ember.sendEvent;
  var ObserverSet = Ember._ObserverSet = function() {
   this.clear();
  };
  ObserverSet.prototype.add = function(sender, keyName, eventName) {
   var observerSet = this.observerSet, observers = this.observers, senderGuid = guidFor(sender), keySet = observerSet[senderGuid], index;
   if (!keySet) {
    observerSet[senderGuid] = keySet = {};
   }
   index = keySet[keyName];
   if (index === undefined) {
    index = observers.push({
     sender:sender,
     keyName:keyName,
     eventName:eventName,
     listeners:[]
    }) - 1;
    keySet[keyName] = index;
   }
   return observers[index].listeners;
  };
  ObserverSet.prototype.flush = function() {
   var observers = this.observers, i, len, observer, sender;
   this.clear();
   for (i = 0, len = observers.length; i < len; ++i) {
    observer = observers[i];
    sender = observer.sender;
    if (sender.isDestroying || sender.isDestroyed) {
     continue;
    }
    sendEvent(sender, observer.eventName, [ sender, observer.keyName ], observer.listeners);
   }
  };
  ObserverSet.prototype.clear = function() {
   this.observerSet = {};
   this.observers = [];
  };
 })();
 (function() {
  var META_KEY = Ember.META_KEY, guidFor = Ember.guidFor, tryFinally = Ember.tryFinally, sendEvent = Ember.sendEvent, listenersUnion = Ember.listenersUnion, listenersDiff = Ember.listenersDiff, ObserverSet = Ember._ObserverSet, beforeObserverSet = new ObserverSet(), observerSet = new ObserverSet(), deferred = 0;
  function propertyWillChange(obj, keyName) {
   var m = obj[META_KEY], watching = m && m.watching[keyName] > 0 || keyName === "length", proto = m && m.proto, desc = m && m.descs[keyName];
   if (!watching) {
    return;
   }
   if (proto === obj) {
    return;
   }
   if (desc && desc.willChange) {
    desc.willChange(obj, keyName);
   }
   dependentKeysWillChange(obj, keyName, m);
   chainsWillChange(obj, keyName, m);
   notifyBeforeObservers(obj, keyName);
  }
  Ember.propertyWillChange = propertyWillChange;
  function propertyDidChange(obj, keyName) {
   var m = obj[META_KEY], watching = m && m.watching[keyName] > 0 || keyName === "length", proto = m && m.proto, desc = m && m.descs[keyName];
   if (proto === obj) {
    return;
   }
   if (desc && desc.didChange) {
    desc.didChange(obj, keyName);
   }
   if (!watching && keyName !== "length") {
    return;
   }
   dependentKeysDidChange(obj, keyName, m);
   chainsDidChange(obj, keyName, m, false);
   notifyObservers(obj, keyName);
  }
  Ember.propertyDidChange = propertyDidChange;
  var WILL_SEEN, DID_SEEN;
  function dependentKeysWillChange(obj, depKey, meta) {
   if (obj.isDestroying) {
    return;
   }
   var seen = WILL_SEEN, top = !seen;
   if (top) {
    seen = WILL_SEEN = {};
   }
   iterDeps(propertyWillChange, obj, depKey, seen, meta);
   if (top) {
    WILL_SEEN = null;
   }
  }
  function dependentKeysDidChange(obj, depKey, meta) {
   if (obj.isDestroying) {
    return;
   }
   var seen = DID_SEEN, top = !seen;
   if (top) {
    seen = DID_SEEN = {};
   }
   iterDeps(propertyDidChange, obj, depKey, seen, meta);
   if (top) {
    DID_SEEN = null;
   }
  }
  function iterDeps(method, obj, depKey, seen, meta) {
   var guid = guidFor(obj);
   if (!seen[guid]) seen[guid] = {};
   if (seen[guid][depKey]) return;
   seen[guid][depKey] = true;
   var deps = meta.deps;
   deps = deps && deps[depKey];
   if (deps) {
    for (var key in deps) {
     var desc = meta.descs[key];
     if (desc && desc._suspended === obj) continue;
     method(obj, key);
    }
   }
  }
  function chainsWillChange(obj, keyName, m) {
   if (!(m.hasOwnProperty("chainWatchers") && m.chainWatchers[keyName])) {
    return;
   }
   var nodes = m.chainWatchers[keyName], events = [], i, l;
   for (i = 0, l = nodes.length; i < l; i++) {
    nodes[i].willChange(events);
   }
   for (i = 0, l = events.length; i < l; i += 2) {
    propertyWillChange(events[i], events[i + 1]);
   }
  }
  function chainsDidChange(obj, keyName, m, suppressEvents) {
   if (!(m && m.hasOwnProperty("chainWatchers") && m.chainWatchers[keyName])) {
    return;
   }
   var nodes = m.chainWatchers[keyName], events = suppressEvents ? null :[], i, l;
   for (i = 0, l = nodes.length; i < l; i++) {
    nodes[i].didChange(events);
   }
   if (suppressEvents) {
    return;
   }
   for (i = 0, l = events.length; i < l; i += 2) {
    propertyDidChange(events[i], events[i + 1]);
   }
  }
  Ember.overrideChains = function(obj, keyName, m) {
   chainsDidChange(obj, keyName, m, true);
  };
  function beginPropertyChanges() {
   deferred++;
  }
  Ember.beginPropertyChanges = beginPropertyChanges;
  function endPropertyChanges() {
   deferred--;
   if (deferred <= 0) {
    beforeObserverSet.clear();
    observerSet.flush();
   }
  }
  Ember.endPropertyChanges = endPropertyChanges;
  Ember.changeProperties = function(cb, binding) {
   beginPropertyChanges();
   tryFinally(cb, endPropertyChanges, binding);
  };
  function notifyBeforeObservers(obj, keyName) {
   if (obj.isDestroying) {
    return;
   }
   var eventName = keyName + ":before", listeners, diff;
   if (deferred) {
    listeners = beforeObserverSet.add(obj, keyName, eventName);
    diff = listenersDiff(obj, eventName, listeners);
    sendEvent(obj, eventName, [ obj, keyName ], diff);
   } else {
    sendEvent(obj, eventName, [ obj, keyName ]);
   }
  }
  function notifyObservers(obj, keyName) {
   if (obj.isDestroying) {
    return;
   }
   var eventName = keyName + ":change", listeners;
   if (deferred) {
    listeners = observerSet.add(obj, keyName, eventName);
    listenersUnion(obj, eventName, listeners);
   } else {
    sendEvent(obj, eventName, [ obj, keyName ]);
   }
  }
 })();
 (function() {
  var META_KEY = Ember.META_KEY, MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER, IS_GLOBAL = /^([A-Z$]|([0-9][A-Z$]))/, getPath = Ember._getPath;
  var set = function set(obj, keyName, value, tolerant) {
   if (typeof obj === "string") {
    value = keyName;
    keyName = obj;
    obj = null;
   }
   if (!obj || keyName.indexOf(".") !== -1) {
    return setPath(obj, keyName, value, tolerant);
   }
   var meta = obj[META_KEY], desc = meta && meta.descs[keyName], isUnknown, currentValue;
   if (desc) {
    desc.set(obj, keyName, value);
   } else {
    isUnknown = "object" === typeof obj && !(keyName in obj);
    if (isUnknown && "function" === typeof obj.setUnknownProperty) {
     obj.setUnknownProperty(keyName, value);
    } else if (meta && meta.watching[keyName] > 0) {
     if (MANDATORY_SETTER) {
      currentValue = meta.values[keyName];
     } else {
      currentValue = obj[keyName];
     }
     if (value !== currentValue) {
      Ember.propertyWillChange(obj, keyName);
      if (MANDATORY_SETTER) {
       if (currentValue === undefined && !(keyName in obj) || !obj.propertyIsEnumerable(keyName)) {
        Ember.defineProperty(obj, keyName, null, value);
       } else {
        meta.values[keyName] = value;
       }
      } else {
       obj[keyName] = value;
      }
      Ember.propertyDidChange(obj, keyName);
     }
    } else {
     obj[keyName] = value;
    }
   }
   return value;
  };
  if (Ember.config.overrideAccessors) {
   Ember.set = set;
   Ember.config.overrideAccessors();
   set = Ember.set;
  }
  function setPath(root, path, value, tolerant) {
   var keyName;
   keyName = path.slice(path.lastIndexOf(".") + 1);
   path = path === keyName ? keyName :path.slice(0, path.length - (keyName.length + 1));
   if (path !== "this") {
    root = getPath(root, path);
   }
   if (!keyName || keyName.length === 0) {
    throw new Ember.Error("Property set failed: You passed an empty path");
   }
   if (!root) {
    if (tolerant) {
     return;
    } else {
     throw new Ember.Error('Property set failed: object in path "' + path + '" could not be found or was destroyed.');
    }
   }
   return set(root, keyName, value);
  }
  Ember.set = set;
  Ember.trySet = function(root, path, value) {
   return set(root, path, value, true);
  };
 })();
 (function() {
  var set = Ember.set, guidFor = Ember.guidFor, indexOf = Ember.ArrayPolyfills.indexOf;
  var copy = function(obj) {
   var output = {};
   for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
     output[prop] = obj[prop];
    }
   }
   return output;
  };
  var copyMap = function(original, newObject) {
   var keys = original.keys.copy(), values = copy(original.values);
   newObject.keys = keys;
   newObject.values = values;
   newObject.length = original.length;
   return newObject;
  };
  var OrderedSet = Ember.OrderedSet = function() {
   this.clear();
  };
  OrderedSet.create = function() {
   return new OrderedSet();
  };
  OrderedSet.prototype = {
   clear:function() {
    this.presenceSet = {};
    this.list = [];
   },
   add:function(obj) {
    var guid = guidFor(obj), presenceSet = this.presenceSet, list = this.list;
    if (guid in presenceSet) {
     return;
    }
    presenceSet[guid] = true;
    list.push(obj);
   },
   remove:function(obj) {
    var guid = guidFor(obj), presenceSet = this.presenceSet, list = this.list;
    delete presenceSet[guid];
    var index = indexOf.call(list, obj);
    if (index > -1) {
     list.splice(index, 1);
    }
   },
   isEmpty:function() {
    return this.list.length === 0;
   },
   has:function(obj) {
    var guid = guidFor(obj), presenceSet = this.presenceSet;
    return guid in presenceSet;
   },
   forEach:function(fn, self) {
    var list = this.toArray();
    for (var i = 0, j = list.length; i < j; i++) {
     fn.call(self, list[i]);
    }
   },
   toArray:function() {
    return this.list.slice();
   },
   copy:function() {
    var set = new OrderedSet();
    set.presenceSet = copy(this.presenceSet);
    set.list = this.toArray();
    return set;
   }
  };
  var Map = Ember.Map = function() {
   this.keys = Ember.OrderedSet.create();
   this.values = {};
  };
  Map.create = function() {
   return new Map();
  };
  Map.prototype = {
   length:0,
   get:function(key) {
    var values = this.values, guid = guidFor(key);
    return values[guid];
   },
   set:function(key, value) {
    var keys = this.keys, values = this.values, guid = guidFor(key);
    keys.add(key);
    values[guid] = value;
    set(this, "length", keys.list.length);
   },
   remove:function(key) {
    var keys = this.keys, values = this.values, guid = guidFor(key);
    if (values.hasOwnProperty(guid)) {
     keys.remove(key);
     delete values[guid];
     set(this, "length", keys.list.length);
     return true;
    } else {
     return false;
    }
   },
   has:function(key) {
    var values = this.values, guid = guidFor(key);
    return values.hasOwnProperty(guid);
   },
   forEach:function(callback, self) {
    var keys = this.keys, values = this.values;
    keys.forEach(function(key) {
     var guid = guidFor(key);
     callback.call(self, key, values[guid]);
    });
   },
   copy:function() {
    return copyMap(this, new Map());
   }
  };
  var MapWithDefault = Ember.MapWithDefault = function(options) {
   Map.call(this);
   this.defaultValue = options.defaultValue;
  };
  MapWithDefault.create = function(options) {
   if (options) {
    return new MapWithDefault(options);
   } else {
    return new Map();
   }
  };
  MapWithDefault.prototype = Ember.create(Map.prototype);
  MapWithDefault.prototype.get = function(key) {
   var hasValue = this.has(key);
   if (hasValue) {
    return Map.prototype.get.call(this, key);
   } else {
    var defaultValue = this.defaultValue(key);
    this.set(key, defaultValue);
    return defaultValue;
   }
  };
  MapWithDefault.prototype.copy = function() {
   return copyMap(this, new MapWithDefault({
    defaultValue:this.defaultValue
   }));
  };
 })();
 (function() {
  function consoleMethod(name) {
   var consoleObj, logToConsole;
   if (Ember.imports.console) {
    consoleObj = Ember.imports.console;
   } else if (typeof console !== "undefined") {
    consoleObj = console;
   }
   var method = typeof consoleObj === "object" ? consoleObj[name] :null;
   if (method) {
    if (method.apply) {
     logToConsole = function() {
      method.apply(consoleObj, arguments);
     };
     logToConsole.displayName = "console." + name;
     return logToConsole;
    } else {
     return function() {
      var message = Array.prototype.join.call(arguments, ", ");
      method(message);
     };
    }
   }
  }
  function assertPolyfill(test, message) {
   if (!test) {
    try {
     throw new Ember.Error("assertion failed: " + message);
    } catch (error) {
     setTimeout(function() {
      throw error;
     }, 0);
    }
   }
  }
  Ember.Logger = {
   log:consoleMethod("log") || Ember.K,
   warn:consoleMethod("warn") || Ember.K,
   error:consoleMethod("error") || Ember.K,
   info:consoleMethod("info") || Ember.K,
   debug:consoleMethod("debug") || consoleMethod("info") || Ember.K,
   assert:consoleMethod("assert") || assertPolyfill
  };
 })();
 (function() {
  var META_KEY = Ember.META_KEY, metaFor = Ember.meta, objectDefineProperty = Ember.platform.defineProperty;
  var MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER;
  Ember.Descriptor = function() {};
  var MANDATORY_SETTER_FUNCTION = Ember.MANDATORY_SETTER_FUNCTION = function(value) {};
  var DEFAULT_GETTER_FUNCTION = Ember.DEFAULT_GETTER_FUNCTION = function(name) {
   return function() {
    var meta = this[META_KEY];
    return meta && meta.values[name];
   };
  };
  Ember.defineProperty = function(obj, keyName, desc, data, meta) {
   var descs, existingDesc, watching, value;
   if (!meta) meta = metaFor(obj);
   descs = meta.descs;
   existingDesc = meta.descs[keyName];
   watching = meta.watching[keyName] > 0;
   if (existingDesc instanceof Ember.Descriptor) {
    existingDesc.teardown(obj, keyName);
   }
   if (desc instanceof Ember.Descriptor) {
    value = desc;
    descs[keyName] = desc;
    if (MANDATORY_SETTER && watching) {
     objectDefineProperty(obj, keyName, {
      configurable:true,
      enumerable:true,
      writable:true,
      value:undefined
     });
    } else {
     obj[keyName] = undefined;
    }
    if (desc.func && desc._dependentCPs) {
     addImplicitCPs(obj, desc._dependentCPs, meta);
    }
   } else {
    descs[keyName] = undefined;
    if (desc == null) {
     value = data;
     if (MANDATORY_SETTER && watching) {
      meta.values[keyName] = data;
      objectDefineProperty(obj, keyName, {
       configurable:true,
       enumerable:true,
       set:MANDATORY_SETTER_FUNCTION,
       get:DEFAULT_GETTER_FUNCTION(keyName)
      });
     } else {
      obj[keyName] = data;
     }
    } else {
     value = desc;
     objectDefineProperty(obj, keyName, desc);
    }
   }
   if (watching) {
    Ember.overrideChains(obj, keyName, meta);
   }
   if (obj.didDefineProperty) {
    obj.didDefineProperty(obj, keyName, value);
   }
   return this;
  };
  var addImplicitCPs = function defineImplicitCPs(obj, implicitCPs, meta) {
   var cp, key, length = implicitCPs.length;
   for (var i = 0; i < length; ++i) {
    cp = implicitCPs[i];
    key = cp.implicitCPKey;
    Ember.defineProperty(obj, key, cp, undefined, meta);
    if (cp._dependentCPs) {
     addImplicitCPs(obj, cp._dependentCPs, meta);
    }
   }
  };
 })();
 (function() {
  var get = Ember.get;
  Ember.getProperties = function(obj) {
   var ret = {}, propertyNames = arguments, i = 1;
   if (arguments.length === 2 && Ember.typeOf(arguments[1]) === "array") {
    i = 0;
    propertyNames = arguments[1];
   }
   for (var len = propertyNames.length; i < len; i++) {
    ret[propertyNames[i]] = get(obj, propertyNames[i]);
   }
   return ret;
  };
 })();
 (function() {
  var changeProperties = Ember.changeProperties, set = Ember.set;
  Ember.setProperties = function(self, hash) {
   changeProperties(function() {
    for (var prop in hash) {
     if (hash.hasOwnProperty(prop)) {
      set(self, prop, hash[prop]);
     }
    }
   });
   return self;
  };
 })();
 (function() {
  var metaFor = Ember.meta, typeOf = Ember.typeOf, MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER, o_defineProperty = Ember.platform.defineProperty;
  Ember.watchKey = function(obj, keyName, meta) {
   if (keyName === "length" && typeOf(obj) === "array") {
    return;
   }
   var m = meta || metaFor(obj), watching = m.watching;
   if (!watching[keyName]) {
    watching[keyName] = 1;
    if ("function" === typeof obj.willWatchProperty) {
     obj.willWatchProperty(keyName);
    }
    if (MANDATORY_SETTER && keyName in obj) {
     m.values[keyName] = obj[keyName];
     o_defineProperty(obj, keyName, {
      configurable:true,
      enumerable:obj.propertyIsEnumerable(keyName),
      set:Ember.MANDATORY_SETTER_FUNCTION,
      get:Ember.DEFAULT_GETTER_FUNCTION(keyName)
     });
    }
   } else {
    watching[keyName] = (watching[keyName] || 0) + 1;
   }
  };
  Ember.unwatchKey = function(obj, keyName, meta) {
   var m = meta || metaFor(obj), watching = m.watching;
   if (watching[keyName] === 1) {
    watching[keyName] = 0;
    if ("function" === typeof obj.didUnwatchProperty) {
     obj.didUnwatchProperty(keyName);
    }
    if (MANDATORY_SETTER && keyName in obj) {
     o_defineProperty(obj, keyName, {
      configurable:true,
      enumerable:obj.propertyIsEnumerable(keyName),
      set:function(val) {
       o_defineProperty(obj, keyName, {
        configurable:true,
        writable:true,
        enumerable:true,
        value:val
       });
       delete m.values[keyName];
      },
      get:Ember.DEFAULT_GETTER_FUNCTION(keyName)
     });
    }
   } else if (watching[keyName] > 1) {
    watching[keyName]--;
   }
  };
 })();
 (function() {
  var metaFor = Ember.meta, get = Ember.get, normalizeTuple = Ember.normalizeTuple, forEach = Ember.ArrayPolyfills.forEach, warn = Ember.warn, watchKey = Ember.watchKey, unwatchKey = Ember.unwatchKey, FIRST_KEY = /^([^\.\*]+)/, META_KEY = Ember.META_KEY;
  function firstKey(path) {
   return path.match(FIRST_KEY)[0];
  }
  var pendingQueue = [];
  Ember.flushPendingChains = function() {
   if (pendingQueue.length === 0) {
    return;
   }
   var queue = pendingQueue;
   pendingQueue = [];
   forEach.call(queue, function(q) {
    q[0].add(q[1]);
   });
   warn("Watching an undefined global, Ember expects watched globals to be setup by the time the run loop is flushed, check for typos", pendingQueue.length === 0);
  };
  function addChainWatcher(obj, keyName, node) {
   if (!obj || "object" !== typeof obj) {
    return;
   }
   var m = metaFor(obj), nodes = m.chainWatchers;
   if (!m.hasOwnProperty("chainWatchers")) {
    nodes = m.chainWatchers = {};
   }
   if (!nodes[keyName]) {
    nodes[keyName] = [];
   }
   nodes[keyName].push(node);
   watchKey(obj, keyName, m);
  }
  var removeChainWatcher = Ember.removeChainWatcher = function(obj, keyName, node) {
   if (!obj || "object" !== typeof obj) {
    return;
   }
   var m = obj[META_KEY];
   if (m && !m.hasOwnProperty("chainWatchers")) {
    return;
   }
   var nodes = m && m.chainWatchers;
   if (nodes && nodes[keyName]) {
    nodes = nodes[keyName];
    for (var i = 0, l = nodes.length; i < l; i++) {
     if (nodes[i] === node) {
      nodes.splice(i, 1);
     }
    }
   }
   unwatchKey(obj, keyName, m);
  };
  var ChainNode = Ember._ChainNode = function(parent, key, value) {
   this._parent = parent;
   this._key = key;
   this._watching = value === undefined;
   this._value = value;
   this._paths = {};
   if (this._watching) {
    this._object = parent.value();
    if (this._object) {
     addChainWatcher(this._object, this._key, this);
    }
   }
   if (this._parent && this._parent._key === "@each") {
    this.value();
   }
  };
  var ChainNodePrototype = ChainNode.prototype;
  function lazyGet(obj, key) {
   if (!obj) return undefined;
   var meta = obj[META_KEY];
   if (meta && meta.proto === obj) return undefined;
   if (key === "@each") return get(obj, key);
   var desc = meta && meta.descs[key];
   if (desc && desc._cacheable) {
    if (key in meta.cache) {
     return meta.cache[key];
    } else {
     return undefined;
    }
   }
   return get(obj, key);
  }
  ChainNodePrototype.value = function() {
   if (this._value === undefined && this._watching) {
    var obj = this._parent.value();
    this._value = lazyGet(obj, this._key);
   }
   return this._value;
  };
  ChainNodePrototype.destroy = function() {
   if (this._watching) {
    var obj = this._object;
    if (obj) {
     removeChainWatcher(obj, this._key, this);
    }
    this._watching = false;
   }
  };
  ChainNodePrototype.copy = function(obj) {
   var ret = new ChainNode(null, null, obj), paths = this._paths, path;
   for (path in paths) {
    if (paths[path] <= 0) {
     continue;
    }
    ret.add(path);
   }
   return ret;
  };
  ChainNodePrototype.add = function(path) {
   var obj, tuple, key, src, paths;
   paths = this._paths;
   paths[path] = (paths[path] || 0) + 1;
   obj = this.value();
   tuple = normalizeTuple(obj, path);
   if (tuple[0] && tuple[0] === obj) {
    path = tuple[1];
    key = firstKey(path);
    path = path.slice(key.length + 1);
   } else if (!tuple[0]) {
    pendingQueue.push([ this, path ]);
    tuple.length = 0;
    return;
   } else {
    src = tuple[0];
    key = path.slice(0, 0 - (tuple[1].length + 1));
    path = tuple[1];
   }
   tuple.length = 0;
   this.chain(key, path, src);
  };
  ChainNodePrototype.remove = function(path) {
   var obj, tuple, key, src, paths;
   paths = this._paths;
   if (paths[path] > 0) {
    paths[path]--;
   }
   obj = this.value();
   tuple = normalizeTuple(obj, path);
   if (tuple[0] === obj) {
    path = tuple[1];
    key = firstKey(path);
    path = path.slice(key.length + 1);
   } else {
    src = tuple[0];
    key = path.slice(0, 0 - (tuple[1].length + 1));
    path = tuple[1];
   }
   tuple.length = 0;
   this.unchain(key, path);
  };
  ChainNodePrototype.count = 0;
  ChainNodePrototype.chain = function(key, path, src) {
   var chains = this._chains, node;
   if (!chains) {
    chains = this._chains = {};
   }
   node = chains[key];
   if (!node) {
    node = chains[key] = new ChainNode(this, key, src);
   }
   node.count++;
   if (path && path.length > 0) {
    key = firstKey(path);
    path = path.slice(key.length + 1);
    node.chain(key, path);
   }
  };
  ChainNodePrototype.unchain = function(key, path) {
   var chains = this._chains, node = chains[key];
   if (path && path.length > 1) {
    key = firstKey(path);
    path = path.slice(key.length + 1);
    node.unchain(key, path);
   }
   node.count--;
   if (node.count <= 0) {
    delete chains[node._key];
    node.destroy();
   }
  };
  ChainNodePrototype.willChange = function(events) {
   var chains = this._chains;
   if (chains) {
    for (var key in chains) {
     if (!chains.hasOwnProperty(key)) {
      continue;
     }
     chains[key].willChange(events);
    }
   }
   if (this._parent) {
    this._parent.chainWillChange(this, this._key, 1, events);
   }
  };
  ChainNodePrototype.chainWillChange = function(chain, path, depth, events) {
   if (this._key) {
    path = this._key + "." + path;
   }
   if (this._parent) {
    this._parent.chainWillChange(this, path, depth + 1, events);
   } else {
    if (depth > 1) {
     events.push(this.value(), path);
    }
    path = "this." + path;
    if (this._paths[path] > 0) {
     events.push(this.value(), path);
    }
   }
  };
  ChainNodePrototype.chainDidChange = function(chain, path, depth, events) {
   if (this._key) {
    path = this._key + "." + path;
   }
   if (this._parent) {
    this._parent.chainDidChange(this, path, depth + 1, events);
   } else {
    if (depth > 1) {
     events.push(this.value(), path);
    }
    path = "this." + path;
    if (this._paths[path] > 0) {
     events.push(this.value(), path);
    }
   }
  };
  ChainNodePrototype.didChange = function(events) {
   if (this._watching) {
    var obj = this._parent.value();
    if (obj !== this._object) {
     removeChainWatcher(this._object, this._key, this);
     this._object = obj;
     addChainWatcher(obj, this._key, this);
    }
    this._value = undefined;
    if (this._parent && this._parent._key === "@each") this.value();
   }
   var chains = this._chains;
   if (chains) {
    for (var key in chains) {
     if (!chains.hasOwnProperty(key)) {
      continue;
     }
     chains[key].didChange(events);
    }
   }
   if (events === null) {
    return;
   }
   if (this._parent) {
    this._parent.chainDidChange(this, this._key, 1, events);
   }
  };
  Ember.finishChains = function(obj) {
   var m = obj[META_KEY], chains = m && m.chains;
   if (chains) {
    if (chains.value() !== obj) {
     metaFor(obj).chains = chains = chains.copy(obj);
    } else {
     chains.didChange(null);
    }
   }
  };
 })();
 (function() {
  var forEach = Ember.EnumerableUtils.forEach, BRACE_EXPANSION = /^((?:[^\.]*\.)*)\{(.*)\}$/;
  Ember.expandProperties = function(pattern, callback) {
   var match, prefix, list;
   if (match = BRACE_EXPANSION.exec(pattern)) {
    prefix = match[1];
    list = match[2];
    forEach(list.split(","), function(suffix) {
     callback(prefix + suffix);
    });
   } else {
    callback(pattern);
   }
  };
 })();
 (function() {
  var metaFor = Ember.meta, typeOf = Ember.typeOf, ChainNode = Ember._ChainNode;
  function chainsFor(obj, meta) {
   var m = meta || metaFor(obj), ret = m.chains;
   if (!ret) {
    ret = m.chains = new ChainNode(null, null, obj);
   } else if (ret.value() !== obj) {
    ret = m.chains = ret.copy(obj);
   }
   return ret;
  }
  Ember.watchPath = function(obj, keyPath, meta) {
   if (keyPath === "length" && typeOf(obj) === "array") {
    return;
   }
   var m = meta || metaFor(obj), watching = m.watching;
   if (!watching[keyPath]) {
    watching[keyPath] = 1;
    chainsFor(obj, m).add(keyPath);
   } else {
    watching[keyPath] = (watching[keyPath] || 0) + 1;
   }
  };
  Ember.unwatchPath = function(obj, keyPath, meta) {
   var m = meta || metaFor(obj), watching = m.watching;
   if (watching[keyPath] === 1) {
    watching[keyPath] = 0;
    chainsFor(obj, m).remove(keyPath);
   } else if (watching[keyPath] > 1) {
    watching[keyPath]--;
   }
  };
 })();
 (function() {
  var metaFor = Ember.meta, GUID_KEY = Ember.GUID_KEY, META_KEY = Ember.META_KEY, removeChainWatcher = Ember.removeChainWatcher, watchKey = Ember.watchKey, unwatchKey = Ember.unwatchKey, watchPath = Ember.watchPath, unwatchPath = Ember.unwatchPath, typeOf = Ember.typeOf, generateGuid = Ember.generateGuid, IS_PATH = /[\.\*]/;
  function isKeyName(path) {
   return path === "*" || !IS_PATH.test(path);
  }
  Ember.watch = function(obj, _keyPath, m) {
   if (_keyPath === "length" && typeOf(obj) === "array") {
    return;
   }
   if (isKeyName(_keyPath)) {
    watchKey(obj, _keyPath, m);
   } else {
    watchPath(obj, _keyPath, m);
   }
  };
  Ember.isWatching = function isWatching(obj, key) {
   var meta = obj[META_KEY];
   return (meta && meta.watching[key]) > 0;
  };
  Ember.watch.flushPending = Ember.flushPendingChains;
  Ember.unwatch = function(obj, _keyPath, m) {
   if (_keyPath === "length" && typeOf(obj) === "array") {
    return;
   }
   if (isKeyName(_keyPath)) {
    unwatchKey(obj, _keyPath, m);
   } else {
    unwatchPath(obj, _keyPath, m);
   }
  };
  Ember.rewatch = function(obj) {
   var m = obj[META_KEY], chains = m && m.chains;
   if (GUID_KEY in obj && !obj.hasOwnProperty(GUID_KEY)) {
    generateGuid(obj);
   }
   if (chains && chains.value() !== obj) {
    m.chains = chains.copy(obj);
   }
  };
  var NODE_STACK = [];
  Ember.destroy = function(obj) {
   var meta = obj[META_KEY], node, nodes, key, nodeObject;
   if (meta) {
    obj[META_KEY] = null;
    node = meta.chains;
    if (node) {
     NODE_STACK.push(node);
     while (NODE_STACK.length > 0) {
      node = NODE_STACK.pop();
      nodes = node._chains;
      if (nodes) {
       for (key in nodes) {
        if (nodes.hasOwnProperty(key)) {
         NODE_STACK.push(nodes[key]);
        }
       }
      }
      if (node._watching) {
       nodeObject = node._object;
       if (nodeObject) {
        removeChainWatcher(nodeObject, node._key, node);
       }
      }
     }
    }
   }
  };
 })();
 (function() {
  var get = Ember.get, set = Ember.set, metaFor = Ember.meta, a_slice = [].slice, o_create = Ember.create, META_KEY = Ember.META_KEY, watch = Ember.watch, unwatch = Ember.unwatch;
  var expandProperties = Ember.expandProperties;
  function keysForDep(depsMeta, depKey) {
   var keys = depsMeta[depKey];
   if (!keys) {
    keys = depsMeta[depKey] = {};
   } else if (!depsMeta.hasOwnProperty(depKey)) {
    keys = depsMeta[depKey] = o_create(keys);
   }
   return keys;
  }
  function metaForDeps(meta) {
   return keysForDep(meta, "deps");
  }
  function addDependentKeys(desc, obj, keyName, meta) {
   var depKeys = desc._dependentKeys, depsMeta, idx, len, depKey, keys;
   if (!depKeys) return;
   depsMeta = metaForDeps(meta);
   for (idx = 0, len = depKeys.length; idx < len; idx++) {
    depKey = depKeys[idx];
    keys = keysForDep(depsMeta, depKey);
    keys[keyName] = (keys[keyName] || 0) + 1;
    watch(obj, depKey, meta);
   }
  }
  function removeDependentKeys(desc, obj, keyName, meta) {
   var depKeys = desc._dependentKeys, depsMeta, idx, len, depKey, keys;
   if (!depKeys) return;
   depsMeta = metaForDeps(meta);
   for (idx = 0, len = depKeys.length; idx < len; idx++) {
    depKey = depKeys[idx];
    keys = keysForDep(depsMeta, depKey);
    keys[keyName] = (keys[keyName] || 0) - 1;
    unwatch(obj, depKey, meta);
   }
  }
  function ComputedProperty(func, opts) {
   this.func = func;
   setDependentKeys(this, opts && opts.dependentKeys);
   this._cacheable = opts && opts.cacheable !== undefined ? opts.cacheable :true;
   this._readOnly = opts && (opts.readOnly !== undefined || !!opts.readOnly);
  }
  Ember.ComputedProperty = ComputedProperty;
  ComputedProperty.prototype = new Ember.Descriptor();
  var ComputedPropertyPrototype = ComputedProperty.prototype;
  ComputedPropertyPrototype.toString = function() {
   if (this.implicitCPKey) {
    return this.implicitCPKey;
   }
   return Ember.Descriptor.prototype.toString.apply(this, arguments);
  };
  ComputedPropertyPrototype.cacheable = function(aFlag) {
   this._cacheable = aFlag !== false;
   return this;
  };
  ComputedPropertyPrototype.volatile = function() {
   return this.cacheable(false);
  };
  ComputedPropertyPrototype.readOnly = function(readOnly) {
   this._readOnly = readOnly === undefined || !!readOnly;
   return this;
  };
  ComputedPropertyPrototype.property = function() {
   var args;
   var addArg = function(property) {
    args.push(property);
   };
   args = [];
   for (var i = 0, l = arguments.length; i < l; i++) {
    expandProperties(arguments[i], addArg);
   }
   setDependentKeys(this, args);
   return this;
  };
  ComputedPropertyPrototype.meta = function(meta) {
   if (arguments.length === 0) {
    return this._meta || {};
   } else {
    this._meta = meta;
    return this;
   }
  };
  ComputedPropertyPrototype.didChange = function(obj, keyName) {
   if (this._cacheable && this._suspended !== obj) {
    var meta = metaFor(obj);
    if (keyName in meta.cache) {
     delete meta.cache[keyName];
     removeDependentKeys(this, obj, keyName, meta);
    }
   }
  };
  function finishChains(chainNodes) {
   for (var i = 0, l = chainNodes.length; i < l; i++) {
    chainNodes[i].didChange(null);
   }
  }
  ComputedPropertyPrototype.get = function(obj, keyName) {
   var ret, cache, meta, chainNodes;
   if (this._cacheable) {
    meta = metaFor(obj);
    cache = meta.cache;
    if (keyName in cache) {
     return cache[keyName];
    }
    ret = cache[keyName] = this.func.call(obj, keyName);
    chainNodes = meta.chainWatchers && meta.chainWatchers[keyName];
    if (chainNodes) {
     finishChains(chainNodes);
    }
    addDependentKeys(this, obj, keyName, meta);
   } else {
    ret = this.func.call(obj, keyName);
   }
   return ret;
  };
  ComputedPropertyPrototype.set = function(obj, keyName, value) {
   var cacheable = this._cacheable, func = this.func, meta = metaFor(obj, cacheable), watched = meta.watching[keyName], oldSuspended = this._suspended, hadCachedValue = false, cache = meta.cache, funcArgLength, cachedValue, ret;
   if (this._readOnly) {
    throw new Ember.Error("Cannot Set: " + keyName + " on: " + Ember.inspect(obj));
   }
   this._suspended = obj;
   try {
    if (cacheable && cache.hasOwnProperty(keyName)) {
     cachedValue = cache[keyName];
     hadCachedValue = true;
    }
    funcArgLength = func.wrappedFunction ? func.wrappedFunction.length :func.length;
    if (funcArgLength === 3) {
     ret = func.call(obj, keyName, value, cachedValue);
    } else if (funcArgLength === 2) {
     ret = func.call(obj, keyName, value);
    } else {
     Ember.defineProperty(obj, keyName, null, cachedValue);
     Ember.set(obj, keyName, value);
     return;
    }
    if (hadCachedValue && cachedValue === ret) {
     return;
    }
    if (watched) {
     Ember.propertyWillChange(obj, keyName);
    }
    if (hadCachedValue) {
     delete cache[keyName];
    }
    if (cacheable) {
     if (!hadCachedValue) {
      addDependentKeys(this, obj, keyName, meta);
     }
     cache[keyName] = ret;
    }
    if (watched) {
     Ember.propertyDidChange(obj, keyName);
    }
   } finally {
    this._suspended = oldSuspended;
   }
   return ret;
  };
  ComputedPropertyPrototype.teardown = function(obj, keyName) {
   var meta = metaFor(obj);
   if (keyName in meta.cache) {
    removeDependentKeys(this, obj, keyName, meta);
   }
   if (this._cacheable) {
    delete meta.cache[keyName];
   }
   return null;
  };
  Ember.computed = function(func) {
   var args;
   if (arguments.length > 1) {
    args = a_slice.call(arguments, 0, -1);
    func = a_slice.call(arguments, -1)[0];
   }
   if (typeof func !== "function") {
    throw new Ember.Error("Computed Property declared without a property function");
   }
   var cp = new ComputedProperty(func);
   if (args) {
    cp.property.apply(cp, args);
   }
   return cp;
  };
  Ember.cacheFor = function cacheFor(obj, key) {
   var meta = obj[META_KEY], cache = meta && meta.cache;
   if (cache && key in cache) {
    return cache[key];
   }
  };
  function getProperties(self, propertyNames) {
   var ret = {};
   for (var i = 0; i < propertyNames.length; i++) {
    ret[propertyNames[i]] = get(self, propertyNames[i]);
   }
   return ret;
  }
  var registerComputed, registerComputedWithProperties;
  var guidFor = Ember.guidFor, map = Ember.EnumerableUtils.map, filter = Ember.EnumerableUtils.filter, typeOf = Ember.typeOf;
  var implicitKey = function(cp) {
   return [ guidFor(cp) ].concat(cp._dependentKeys).join("_");
  };
  var normalizeDependentKey = function(key) {
   if (key instanceof Ember.ComputedProperty) {
    return implicitKey(key);
   } else if (typeof key === "string" || key instanceof String || typeof key === "object" || typeof key === "number") {
    return key;
   } else {}
  };
  var normalizeDependentKeys = function(keys) {
   return map(keys, function(key) {
    return normalizeDependentKey(key);
   });
  };
  var selectDependentCPs = function(keys) {
   return filter(keys, function(key) {
    return key instanceof Ember.ComputedProperty;
   });
  };
  var setDependentKeys = function(cp, dependentKeys) {
   if (dependentKeys) {
    cp._dependentKeys = normalizeDependentKeys(dependentKeys);
    cp._dependentCPs = selectDependentCPs(dependentKeys);
    cp.implicitCPKey = implicitKey(cp);
   } else {
    cp._dependentKeys = cp._dependentCPs = [];
    delete cp.implicitCPKey;
   }
  };
  Ember.computed.normalizeDependentKey = normalizeDependentKey;
  Ember.computed.normalizeDependentKeys = normalizeDependentKeys;
  registerComputed = function(name, macro) {
   Ember.computed[name] = function(dependentKey) {
    var args = normalizeDependentKeys(a_slice.call(arguments));
    return Ember.computed(dependentKey, function() {
     return macro.apply(this, args);
    });
   };
  };
  registerComputedWithProperties = function(name, macro) {
   Ember.computed[name] = function() {
    var args = a_slice.call(arguments);
    var properties = normalizeDependentKeys(args);
    var computed = Ember.computed(function() {
     return macro.apply(this, [ getProperties(this, properties) ]);
    });
    return computed.property.apply(computed, args);
   };
  };
  Ember.computed.literal = function(value) {
   return Ember.computed(function() {
    return value;
   });
  };
  registerComputed("empty", function(dependentKey) {
   return Ember.isEmpty(get(this, dependentKey));
  });
  registerComputed("notEmpty", function(dependentKey) {
   return !Ember.isEmpty(get(this, dependentKey));
  });
  registerComputed("none", function(dependentKey) {
   return Ember.isNone(get(this, dependentKey));
  });
  registerComputed("not", function(dependentKey) {
   return !get(this, dependentKey);
  });
  registerComputed("bool", function(dependentKey) {
   return !!get(this, dependentKey);
  });
  registerComputed("match", function(dependentKey, regexp) {
   var value = get(this, dependentKey);
   return typeof value === "string" ? regexp.test(value) :false;
  });
  registerComputed("equal", function(dependentKey, value) {
   return get(this, dependentKey) === value;
  });
  registerComputed("gt", function(dependentKey, value) {
   return get(this, dependentKey) > value;
  });
  registerComputed("gte", function(dependentKey, value) {
   return get(this, dependentKey) >= value;
  });
  registerComputed("lt", function(dependentKey, value) {
   return get(this, dependentKey) < value;
  });
  registerComputed("lte", function(dependentKey, value) {
   return get(this, dependentKey) <= value;
  });
  registerComputedWithProperties("and", function(properties) {
   for (var key in properties) {
    if (properties.hasOwnProperty(key) && !properties[key]) {
     return false;
    }
   }
   return true;
  });
  registerComputedWithProperties("or", function(properties) {
   for (var key in properties) {
    if (properties.hasOwnProperty(key) && properties[key]) {
     return true;
    }
   }
   return false;
  });
  registerComputedWithProperties("any", function(properties) {
   for (var key in properties) {
    if (properties.hasOwnProperty(key) && properties[key]) {
     return properties[key];
    }
   }
   return null;
  });
  registerComputedWithProperties("collect", function(properties) {
   var res = [];
   for (var key in properties) {
    if (properties.hasOwnProperty(key)) {
     if (Ember.isNone(properties[key])) {
      res.push(null);
     } else {
      res.push(properties[key]);
     }
    }
   }
   return res;
  });
  Ember.computed.alias = function(dependentKey) {
   return Ember.computed(dependentKey, function(key, value) {
    if (arguments.length > 1) {
     set(this, dependentKey, value);
     return value;
    } else {
     return get(this, dependentKey);
    }
   });
  };
  Ember.computed.oneWay = function(dependentKey) {
   return Ember.computed(dependentKey, function() {
    return get(this, dependentKey);
   });
  };
  if (Ember.FEATURES.isEnabled("computed-read-only")) {
   Ember.computed.readOnly = function(dependentKey) {
    return Ember.computed(dependentKey, function() {
     return get(this, dependentKey);
    }).readOnly();
   };
  }
  Ember.computed.defaultTo = function(defaultPath) {
   return Ember.computed(function(key, newValue, cachedValue) {
    if (arguments.length === 1) {
     return cachedValue != null ? cachedValue :get(this, defaultPath);
    }
    return newValue != null ? newValue :get(this, defaultPath);
   });
  };
 })();
 (function() {
  var AFTER_OBSERVERS = ":change", BEFORE_OBSERVERS = ":before";
  function changeEvent(keyName) {
   return keyName + AFTER_OBSERVERS;
  }
  function beforeEvent(keyName) {
   return keyName + BEFORE_OBSERVERS;
  }
  Ember.addObserver = function(obj, _path, target, method) {
   Ember.addListener(obj, changeEvent(_path), target, method);
   Ember.watch(obj, _path);
   return this;
  };
  Ember.observersFor = function(obj, path) {
   return Ember.listenersFor(obj, changeEvent(path));
  };
  Ember.removeObserver = function(obj, _path, target, method) {
   Ember.unwatch(obj, _path);
   Ember.removeListener(obj, changeEvent(_path), target, method);
   return this;
  };
  Ember.addBeforeObserver = function(obj, _path, target, method) {
   Ember.addListener(obj, beforeEvent(_path), target, method);
   Ember.watch(obj, _path);
   return this;
  };
  Ember._suspendBeforeObserver = function(obj, path, target, method, callback) {
   return Ember._suspendListener(obj, beforeEvent(path), target, method, callback);
  };
  Ember._suspendObserver = function(obj, path, target, method, callback) {
   return Ember._suspendListener(obj, changeEvent(path), target, method, callback);
  };
  var map = Ember.ArrayPolyfills.map;
  Ember._suspendBeforeObservers = function(obj, paths, target, method, callback) {
   var events = map.call(paths, beforeEvent);
   return Ember._suspendListeners(obj, events, target, method, callback);
  };
  Ember._suspendObservers = function(obj, paths, target, method, callback) {
   var events = map.call(paths, changeEvent);
   return Ember._suspendListeners(obj, events, target, method, callback);
  };
  Ember.beforeObserversFor = function(obj, path) {
   return Ember.listenersFor(obj, beforeEvent(path));
  };
  Ember.removeBeforeObserver = function(obj, _path, target, method) {
   Ember.unwatch(obj, _path);
   Ember.removeListener(obj, beforeEvent(_path), target, method);
   return this;
  };
 })();
 (function() {
  define("backburner/queue", [ "exports" ], function(__exports__) {
   function Queue(daq, name, options) {
    this.daq = daq;
    this.name = name;
    this.options = options;
    this._queue = [];
   }
   Queue.prototype = {
    daq:null,
    name:null,
    options:null,
    _queue:null,
    push:function(target, method, args, stack) {
     var queue = this._queue;
     queue.push(target, method, args, stack);
     return {
      queue:this,
      target:target,
      method:method
     };
    },
    pushUnique:function(target, method, args, stack) {
     var queue = this._queue, currentTarget, currentMethod, i, l;
     for (i = 0, l = queue.length; i < l; i += 4) {
      currentTarget = queue[i];
      currentMethod = queue[i + 1];
      if (currentTarget === target && currentMethod === method) {
       queue[i + 2] = args;
       queue[i + 3] = stack;
       return {
        queue:this,
        target:target,
        method:method
       };
      }
     }
     this._queue.push(target, method, args, stack);
     return {
      queue:this,
      target:target,
      method:method
     };
    },
    flush:function() {
     var queue = this._queue, options = this.options, before = options && options.before, after = options && options.after, target, method, args, stack, i, l = queue.length;
     if (l && before) {
      before();
     }
     for (i = 0; i < l; i += 4) {
      target = queue[i];
      method = queue[i + 1];
      args = queue[i + 2];
      stack = queue[i + 3];
      if (args && args.length > 0) {
       method.apply(target, args);
      } else {
       method.call(target);
      }
     }
     if (l && after) {
      after();
     }
     if (queue.length > l) {
      this._queue = queue.slice(l);
      this.flush();
     } else {
      this._queue.length = 0;
     }
    },
    cancel:function(actionToCancel) {
     var queue = this._queue, currentTarget, currentMethod, i, l;
     for (i = 0, l = queue.length; i < l; i += 4) {
      currentTarget = queue[i];
      currentMethod = queue[i + 1];
      if (currentTarget === actionToCancel.target && currentMethod === actionToCancel.method) {
       queue.splice(i, 4);
       return true;
      }
     }
     queue = this._queueBeingFlushed;
     if (!queue) {
      return;
     }
     for (i = 0, l = queue.length; i < l; i += 4) {
      currentTarget = queue[i];
      currentMethod = queue[i + 1];
      if (currentTarget === actionToCancel.target && currentMethod === actionToCancel.method) {
       queue[i + 1] = null;
       return true;
      }
     }
    }
   };
   __exports__.Queue = Queue;
  });
  define("backburner/deferred_action_queues", [ "backburner/queue", "exports" ], function(__dependency1__, __exports__) {
   var Queue = __dependency1__.Queue;
   function DeferredActionQueues(queueNames, options) {
    var queues = this.queues = {};
    this.queueNames = queueNames = queueNames || [];
    var queueName;
    for (var i = 0, l = queueNames.length; i < l; i++) {
     queueName = queueNames[i];
     queues[queueName] = new Queue(this, queueName, options[queueName]);
    }
   }
   DeferredActionQueues.prototype = {
    queueNames:null,
    queues:null,
    schedule:function(queueName, target, method, args, onceFlag, stack) {
     var queues = this.queues, queue = queues[queueName];
     if (!queue) {
      throw new Error("You attempted to schedule an action in a queue (" + queueName + ") that doesn't exist");
     }
     if (onceFlag) {
      return queue.pushUnique(target, method, args, stack);
     } else {
      return queue.push(target, method, args, stack);
     }
    },
    flush:function() {
     var queues = this.queues, queueNames = this.queueNames, queueName, queue, queueItems, priorQueueNameIndex, queueNameIndex = 0, numberOfQueues = queueNames.length;
     outerloop:while (queueNameIndex < numberOfQueues) {
      queueName = queueNames[queueNameIndex];
      queue = queues[queueName];
      queueItems = queue._queueBeingFlushed = queue._queue.slice();
      queue._queue = [];
      var options = queue.options, before = options && options.before, after = options && options.after, target, method, args, stack, queueIndex = 0, numberOfQueueItems = queueItems.length;
      if (numberOfQueueItems && before) {
       before();
      }
      while (queueIndex < numberOfQueueItems) {
       target = queueItems[queueIndex];
       method = queueItems[queueIndex + 1];
       args = queueItems[queueIndex + 2];
       stack = queueItems[queueIndex + 3];
       if (typeof method === "string") {
        method = target[method];
       }
       if (method) {
        if (args && args.length > 0) {
         method.apply(target, args);
        } else {
         method.call(target);
        }
       }
       queueIndex += 4;
      }
      queue._queueBeingFlushed = null;
      if (numberOfQueueItems && after) {
       after();
      }
      if ((priorQueueNameIndex = indexOfPriorQueueWithActions(this, queueNameIndex)) !== -1) {
       queueNameIndex = priorQueueNameIndex;
       continue outerloop;
      }
      queueNameIndex++;
     }
    }
   };
   function indexOfPriorQueueWithActions(daq, currentQueueIndex) {
    var queueName, queue;
    for (var i = 0, l = currentQueueIndex; i <= l; i++) {
     queueName = daq.queueNames[i];
     queue = daq.queues[queueName];
     if (queue._queue.length) {
      return i;
     }
    }
    return -1;
   }
   __exports__.DeferredActionQueues = DeferredActionQueues;
  });
  define("backburner", [ "backburner/deferred_action_queues", "exports" ], function(__dependency1__, __exports__) {
   var DeferredActionQueues = __dependency1__.DeferredActionQueues;
   var slice = [].slice, pop = [].pop, throttlers = [], debouncees = [], timers = [], autorun, laterTimer, laterTimerExpiresAt, global = this, NUMBER = /\d+/;
   function isCoercableNumber(number) {
    return typeof number === "number" || NUMBER.test(number);
   }
   function Backburner(queueNames, options) {
    this.queueNames = queueNames;
    this.options = options || {};
    if (!this.options.defaultQueue) {
     this.options.defaultQueue = queueNames[0];
    }
    this.instanceStack = [];
   }
   Backburner.prototype = {
    queueNames:null,
    options:null,
    currentInstance:null,
    instanceStack:null,
    begin:function() {
     var onBegin = this.options && this.options.onBegin, previousInstance = this.currentInstance;
     if (previousInstance) {
      this.instanceStack.push(previousInstance);
     }
     this.currentInstance = new DeferredActionQueues(this.queueNames, this.options);
     if (onBegin) {
      onBegin(this.currentInstance, previousInstance);
     }
    },
    end:function() {
     var onEnd = this.options && this.options.onEnd, currentInstance = this.currentInstance, nextInstance = null;
     try {
      currentInstance.flush();
     } finally {
      this.currentInstance = null;
      if (this.instanceStack.length) {
       nextInstance = this.instanceStack.pop();
       this.currentInstance = nextInstance;
      }
      if (onEnd) {
       onEnd(currentInstance, nextInstance);
      }
     }
    },
    run:function(target, method) {
     var ret;
     this.begin();
     if (!method) {
      method = target;
      target = null;
     }
     if (typeof method === "string") {
      method = target[method];
     }
     var finallyAlreadyCalled = false;
     try {
      if (arguments.length > 2) {
       ret = method.apply(target, slice.call(arguments, 2));
      } else {
       ret = method.call(target);
      }
     } finally {
      if (!finallyAlreadyCalled) {
       finallyAlreadyCalled = true;
       this.end();
      }
     }
     return ret;
    },
    defer:function(queueName, target, method) {
     if (!method) {
      method = target;
      target = null;
     }
     if (typeof method === "string") {
      method = target[method];
     }
     var stack = this.DEBUG ? new Error() :undefined, args = arguments.length > 3 ? slice.call(arguments, 3) :undefined;
     if (!this.currentInstance) {
      createAutorun(this);
     }
     return this.currentInstance.schedule(queueName, target, method, args, false, stack);
    },
    deferOnce:function(queueName, target, method) {
     if (!method) {
      method = target;
      target = null;
     }
     if (typeof method === "string") {
      method = target[method];
     }
     var stack = this.DEBUG ? new Error() :undefined, args = arguments.length > 3 ? slice.call(arguments, 3) :undefined;
     if (!this.currentInstance) {
      createAutorun(this);
     }
     return this.currentInstance.schedule(queueName, target, method, args, true, stack);
    },
    setTimeout:function() {
     var args = slice.call(arguments);
     var length = args.length;
     var method, wait, target;
     var self = this;
     var methodOrTarget, methodOrWait, methodOrArgs;
     if (length === 0) {
      return;
     } else if (length === 1) {
      method = args.shift();
      wait = 0;
     } else if (length === 2) {
      methodOrTarget = args[0];
      methodOrWait = args[1];
      if (typeof methodOrWait === "function" || typeof methodOrTarget[methodOrWait] === "function") {
       target = args.shift();
       method = args.shift();
       wait = 0;
      } else if (isCoercableNumber(methodOrWait)) {
       method = args.shift();
       wait = args.shift();
      } else {
       method = args.shift();
       wait = 0;
      }
     } else {
      var last = args[args.length - 1];
      if (isCoercableNumber(last)) {
       wait = args.pop();
      }
      methodOrTarget = args[0];
      methodOrArgs = args[1];
      if (typeof methodOrArgs === "function" || typeof methodOrArgs === "string" && methodOrTarget !== null && methodOrArgs in methodOrTarget) {
       target = args.shift();
       method = args.shift();
      } else {
       method = args.shift();
      }
     }
     var executeAt = +new Date() + parseInt(wait, 10);
     if (typeof method === "string") {
      method = target[method];
     }
     function fn() {
      method.apply(target, args);
     }
     var i, l;
     for (i = 0, l = timers.length; i < l; i += 2) {
      if (executeAt < timers[i]) {
       break;
      }
     }
     timers.splice(i, 0, executeAt, fn);
     updateLaterTimer(self, executeAt, wait);
     return fn;
    },
    throttle:function(target, method) {
     var self = this, args = arguments, wait = parseInt(pop.call(args), 10), throttler, index, timer;
     index = findThrottler(target, method);
     if (index > -1) {
      return throttlers[index];
     }
     timer = global.setTimeout(function() {
      self.run.apply(self, args);
      var index = findThrottler(target, method);
      if (index > -1) {
       throttlers.splice(index, 1);
      }
     }, wait);
     throttler = [ target, method, timer ];
     throttlers.push(throttler);
     return throttler;
    },
    debounce:function(target, method) {
     var self = this, args = arguments, immediate = pop.call(args), wait, index, debouncee, timer;
     if (typeof immediate === "number" || typeof immediate === "string") {
      wait = immediate;
      immediate = false;
     } else {
      wait = pop.call(args);
     }
     wait = parseInt(wait, 10);
     index = findDebouncee(target, method);
     if (index > -1) {
      debouncee = debouncees[index];
      debouncees.splice(index, 1);
      clearTimeout(debouncee[2]);
     }
     timer = global.setTimeout(function() {
      if (!immediate) {
       self.run.apply(self, args);
      }
      var index = findDebouncee(target, method);
      if (index > -1) {
       debouncees.splice(index, 1);
      }
     }, wait);
     if (immediate && index === -1) {
      self.run.apply(self, args);
     }
     debouncee = [ target, method, timer ];
     debouncees.push(debouncee);
     return debouncee;
    },
    cancelTimers:function() {
     var i, len;
     for (i = 0, len = throttlers.length; i < len; i++) {
      clearTimeout(throttlers[i][2]);
     }
     throttlers = [];
     for (i = 0, len = debouncees.length; i < len; i++) {
      clearTimeout(debouncees[i][2]);
     }
     debouncees = [];
     if (laterTimer) {
      clearTimeout(laterTimer);
      laterTimer = null;
     }
     timers = [];
     if (autorun) {
      clearTimeout(autorun);
      autorun = null;
     }
    },
    hasTimers:function() {
     return !!timers.length || autorun;
    },
    cancel:function(timer) {
     var timerType = typeof timer;
     if (timer && timerType === "object" && timer.queue && timer.method) {
      return timer.queue.cancel(timer);
     } else if (timerType === "function") {
      for (var i = 0, l = timers.length; i < l; i += 2) {
       if (timers[i + 1] === timer) {
        timers.splice(i, 2);
        return true;
       }
      }
     } else if (window.toString.call(timer) === "[object Array]") {
      return this._cancelItem(findThrottler, throttlers, timer) || this._cancelItem(findDebouncee, debouncees, timer);
     } else {
      return;
     }
    },
    _cancelItem:function(findMethod, array, timer) {
     var item, index;
     if (timer.length < 3) {
      return false;
     }
     index = findMethod(timer[0], timer[1]);
     if (index > -1) {
      item = array[index];
      if (item[2] === timer[2]) {
       array.splice(index, 1);
       clearTimeout(timer[2]);
       return true;
      }
     }
     return false;
    }
   };
   Backburner.prototype.schedule = Backburner.prototype.defer;
   Backburner.prototype.scheduleOnce = Backburner.prototype.deferOnce;
   Backburner.prototype.later = Backburner.prototype.setTimeout;
   function createAutorun(backburner) {
    backburner.begin();
    autorun = global.setTimeout(function() {
     autorun = null;
     backburner.end();
    });
   }
   function updateLaterTimer(self, executeAt, wait) {
    if (!laterTimer || executeAt < laterTimerExpiresAt) {
     if (laterTimer) {
      clearTimeout(laterTimer);
     }
     laterTimer = global.setTimeout(function() {
      laterTimer = null;
      laterTimerExpiresAt = null;
      executeTimers(self);
     }, wait);
     laterTimerExpiresAt = executeAt;
    }
   }
   function executeTimers(self) {
    var now = +new Date(), time, fns, i, l;
    self.run(function() {
     for (i = 0, l = timers.length; i < l; i += 2) {
      time = timers[i];
      if (time > now) {
       break;
      }
     }
     fns = timers.splice(0, i);
     for (i = 1, l = fns.length; i < l; i += 2) {
      self.schedule(self.options.defaultQueue, null, fns[i]);
     }
    });
    if (timers.length) {
     updateLaterTimer(self, timers[0], timers[0] - now);
    }
   }
   function findDebouncee(target, method) {
    var debouncee, index = -1;
    for (var i = 0, l = debouncees.length; i < l; i++) {
     debouncee = debouncees[i];
     if (debouncee[0] === target && debouncee[1] === method) {
      index = i;
      break;
     }
    }
    return index;
   }
   function findThrottler(target, method) {
    var throttler, index = -1;
    for (var i = 0, l = throttlers.length; i < l; i++) {
     throttler = throttlers[i];
     if (throttler[0] === target && throttler[1] === method) {
      index = i;
      break;
     }
    }
    return index;
   }
   __exports__.Backburner = Backburner;
  });
 })();
 (function() {
  var onBegin = function(current) {
   Ember.run.currentRunLoop = current;
  };
  var onEnd = function(current, next) {
   Ember.run.currentRunLoop = next;
  };
  var Backburner = requireModule("backburner").Backburner, backburner = new Backburner([ "sync", "actions", "destroy" ], {
   sync:{
    before:Ember.beginPropertyChanges,
    after:Ember.endPropertyChanges
   },
   defaultQueue:"actions",
   onBegin:onBegin,
   onEnd:onEnd
  }), slice = [].slice, concat = [].concat;
  Ember.run = function(target, method) {
   var ret;
   if (Ember.onerror) {
    try {
     ret = backburner.run.apply(backburner, arguments);
    } catch (e) {
     Ember.onerror(e);
    }
   } else {
    ret = backburner.run.apply(backburner, arguments);
   }
   return ret;
  };
  Ember.run.join = function(target, method) {
   if (!Ember.run.currentRunLoop) {
    return Ember.run.apply(Ember.run, arguments);
   }
   var args = slice.call(arguments);
   args.unshift("actions");
   Ember.run.schedule.apply(Ember.run, args);
  };
  Ember.run.bind = function(target, method) {
   var args = arguments;
   return function() {
    return Ember.run.join.apply(Ember.run, args);
   };
  };
  Ember.run.backburner = backburner;
  var run = Ember.run;
  Ember.run.currentRunLoop = null;
  Ember.run.queues = backburner.queueNames;
  Ember.run.begin = function() {
   backburner.begin();
  };
  Ember.run.end = function() {
   backburner.end();
  };
  Ember.run.schedule = function(queue, target, method) {
   checkAutoRun();
   backburner.schedule.apply(backburner, arguments);
  };
  Ember.run.hasScheduledTimers = function() {
   return backburner.hasTimers();
  };
  Ember.run.cancelTimers = function() {
   backburner.cancelTimers();
  };
  Ember.run.sync = function() {
   if (backburner.currentInstance) {
    backburner.currentInstance.queues.sync.flush();
   }
  };
  Ember.run.later = function(target, method) {
   return backburner.later.apply(backburner, arguments);
  };
  Ember.run.once = function(target, method) {
   checkAutoRun();
   var args = slice.call(arguments);
   args.unshift("actions");
   return backburner.scheduleOnce.apply(backburner, args);
  };
  Ember.run.scheduleOnce = function(queue, target, method) {
   checkAutoRun();
   return backburner.scheduleOnce.apply(backburner, arguments);
  };
  Ember.run.next = function() {
   var args = slice.call(arguments);
   args.push(1);
   return backburner.later.apply(backburner, args);
  };
  Ember.run.cancel = function(timer) {
   return backburner.cancel(timer);
  };
  Ember.run.debounce = function() {
   return backburner.debounce.apply(backburner, arguments);
  };
  Ember.run.throttle = function() {
   return backburner.throttle.apply(backburner, arguments);
  };
  function checkAutoRun() {
   if (!Ember.run.currentRunLoop) {}
  }
 })();
 (function() {
  Ember.LOG_BINDINGS = false || !!Ember.ENV.LOG_BINDINGS;
  var get = Ember.get, set = Ember.set, guidFor = Ember.guidFor, IS_GLOBAL = /^([A-Z$]|([0-9][A-Z$]))/;
  var isGlobalPath = Ember.isGlobalPath = function(path) {
   return IS_GLOBAL.test(path);
  };
  function getWithGlobals(obj, path) {
   return get(isGlobalPath(path) ? Ember.lookup :obj, path);
  }
  var Binding = function(toPath, fromPath) {
   this._direction = "fwd";
   this._from = fromPath;
   this._to = toPath;
   this._directionMap = Ember.Map.create();
  };
  Binding.prototype = {
   copy:function() {
    var copy = new Binding(this._to, this._from);
    if (this._oneWay) {
     copy._oneWay = true;
    }
    return copy;
   },
   from:function(path) {
    this._from = path;
    return this;
   },
   to:function(path) {
    this._to = path;
    return this;
   },
   oneWay:function() {
    this._oneWay = true;
    return this;
   },
   toString:function() {
    var oneWay = this._oneWay ? "[oneWay]" :"";
    return "Ember.Binding<" + guidFor(this) + ">(" + this._from + " -> " + this._to + ")" + oneWay;
   },
   connect:function(obj) {
    var fromPath = this._from, toPath = this._to;
    Ember.trySet(obj, toPath, getWithGlobals(obj, fromPath));
    Ember.addObserver(obj, fromPath, this, this.fromDidChange);
    if (!this._oneWay) {
     Ember.addObserver(obj, toPath, this, this.toDidChange);
    }
    this._readyToSync = true;
    return this;
   },
   disconnect:function(obj) {
    var twoWay = !this._oneWay;
    Ember.removeObserver(obj, this._from, this, this.fromDidChange);
    if (twoWay) {
     Ember.removeObserver(obj, this._to, this, this.toDidChange);
    }
    this._readyToSync = false;
    return this;
   },
   fromDidChange:function(target) {
    this._scheduleSync(target, "fwd");
   },
   toDidChange:function(target) {
    this._scheduleSync(target, "back");
   },
   _scheduleSync:function(obj, dir) {
    var directionMap = this._directionMap;
    var existingDir = directionMap.get(obj);
    if (!existingDir) {
     Ember.run.schedule("sync", this, this._sync, obj);
     directionMap.set(obj, dir);
    }
    if (existingDir === "back" && dir === "fwd") {
     directionMap.set(obj, "fwd");
    }
   },
   _sync:function(obj) {
    var log = Ember.LOG_BINDINGS;
    if (obj.isDestroyed || !this._readyToSync) {
     return;
    }
    var directionMap = this._directionMap;
    var direction = directionMap.get(obj);
    var fromPath = this._from, toPath = this._to;
    directionMap.remove(obj);
    if (direction === "fwd") {
     var fromValue = getWithGlobals(obj, this._from);
     if (log) {
      Ember.Logger.log(" ", this.toString(), "->", fromValue, obj);
     }
     if (this._oneWay) {
      Ember.trySet(obj, toPath, fromValue);
     } else {
      Ember._suspendObserver(obj, toPath, this, this.toDidChange, function() {
       Ember.trySet(obj, toPath, fromValue);
      });
     }
    } else if (direction === "back") {
     var toValue = get(obj, this._to);
     if (log) {
      Ember.Logger.log(" ", this.toString(), "<-", toValue, obj);
     }
     Ember._suspendObserver(obj, fromPath, this, this.fromDidChange, function() {
      Ember.trySet(Ember.isGlobalPath(fromPath) ? Ember.lookup :obj, fromPath, toValue);
     });
    }
   }
  };
  function mixinProperties(to, from) {
   for (var key in from) {
    if (from.hasOwnProperty(key)) {
     to[key] = from[key];
    }
   }
  }
  mixinProperties(Binding, {
   from:function() {
    var C = this, binding = new C();
    return binding.from.apply(binding, arguments);
   },
   to:function() {
    var C = this, binding = new C();
    return binding.to.apply(binding, arguments);
   },
   oneWay:function(from, flag) {
    var C = this, binding = new C(null, from);
    return binding.oneWay(flag);
   }
  });
  Ember.Binding = Binding;
  Ember.bind = function(obj, to, from) {
   return new Ember.Binding(to, from).connect(obj);
  };
  Ember.oneWay = function(obj, to, from) {
   return new Ember.Binding(to, from).oneWay().connect(obj);
  };
 })();
 (function() {
  var Mixin, REQUIRED, Alias, a_map = Ember.ArrayPolyfills.map, a_indexOf = Ember.ArrayPolyfills.indexOf, a_forEach = Ember.ArrayPolyfills.forEach, a_slice = [].slice, o_create = Ember.create, defineProperty = Ember.defineProperty, guidFor = Ember.guidFor, metaFor = Ember.meta, META_KEY = Ember.META_KEY;
  var expandProperties = Ember.expandProperties;
  function mixinsMeta(obj) {
   var m = metaFor(obj, true), ret = m.mixins;
   if (!ret) {
    ret = m.mixins = {};
   } else if (!m.hasOwnProperty("mixins")) {
    ret = m.mixins = o_create(ret);
   }
   return ret;
  }
  function initMixin(mixin, args) {
   if (args && args.length > 0) {
    mixin.mixins = a_map.call(args, function(x) {
     if (x instanceof Mixin) {
      return x;
     }
     var mixin = new Mixin();
     mixin.properties = x;
     return mixin;
    });
   }
   return mixin;
  }
  function isMethod(obj) {
   return "function" === typeof obj && obj.isMethod !== false && obj !== Boolean && obj !== Object && obj !== Number && obj !== Array && obj !== Date && obj !== String;
  }
  var CONTINUE = {};
  function mixinProperties(mixinsMeta, mixin) {
   var guid;
   if (mixin instanceof Mixin) {
    guid = guidFor(mixin);
    if (mixinsMeta[guid]) {
     return CONTINUE;
    }
    mixinsMeta[guid] = mixin;
    return mixin.properties;
   } else {
    return mixin;
   }
  }
  function concatenatedMixinProperties(concatProp, props, values, base) {
   var concats;
   concats = values[concatProp] || base[concatProp];
   if (props[concatProp]) {
    concats = concats ? concats.concat(props[concatProp]) :props[concatProp];
   }
   return concats;
  }
  function giveDescriptorSuper(meta, key, property, values, descs) {
   var superProperty;
   if (values[key] === undefined) {
    superProperty = descs[key];
   }
   superProperty = superProperty || meta.descs[key];
   if (!superProperty || !(superProperty instanceof Ember.ComputedProperty)) {
    return property;
   }
   property = o_create(property);
   property.func = Ember.wrap(property.func, superProperty.func);
   return property;
  }
  function giveMethodSuper(obj, key, method, values, descs) {
   var superMethod;
   if (descs[key] === undefined) {
    superMethod = values[key];
   }
   superMethod = superMethod || obj[key];
   if ("function" !== typeof superMethod) {
    return method;
   }
   return Ember.wrap(method, superMethod);
  }
  function applyConcatenatedProperties(obj, key, value, values) {
   var baseValue = values[key] || obj[key];
   if (baseValue) {
    if ("function" === typeof baseValue.concat) {
     return baseValue.concat(value);
    } else {
     return Ember.makeArray(baseValue).concat(value);
    }
   } else {
    return Ember.makeArray(value);
   }
  }
  function applyMergedProperties(obj, key, value, values) {
   var baseValue = values[key] || obj[key];
   if (!baseValue) {
    return value;
   }
   var newBase = Ember.merge({}, baseValue);
   for (var prop in value) {
    if (!value.hasOwnProperty(prop)) {
     continue;
    }
    var propValue = value[prop];
    if (isMethod(propValue)) {
     newBase[prop] = giveMethodSuper(obj, prop, propValue, baseValue, {});
    } else {
     newBase[prop] = propValue;
    }
   }
   return newBase;
  }
  function addNormalizedProperty(base, key, value, meta, descs, values, concats, mergings) {
   if (value instanceof Ember.Descriptor) {
    if (value === REQUIRED && descs[key]) {
     return CONTINUE;
    }
    if (value.func) {
     value = giveDescriptorSuper(meta, key, value, values, descs);
    }
    descs[key] = value;
    values[key] = undefined;
   } else {
    if (concats && a_indexOf.call(concats, key) >= 0 || key === "concatenatedProperties" || key === "mergedProperties") {
     value = applyConcatenatedProperties(base, key, value, values);
    } else if (mergings && a_indexOf.call(mergings, key) >= 0) {
     value = applyMergedProperties(base, key, value, values);
    } else if (isMethod(value)) {
     value = giveMethodSuper(base, key, value, values, descs);
    }
    descs[key] = undefined;
    values[key] = value;
   }
  }
  function mergeMixins(mixins, m, descs, values, base, keys) {
   var mixin, props, key, concats, mergings, meta;
   function removeKeys(keyName) {
    delete descs[keyName];
    delete values[keyName];
   }
   for (var i = 0, l = mixins.length; i < l; i++) {
    mixin = mixins[i];
    props = mixinProperties(m, mixin);
    if (props === CONTINUE) {
     continue;
    }
    if (props) {
     meta = metaFor(base);
     if (base.willMergeMixin) {
      base.willMergeMixin(props);
     }
     concats = concatenatedMixinProperties("concatenatedProperties", props, values, base);
     mergings = concatenatedMixinProperties("mergedProperties", props, values, base);
     for (key in props) {
      if (!props.hasOwnProperty(key)) {
       continue;
      }
      keys.push(key);
      addNormalizedProperty(base, key, props[key], meta, descs, values, concats, mergings);
     }
     if (props.hasOwnProperty("toString")) {
      base.toString = props.toString;
     }
    } else if (mixin.mixins) {
     mergeMixins(mixin.mixins, m, descs, values, base, keys);
     if (mixin._without) {
      a_forEach.call(mixin._without, removeKeys);
     }
    }
   }
  }
  var IS_BINDING = Ember.IS_BINDING = /^.+Binding$/;
  function detectBinding(obj, key, value, m) {
   if (IS_BINDING.test(key)) {
    var bindings = m.bindings;
    if (!bindings) {
     bindings = m.bindings = {};
    } else if (!m.hasOwnProperty("bindings")) {
     bindings = m.bindings = o_create(m.bindings);
    }
    bindings[key] = value;
   }
  }
  function connectBindings(obj, m) {
   var bindings = m.bindings, key, binding, to;
   if (bindings) {
    for (key in bindings) {
     binding = bindings[key];
     if (binding) {
      to = key.slice(0, -7);
      if (binding instanceof Ember.Binding) {
       binding = binding.copy();
       binding.to(to);
      } else {
       binding = new Ember.Binding(to, binding);
      }
      binding.connect(obj);
      obj[key] = binding;
     }
    }
    m.bindings = {};
   }
  }
  function finishPartial(obj, m) {
   connectBindings(obj, m || metaFor(obj));
   return obj;
  }
  function followAlias(obj, desc, m, descs, values) {
   var altKey = desc.methodName, value;
   if (descs[altKey] || values[altKey]) {
    value = values[altKey];
    desc = descs[altKey];
   } else if (m.descs[altKey]) {
    desc = m.descs[altKey];
    value = undefined;
   } else {
    desc = undefined;
    value = obj[altKey];
   }
   return {
    desc:desc,
    value:value
   };
  }
  function updateObserversAndListeners(obj, key, observerOrListener, pathsKey, updateMethod) {
   var paths = observerOrListener[pathsKey];
   if (paths) {
    for (var i = 0, l = paths.length; i < l; i++) {
     Ember[updateMethod](obj, paths[i], null, key);
    }
   }
  }
  function replaceObserversAndListeners(obj, key, observerOrListener) {
   var prev = obj[key];
   if ("function" === typeof prev) {
    updateObserversAndListeners(obj, key, prev, "__ember_observesBefore__", "removeBeforeObserver");
    updateObserversAndListeners(obj, key, prev, "__ember_observes__", "removeObserver");
    updateObserversAndListeners(obj, key, prev, "__ember_listens__", "removeListener");
   }
   if ("function" === typeof observerOrListener) {
    updateObserversAndListeners(obj, key, observerOrListener, "__ember_observesBefore__", "addBeforeObserver");
    updateObserversAndListeners(obj, key, observerOrListener, "__ember_observes__", "addObserver");
    updateObserversAndListeners(obj, key, observerOrListener, "__ember_listens__", "addListener");
   }
  }
  function applyMixin(obj, mixins, partial) {
   var descs = {}, values = {}, m = metaFor(obj), key, value, desc, keys = [];
   mergeMixins(mixins, mixinsMeta(obj), descs, values, obj, keys);
   for (var i = 0, l = keys.length; i < l; i++) {
    key = keys[i];
    if (key === "constructor" || !values.hasOwnProperty(key)) {
     continue;
    }
    desc = descs[key];
    value = values[key];
    if (desc === REQUIRED) {
     continue;
    }
    while (desc && desc instanceof Alias) {
     var followed = followAlias(obj, desc, m, descs, values);
     desc = followed.desc;
     value = followed.value;
    }
    if (desc === undefined && value === undefined) {
     continue;
    }
    replaceObserversAndListeners(obj, key, value);
    detectBinding(obj, key, value, m);
    defineProperty(obj, key, desc, value, m);
   }
   if (!partial) {
    finishPartial(obj, m);
   }
   return obj;
  }
  Ember.mixin = function(obj) {
   var args = a_slice.call(arguments, 1);
   applyMixin(obj, args, false);
   return obj;
  };
  Ember.Mixin = function() {
   return initMixin(this, arguments);
  };
  Mixin = Ember.Mixin;
  Mixin.prototype = {
   properties:null,
   mixins:null,
   ownerConstructor:null
  };
  Mixin._apply = applyMixin;
  Mixin.applyPartial = function(obj) {
   var args = a_slice.call(arguments, 1);
   return applyMixin(obj, args, true);
  };
  Mixin.finishPartial = finishPartial;
  Ember.anyUnprocessedMixins = false;
  Mixin.create = function() {
   Ember.anyUnprocessedMixins = true;
   var M = this;
   return initMixin(new M(), arguments);
  };
  var MixinPrototype = Mixin.prototype;
  MixinPrototype.reopen = function() {
   var mixin, tmp;
   if (this.properties) {
    mixin = Mixin.create();
    mixin.properties = this.properties;
    delete this.properties;
    this.mixins = [ mixin ];
   } else if (!this.mixins) {
    this.mixins = [];
   }
   var len = arguments.length, mixins = this.mixins, idx;
   for (idx = 0; idx < len; idx++) {
    mixin = arguments[idx];
    if (mixin instanceof Mixin) {
     mixins.push(mixin);
    } else {
     tmp = Mixin.create();
     tmp.properties = mixin;
     mixins.push(tmp);
    }
   }
   return this;
  };
  MixinPrototype.apply = function(obj) {
   return applyMixin(obj, [ this ], false);
  };
  MixinPrototype.applyPartial = function(obj) {
   return applyMixin(obj, [ this ], true);
  };
  function _detect(curMixin, targetMixin, seen) {
   var guid = guidFor(curMixin);
   if (seen[guid]) {
    return false;
   }
   seen[guid] = true;
   if (curMixin === targetMixin) {
    return true;
   }
   var mixins = curMixin.mixins, loc = mixins ? mixins.length :0;
   while (--loc >= 0) {
    if (_detect(mixins[loc], targetMixin, seen)) {
     return true;
    }
   }
   return false;
  }
  MixinPrototype.detect = function(obj) {
   if (!obj) {
    return false;
   }
   if (obj instanceof Mixin) {
    return _detect(obj, this, {});
   }
   var m = obj[META_KEY], mixins = m && m.mixins;
   if (mixins) {
    return !!mixins[guidFor(this)];
   }
   return false;
  };
  MixinPrototype.without = function() {
   var ret = new Mixin(this);
   ret._without = a_slice.call(arguments);
   return ret;
  };
  function _keys(ret, mixin, seen) {
   if (seen[guidFor(mixin)]) {
    return;
   }
   seen[guidFor(mixin)] = true;
   if (mixin.properties) {
    var props = mixin.properties;
    for (var key in props) {
     if (props.hasOwnProperty(key)) {
      ret[key] = true;
     }
    }
   } else if (mixin.mixins) {
    a_forEach.call(mixin.mixins, function(x) {
     _keys(ret, x, seen);
    });
   }
  }
  MixinPrototype.keys = function() {
   var keys = {}, seen = {}, ret = [];
   _keys(keys, this, seen);
   for (var key in keys) {
    if (keys.hasOwnProperty(key)) {
     ret.push(key);
    }
   }
   return ret;
  };
  Mixin.mixins = function(obj) {
   var m = obj[META_KEY], mixins = m && m.mixins, ret = [];
   if (!mixins) {
    return ret;
   }
   for (var key in mixins) {
    var mixin = mixins[key];
    if (!mixin.properties) {
     ret.push(mixin);
    }
   }
   return ret;
  };
  REQUIRED = new Ember.Descriptor();
  REQUIRED.toString = function() {
   return "(Required Property)";
  };
  Ember.required = function() {
   return REQUIRED;
  };
  Alias = function(methodName) {
   this.methodName = methodName;
  };
  Alias.prototype = new Ember.Descriptor();
  Ember.aliasMethod = function(methodName) {
   return new Alias(methodName);
  };
  Ember.observer = function() {
   var func = a_slice.call(arguments, -1)[0];
   var paths;
   var addWatchedProperty = function(path) {
    paths.push(path);
   };
   var _paths = a_slice.call(arguments, 0, -1);
   if (typeof func !== "function") {
    func = arguments[0];
    _paths = a_slice.call(arguments, 1);
   }
   paths = [];
   for (var i = 0; i < _paths.length; ++i) {
    expandProperties(_paths[i], addWatchedProperty);
   }
   if (typeof func !== "function") {
    throw new Ember.Error("Ember.observer called without a function");
   }
   func.__ember_observes__ = paths;
   return func;
  };
  Ember.immediateObserver = function() {
   for (var i = 0, l = arguments.length; i < l; i++) {
    var arg = arguments[i];
   }
   return Ember.observer.apply(this, arguments);
  };
  Ember.beforeObserver = function() {
   var func = a_slice.call(arguments, -1)[0];
   var paths;
   var addWatchedProperty = function(path) {
    paths.push(path);
   };
   var _paths = a_slice.call(arguments, 0, -1);
   if (typeof func !== "function") {
    func = arguments[0];
    _paths = a_slice.call(arguments, 1);
   }
   paths = [];
   for (var i = 0; i < _paths.length; ++i) {
    expandProperties(_paths[i], addWatchedProperty);
   }
   if (typeof func !== "function") {
    throw new Ember.Error("Ember.beforeObserver called without a function");
   }
   func.__ember_observesBefore__ = paths;
   return func;
  };
 })();
 (function() {
  var forEach = Ember.EnumerableUtils.forEach, indexOf = Ember.EnumerableUtils.indexOf;
  Ember.libraries = function() {
   var libraries = [];
   var coreLibIndex = 0;
   var getLibrary = function(name) {
    for (var i = 0; i < libraries.length; i++) {
     if (libraries[i].name === name) {
      return libraries[i];
     }
    }
   };
   libraries.register = function(name, version) {
    if (!getLibrary(name)) {
     libraries.push({
      name:name,
      version:version
     });
    }
   };
   libraries.registerCoreLibrary = function(name, version) {
    if (!getLibrary(name)) {
     libraries.splice(coreLibIndex++, 0, {
      name:name,
      version:version
     });
    }
   };
   libraries.deRegister = function(name) {
    var lib = getLibrary(name);
    if (lib) libraries.splice(indexOf(libraries, lib), 1);
   };
   libraries.each = function(callback) {
    forEach(libraries, function(lib) {
     callback(lib.name, lib.version);
    });
   };
   return libraries;
  }();
  Ember.libraries.registerCoreLibrary("Ember", Ember.VERSION);
 })();
 (function() {})();
 (function() {
  define("rsvp/all", [ "./promise", "exports" ], function(__dependency1__, __exports__) {
   var Promise = __dependency1__["default"];
   __exports__["default"] = function all(array, label) {
    return Promise.all(array, label);
   };
  });
  define("rsvp/all_settled", [ "./promise", "./utils", "exports" ], function(__dependency1__, __dependency2__, __exports__) {
   var Promise = __dependency1__["default"];
   var isArray = __dependency2__.isArray;
   var isNonThenable = __dependency2__.isNonThenable;
   __exports__["default"] = function allSettled(entries, label) {
    return new Promise(function(resolve, reject) {
     if (!isArray(entries)) {
      throw new TypeError("You must pass an array to allSettled.");
     }
     var remaining = entries.length;
     var entry;
     if (remaining === 0) {
      resolve([]);
      return;
     }
     var results = new Array(remaining);
     function fulfilledResolver(index) {
      return function(value) {
       resolveAll(index, fulfilled(value));
      };
     }
     function rejectedResolver(index) {
      return function(reason) {
       resolveAll(index, rejected(reason));
      };
     }
     function resolveAll(index, value) {
      results[index] = value;
      if (--remaining === 0) {
       resolve(results);
      }
     }
     for (var index = 0; index < entries.length; index++) {
      entry = entries[index];
      if (isNonThenable(entry)) {
       resolveAll(index, fulfilled(entry));
      } else {
       Promise.cast(entry).then(fulfilledResolver(index), rejectedResolver(index));
      }
     }
    }, label);
   };
   function fulfilled(value) {
    return {
     state:"fulfilled",
     value:value
    };
   }
   function rejected(reason) {
    return {
     state:"rejected",
     reason:reason
    };
   }
  });
  define("rsvp/config", [ "./events", "exports" ], function(__dependency1__, __exports__) {
   var EventTarget = __dependency1__["default"];
   var config = {
    instrument:false
   };
   EventTarget.mixin(config);
   function configure(name, value) {
    if (name === "onerror") {
     config.on("error", value);
     return;
    }
    if (arguments.length === 2) {
     config[name] = value;
    } else {
     return config[name];
    }
   }
   __exports__.config = config;
   __exports__.configure = configure;
  });
  define("rsvp/defer", [ "./promise", "exports" ], function(__dependency1__, __exports__) {
   var Promise = __dependency1__["default"];
   __exports__["default"] = function defer(label) {
    var deferred = {};
    deferred.promise = new Promise(function(resolve, reject) {
     deferred.resolve = resolve;
     deferred.reject = reject;
    }, label);
    return deferred;
   };
  });
  define("rsvp/events", [ "exports" ], function(__exports__) {
   var indexOf = function(callbacks, callback) {
    for (var i = 0, l = callbacks.length; i < l; i++) {
     if (callbacks[i] === callback) {
      return i;
     }
    }
    return -1;
   };
   var callbacksFor = function(object) {
    var callbacks = object._promiseCallbacks;
    if (!callbacks) {
     callbacks = object._promiseCallbacks = {};
    }
    return callbacks;
   };
   __exports__["default"] = {
    mixin:function(object) {
     object.on = this.on;
     object.off = this.off;
     object.trigger = this.trigger;
     object._promiseCallbacks = undefined;
     return object;
    },
    on:function(eventName, callback) {
     var allCallbacks = callbacksFor(this), callbacks;
     callbacks = allCallbacks[eventName];
     if (!callbacks) {
      callbacks = allCallbacks[eventName] = [];
     }
     if (indexOf(callbacks, callback) === -1) {
      callbacks.push(callback);
     }
    },
    off:function(eventName, callback) {
     var allCallbacks = callbacksFor(this), callbacks, index;
     if (!callback) {
      allCallbacks[eventName] = [];
      return;
     }
     callbacks = allCallbacks[eventName];
     index = indexOf(callbacks, callback);
     if (index !== -1) {
      callbacks.splice(index, 1);
     }
    },
    trigger:function(eventName, options) {
     var allCallbacks = callbacksFor(this), callbacks, callbackTuple, callback, binding;
     if (callbacks = allCallbacks[eventName]) {
      for (var i = 0; i < callbacks.length; i++) {
       callback = callbacks[i];
       callback(options);
      }
     }
    }
   };
  });
  define("rsvp/filter", [ "./all", "./map", "./utils", "exports" ], function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
   var all = __dependency1__["default"];
   var map = __dependency2__["default"];
   var isFunction = __dependency3__.isFunction;
   var isArray = __dependency3__.isArray;
   function filter(promises, filterFn, label) {
    return all(promises, label).then(function(values) {
     if (!isArray(promises)) {
      throw new TypeError("You must pass an array to filter.");
     }
     if (!isFunction(filterFn)) {
      throw new TypeError("You must pass a function to filter's second argument.");
     }
     return map(promises, filterFn, label).then(function(filterResults) {
      var i, valuesLen = values.length, filtered = [];
      for (i = 0; i < valuesLen; i++) {
       if (filterResults[i]) filtered.push(values[i]);
      }
      return filtered;
     });
    });
   }
   __exports__["default"] = filter;
  });
  define("rsvp/hash", [ "./promise", "./utils", "exports" ], function(__dependency1__, __dependency2__, __exports__) {
   var Promise = __dependency1__["default"];
   var isNonThenable = __dependency2__.isNonThenable;
   var keysOf = __dependency2__.keysOf;
   __exports__["default"] = function hash(object, label) {
    return new Promise(function(resolve, reject) {
     var results = {};
     var keys = keysOf(object);
     var remaining = keys.length;
     var entry, property;
     if (remaining === 0) {
      resolve(results);
      return;
     }
     function fulfilledTo(property) {
      return function(value) {
       results[property] = value;
       if (--remaining === 0) {
        resolve(results);
       }
      };
     }
     function onRejection(reason) {
      remaining = 0;
      reject(reason);
     }
     for (var i = 0; i < keys.length; i++) {
      property = keys[i];
      entry = object[property];
      if (isNonThenable(entry)) {
       results[property] = entry;
       if (--remaining === 0) {
        resolve(results);
       }
      } else {
       Promise.cast(entry).then(fulfilledTo(property), onRejection);
      }
     }
    });
   };
  });
  define("rsvp/instrument", [ "./config", "./utils", "exports" ], function(__dependency1__, __dependency2__, __exports__) {
   var config = __dependency1__.config;
   var now = __dependency2__.now;
   __exports__["default"] = function instrument(eventName, promise, child) {
    try {
     config.trigger(eventName, {
      guid:promise._guidKey + promise._id,
      eventName:eventName,
      detail:promise._detail,
      childGuid:child && promise._guidKey + child._id,
      label:promise._label,
      timeStamp:now(),
      stack:new Error(promise._label).stack
     });
    } catch (error) {
     setTimeout(function() {
      throw error;
     }, 0);
    }
   };
  });
  define("rsvp/map", [ "./promise", "./all", "./utils", "exports" ], function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
   var Promise = __dependency1__["default"];
   var all = __dependency2__["default"];
   var isArray = __dependency3__.isArray;
   var isFunction = __dependency3__.isFunction;
   __exports__["default"] = function map(promises, mapFn, label) {
    return all(promises, label).then(function(results) {
     if (!isArray(promises)) {
      throw new TypeError("You must pass an array to map.");
     }
     if (!isFunction(mapFn)) {
      throw new TypeError("You must pass a function to map's second argument.");
     }
     var resultLen = results.length, mappedResults = [], i;
     for (i = 0; i < resultLen; i++) {
      mappedResults.push(mapFn(results[i]));
     }
     return all(mappedResults, label);
    });
   };
  });
  define("rsvp/node", [ "./promise", "exports" ], function(__dependency1__, __exports__) {
   var Promise = __dependency1__["default"];
   var slice = Array.prototype.slice;
   function makeNodeCallbackFor(resolve, reject) {
    return function(error, value) {
     if (error) {
      reject(error);
     } else if (arguments.length > 2) {
      resolve(slice.call(arguments, 1));
     } else {
      resolve(value);
     }
    };
   }
   __exports__["default"] = function denodeify(nodeFunc, binding) {
    return function() {
     var nodeArgs = slice.call(arguments), resolve, reject;
     var thisArg = this || binding;
     return new Promise(function(resolve, reject) {
      Promise.all(nodeArgs).then(function(nodeArgs) {
       try {
        nodeArgs.push(makeNodeCallbackFor(resolve, reject));
        nodeFunc.apply(thisArg, nodeArgs);
       } catch (e) {
        reject(e);
       }
      });
     });
    };
   };
  });
  define("rsvp/promise", [ "./config", "./events", "./instrument", "./utils", "./promise/cast", "./promise/all", "./promise/race", "./promise/resolve", "./promise/reject", "exports" ], function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __dependency9__, __exports__) {
   var config = __dependency1__.config;
   var EventTarget = __dependency2__["default"];
   var instrument = __dependency3__["default"];
   var objectOrFunction = __dependency4__.objectOrFunction;
   var isFunction = __dependency4__.isFunction;
   var now = __dependency4__.now;
   var cast = __dependency5__["default"];
   var all = __dependency6__["default"];
   var race = __dependency7__["default"];
   var Resolve = __dependency8__["default"];
   var Reject = __dependency9__["default"];
   var guidKey = "rsvp_" + now() + "-";
   var counter = 0;
   function noop() {}
   __exports__["default"] = Promise;
   function Promise(resolver, label) {
    if (!isFunction(resolver)) {
     throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
    }
    if (!(this instanceof Promise)) {
     throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }
    this._id = counter++;
    this._label = label;
    this._subscribers = [];
    if (config.instrument) {
     instrument("created", this);
    }
    if (noop !== resolver) {
     invokeResolver(resolver, this);
    }
   }
   function invokeResolver(resolver, promise) {
    function resolvePromise(value) {
     resolve(promise, value);
    }
    function rejectPromise(reason) {
     reject(promise, reason);
    }
    try {
     resolver(resolvePromise, rejectPromise);
    } catch (e) {
     rejectPromise(e);
    }
   }
   Promise.cast = cast;
   Promise.all = all;
   Promise.race = race;
   Promise.resolve = Resolve;
   Promise.reject = Reject;
   var PENDING = void 0;
   var SEALED = 0;
   var FULFILLED = 1;
   var REJECTED = 2;
   function subscribe(parent, child, onFulfillment, onRejection) {
    var subscribers = parent._subscribers;
    var length = subscribers.length;
    subscribers[length] = child;
    subscribers[length + FULFILLED] = onFulfillment;
    subscribers[length + REJECTED] = onRejection;
   }
   function publish(promise, settled) {
    var child, callback, subscribers = promise._subscribers, detail = promise._detail;
    if (config.instrument) {
     instrument(settled === FULFILLED ? "fulfilled" :"rejected", promise);
    }
    for (var i = 0; i < subscribers.length; i += 3) {
     child = subscribers[i];
     callback = subscribers[i + settled];
     invokeCallback(settled, child, callback, detail);
    }
    promise._subscribers = null;
   }
   Promise.prototype = {
    constructor:Promise,
    _id:undefined,
    _guidKey:guidKey,
    _label:undefined,
    _state:undefined,
    _detail:undefined,
    _subscribers:undefined,
    _onerror:function(reason) {
     config.trigger("error", reason);
    },
    then:function(onFulfillment, onRejection, label) {
     var promise = this;
     this._onerror = null;
     var thenPromise = new this.constructor(noop, label);
     if (this._state) {
      var callbacks = arguments;
      config.async(function invokePromiseCallback() {
       invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
      });
     } else {
      subscribe(this, thenPromise, onFulfillment, onRejection);
     }
     if (config.instrument) {
      instrument("chained", promise, thenPromise);
     }
     return thenPromise;
    },
    "catch":function(onRejection, label) {
     return this.then(null, onRejection, label);
    },
    "finally":function(callback, label) {
     var constructor = this.constructor;
     return this.then(function(value) {
      return constructor.cast(callback()).then(function() {
       return value;
      });
     }, function(reason) {
      return constructor.cast(callback()).then(function() {
       throw reason;
      });
     }, label);
    }
   };
   function invokeCallback(settled, promise, callback, detail) {
    var hasCallback = isFunction(callback), value, error, succeeded, failed;
    if (hasCallback) {
     try {
      value = callback(detail);
      succeeded = true;
     } catch (e) {
      failed = true;
      error = e;
     }
    } else {
     value = detail;
     succeeded = true;
    }
    if (handleThenable(promise, value)) {
     return;
    } else if (hasCallback && succeeded) {
     resolve(promise, value);
    } else if (failed) {
     reject(promise, error);
    } else if (settled === FULFILLED) {
     resolve(promise, value);
    } else if (settled === REJECTED) {
     reject(promise, value);
    }
   }
   function handleThenable(promise, value) {
    var then = null, resolved;
    try {
     if (promise === value) {
      throw new TypeError("A promises callback cannot return that same promise.");
     }
     if (objectOrFunction(value)) {
      then = value.then;
      if (isFunction(then)) {
       then.call(value, function(val) {
        if (resolved) {
         return true;
        }
        resolved = true;
        if (value !== val) {
         resolve(promise, val);
        } else {
         fulfill(promise, val);
        }
       }, function(val) {
        if (resolved) {
         return true;
        }
        resolved = true;
        reject(promise, val);
       }, "derived from: " + (promise._label || " unknown promise"));
       return true;
      }
     }
    } catch (error) {
     if (resolved) {
      return true;
     }
     reject(promise, error);
     return true;
    }
    return false;
   }
   function resolve(promise, value) {
    if (promise === value) {
     fulfill(promise, value);
    } else if (!handleThenable(promise, value)) {
     fulfill(promise, value);
    }
   }
   function fulfill(promise, value) {
    if (promise._state !== PENDING) {
     return;
    }
    promise._state = SEALED;
    promise._detail = value;
    config.async(publishFulfillment, promise);
   }
   function reject(promise, reason) {
    if (promise._state !== PENDING) {
     return;
    }
    promise._state = SEALED;
    promise._detail = reason;
    config.async(publishRejection, promise);
   }
   function publishFulfillment(promise) {
    publish(promise, promise._state = FULFILLED);
   }
   function publishRejection(promise) {
    if (promise._onerror) {
     promise._onerror(promise._detail);
    }
    publish(promise, promise._state = REJECTED);
   }
  });
  define("rsvp/promise/all", [ "../utils", "exports" ], function(__dependency1__, __exports__) {
   var isArray = __dependency1__.isArray;
   var isNonThenable = __dependency1__.isNonThenable;
   __exports__["default"] = function all(entries, label) {
    var Constructor = this;
    return new Constructor(function(resolve, reject) {
     if (!isArray(entries)) {
      throw new TypeError("You must pass an array to all.");
     }
     var remaining = entries.length;
     var results = new Array(remaining);
     var entry, pending = true;
     if (remaining === 0) {
      resolve(results);
      return;
     }
     function fulfillmentAt(index) {
      return function(value) {
       results[index] = value;
       if (--remaining === 0) {
        resolve(results);
       }
      };
     }
     function onRejection(reason) {
      remaining = 0;
      reject(reason);
     }
     for (var index = 0; index < entries.length; index++) {
      entry = entries[index];
      if (isNonThenable(entry)) {
       results[index] = entry;
       if (--remaining === 0) {
        resolve(results);
       }
      } else {
       Constructor.cast(entry).then(fulfillmentAt(index), onRejection);
      }
     }
    }, label);
   };
  });
  define("rsvp/promise/cast", [ "exports" ], function(__exports__) {
   __exports__["default"] = function cast(object, label) {
    var Constructor = this;
    if (object && typeof object === "object" && object.constructor === Constructor) {
     return object;
    }
    return new Constructor(function(resolve) {
     resolve(object);
    }, label);
   };
  });
  define("rsvp/promise/race", [ "../utils", "exports" ], function(__dependency1__, __exports__) {
   var isArray = __dependency1__.isArray;
   var isFunction = __dependency1__.isFunction;
   var isNonThenable = __dependency1__.isNonThenable;
   __exports__["default"] = function race(entries, label) {
    var Constructor = this, entry;
    return new Constructor(function(resolve, reject) {
     if (!isArray(entries)) {
      throw new TypeError("You must pass an array to race.");
     }
     var pending = true;
     function onFulfillment(value) {
      if (pending) {
       pending = false;
       resolve(value);
      }
     }
     function onRejection(reason) {
      if (pending) {
       pending = false;
       reject(reason);
      }
     }
     for (var i = 0; i < entries.length; i++) {
      entry = entries[i];
      if (isNonThenable(entry)) {
       pending = false;
       resolve(entry);
       return;
      } else {
       Constructor.cast(entry).then(onFulfillment, onRejection);
      }
     }
    }, label);
   };
  });
  define("rsvp/promise/reject", [ "exports" ], function(__exports__) {
   __exports__["default"] = function reject(reason, label) {
    var Constructor = this;
    return new Constructor(function(resolve, reject) {
     reject(reason);
    }, label);
   };
  });
  define("rsvp/promise/resolve", [ "exports" ], function(__exports__) {
   __exports__["default"] = function resolve(value, label) {
    var Constructor = this;
    return new Constructor(function(resolve, reject) {
     resolve(value);
    }, label);
   };
  });
  define("rsvp/race", [ "./promise", "exports" ], function(__dependency1__, __exports__) {
   var Promise = __dependency1__["default"];
   __exports__["default"] = function race(array, label) {
    return Promise.race(array, label);
   };
  });
  define("rsvp/reject", [ "./promise", "exports" ], function(__dependency1__, __exports__) {
   var Promise = __dependency1__["default"];
   __exports__["default"] = function reject(reason, label) {
    return Promise.reject(reason, label);
   };
  });
  define("rsvp/resolve", [ "./promise", "exports" ], function(__dependency1__, __exports__) {
   var Promise = __dependency1__["default"];
   __exports__["default"] = function resolve(value, label) {
    return Promise.resolve(value, label);
   };
  });
  define("rsvp/rethrow", [ "exports" ], function(__exports__) {
   __exports__["default"] = function rethrow(reason) {
    setTimeout(function() {
     throw reason;
    });
    throw reason;
   };
  });
  define("rsvp/utils", [ "exports" ], function(__exports__) {
   function objectOrFunction(x) {
    return typeof x === "function" || typeof x === "object" && x !== null;
   }
   __exports__.objectOrFunction = objectOrFunction;
   function isFunction(x) {
    return typeof x === "function";
   }
   __exports__.isFunction = isFunction;
   function isNonThenable(x) {
    return !objectOrFunction(x);
   }
   __exports__.isNonThenable = isNonThenable;
   function isArray(x) {
    return Object.prototype.toString.call(x) === "[object Array]";
   }
   __exports__.isArray = isArray;
   var now = Date.now || function() {
    return new Date().getTime();
   };
   __exports__.now = now;
   var keysOf = Object.keys || function(object) {
    var result = [];
    for (var prop in object) {
     result.push(prop);
    }
    return result;
   };
   __exports__.keysOf = keysOf;
  });
  define("rsvp", [ "./rsvp/promise", "./rsvp/events", "./rsvp/node", "./rsvp/all", "./rsvp/all_settled", "./rsvp/race", "./rsvp/hash", "./rsvp/rethrow", "./rsvp/defer", "./rsvp/config", "./rsvp/map", "./rsvp/resolve", "./rsvp/reject", "./rsvp/filter", "exports" ], function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __dependency9__, __dependency10__, __dependency11__, __dependency12__, __dependency13__, __dependency14__, __exports__) {
   var Promise = __dependency1__["default"];
   var EventTarget = __dependency2__["default"];
   var denodeify = __dependency3__["default"];
   var all = __dependency4__["default"];
   var allSettled = __dependency5__["default"];
   var race = __dependency6__["default"];
   var hash = __dependency7__["default"];
   var rethrow = __dependency8__["default"];
   var defer = __dependency9__["default"];
   var config = __dependency10__.config;
   var configure = __dependency10__.configure;
   var map = __dependency11__["default"];
   var resolve = __dependency12__["default"];
   var reject = __dependency13__["default"];
   var filter = __dependency14__["default"];
   function async(callback, arg) {
    config.async(callback, arg);
   }
   function on() {
    config.on.apply(config, arguments);
   }
   function off() {
    config.off.apply(config, arguments);
   }
   if (typeof window !== "undefined" && typeof window.__PROMISE_INSTRUMENTATION__ === "object") {
    var callbacks = window.__PROMISE_INSTRUMENTATION__;
    configure("instrument", true);
    for (var eventName in callbacks) {
     if (callbacks.hasOwnProperty(eventName)) {
      on(eventName, callbacks[eventName]);
     }
    }
   }
   __exports__.Promise = Promise;
   __exports__.EventTarget = EventTarget;
   __exports__.all = all;
   __exports__.allSettled = allSettled;
   __exports__.race = race;
   __exports__.hash = hash;
   __exports__.rethrow = rethrow;
   __exports__.defer = defer;
   __exports__.denodeify = denodeify;
   __exports__.configure = configure;
   __exports__.on = on;
   __exports__.off = off;
   __exports__.resolve = resolve;
   __exports__.reject = reject;
   __exports__.async = async;
   __exports__.map = map;
   __exports__.filter = filter;
  });
 })();
 (function() {
  Ember.MODEL_FACTORY_INJECTIONS = false || !!Ember.ENV.MODEL_FACTORY_INJECTIONS;
  define("container", [], function() {
   function InheritingDict(parent) {
    this.parent = parent;
    this.dict = {};
   }
   InheritingDict.prototype = {
    parent:null,
    dict:null,
    get:function(key) {
     var dict = this.dict;
     if (dict.hasOwnProperty(key)) {
      return dict[key];
     }
     if (this.parent) {
      return this.parent.get(key);
     }
    },
    set:function(key, value) {
     this.dict[key] = value;
    },
    remove:function(key) {
     delete this.dict[key];
    },
    has:function(key) {
     var dict = this.dict;
     if (dict.hasOwnProperty(key)) {
      return true;
     }
     if (this.parent) {
      return this.parent.has(key);
     }
     return false;
    },
    eachLocal:function(callback, binding) {
     var dict = this.dict;
     for (var prop in dict) {
      if (dict.hasOwnProperty(prop)) {
       callback.call(binding, prop, dict[prop]);
      }
     }
    }
   };
   function Container(parent) {
    this.parent = parent;
    this.children = [];
    this.resolver = parent && parent.resolver || function() {};
    this.registry = new InheritingDict(parent && parent.registry);
    this.cache = new InheritingDict(parent && parent.cache);
    this.factoryCache = new InheritingDict(parent && parent.factoryCache);
    this.resolveCache = new InheritingDict(parent && parent.resolveCache);
    this.typeInjections = new InheritingDict(parent && parent.typeInjections);
    this.injections = {};
    this.factoryTypeInjections = new InheritingDict(parent && parent.factoryTypeInjections);
    this.factoryInjections = {};
    this._options = new InheritingDict(parent && parent._options);
    this._typeOptions = new InheritingDict(parent && parent._typeOptions);
   }
   Container.prototype = {
    parent:null,
    children:null,
    resolver:null,
    registry:null,
    cache:null,
    typeInjections:null,
    injections:null,
    _options:null,
    _typeOptions:null,
    child:function() {
     var container = new Container(this);
     this.children.push(container);
     return container;
    },
    set:function(object, key, value) {
     object[key] = value;
    },
    register:function(fullName, factory, options) {
     validateFullName(fullName);
     if (factory === undefined) {
      throw new TypeError("Attempting to register an unknown factory: `" + fullName + "`");
     }
     var normalizedName = this.normalize(fullName);
     if (this.cache.has(normalizedName)) {
      throw new Error("Cannot re-register: `" + fullName + "`, as it has already been looked up.");
     }
     this.registry.set(normalizedName, factory);
     this._options.set(normalizedName, options || {});
    },
    unregister:function(fullName) {
     validateFullName(fullName);
     var normalizedName = this.normalize(fullName);
     this.registry.remove(normalizedName);
     this.cache.remove(normalizedName);
     this.factoryCache.remove(normalizedName);
     this.resolveCache.remove(normalizedName);
     this._options.remove(normalizedName);
    },
    resolve:function(fullName) {
     validateFullName(fullName);
     var normalizedName = this.normalize(fullName);
     var cached = this.resolveCache.get(normalizedName);
     if (cached) {
      return cached;
     }
     var resolved = this.resolver(normalizedName) || this.registry.get(normalizedName);
     this.resolveCache.set(normalizedName, resolved);
     return resolved;
    },
    describe:function(fullName) {
     return fullName;
    },
    normalize:function(fullName) {
     return fullName;
    },
    makeToString:function(factory, fullName) {
     return factory.toString();
    },
    lookup:function(fullName, options) {
     validateFullName(fullName);
     return lookup(this, this.normalize(fullName), options);
    },
    lookupFactory:function(fullName) {
     validateFullName(fullName);
     return factoryFor(this, this.normalize(fullName));
    },
    has:function(fullName) {
     validateFullName(fullName);
     return has(this, this.normalize(fullName));
    },
    optionsForType:function(type, options) {
     if (this.parent) {
      illegalChildOperation("optionsForType");
     }
     this._typeOptions.set(type, options);
    },
    options:function(type, options) {
     this.optionsForType(type, options);
    },
    typeInjection:function(type, property, fullName) {
     validateFullName(fullName);
     if (this.parent) {
      illegalChildOperation("typeInjection");
     }
     addTypeInjection(this.typeInjections, type, property, fullName);
    },
    injection:function(fullName, property, injectionName) {
     if (this.parent) {
      illegalChildOperation("injection");
     }
     validateFullName(injectionName);
     var normalizedInjectionName = this.normalize(injectionName);
     if (fullName.indexOf(":") === -1) {
      return this.typeInjection(fullName, property, normalizedInjectionName);
     }
     validateFullName(fullName);
     var normalizedName = this.normalize(fullName);
     addInjection(this.injections, normalizedName, property, normalizedInjectionName);
    },
    factoryTypeInjection:function(type, property, fullName) {
     if (this.parent) {
      illegalChildOperation("factoryTypeInjection");
     }
     addTypeInjection(this.factoryTypeInjections, type, property, this.normalize(fullName));
    },
    factoryInjection:function(fullName, property, injectionName) {
     if (this.parent) {
      illegalChildOperation("injection");
     }
     var normalizedName = this.normalize(fullName);
     var normalizedInjectionName = this.normalize(injectionName);
     validateFullName(injectionName);
     if (fullName.indexOf(":") === -1) {
      return this.factoryTypeInjection(normalizedName, property, normalizedInjectionName);
     }
     validateFullName(fullName);
     addInjection(this.factoryInjections, normalizedName, property, normalizedInjectionName);
    },
    destroy:function() {
     for (var i = 0, l = this.children.length; i < l; i++) {
      this.children[i].destroy();
     }
     this.children = [];
     eachDestroyable(this, function(item) {
      item.destroy();
     });
     this.parent = undefined;
     this.isDestroyed = true;
    },
    reset:function() {
     for (var i = 0, l = this.children.length; i < l; i++) {
      resetCache(this.children[i]);
     }
     resetCache(this);
    }
   };
   function has(container, fullName) {
    if (container.cache.has(fullName)) {
     return true;
    }
    return !!container.resolve(fullName);
   }
   function lookup(container, fullName, options) {
    options = options || {};
    if (container.cache.has(fullName) && options.singleton !== false) {
     return container.cache.get(fullName);
    }
    var value = instantiate(container, fullName);
    if (value === undefined) {
     return;
    }
    if (isSingleton(container, fullName) && options.singleton !== false) {
     container.cache.set(fullName, value);
    }
    return value;
   }
   function illegalChildOperation(operation) {
    throw new Error(operation + " is not currently supported on child containers");
   }
   function isSingleton(container, fullName) {
    var singleton = option(container, fullName, "singleton");
    return singleton !== false;
   }
   function buildInjections(container, injections) {
    var hash = {};
    if (!injections) {
     return hash;
    }
    var injection, injectable;
    for (var i = 0, l = injections.length; i < l; i++) {
     injection = injections[i];
     injectable = lookup(container, injection.fullName);
     if (injectable !== undefined) {
      hash[injection.property] = injectable;
     } else {
      throw new Error("Attempting to inject an unknown injection: `" + injection.fullName + "`");
     }
    }
    return hash;
   }
   function option(container, fullName, optionName) {
    var options = container._options.get(fullName);
    if (options && options[optionName] !== undefined) {
     return options[optionName];
    }
    var type = fullName.split(":")[0];
    options = container._typeOptions.get(type);
    if (options) {
     return options[optionName];
    }
   }
   function factoryFor(container, fullName) {
    var name = fullName;
    var factory = container.resolve(name);
    var injectedFactory;
    var cache = container.factoryCache;
    var type = fullName.split(":")[0];
    if (factory === undefined) {
     return;
    }
    if (cache.has(fullName)) {
     return cache.get(fullName);
    }
    if (!factory || typeof factory.extend !== "function" || !Ember.MODEL_FACTORY_INJECTIONS && type === "model") {
     return factory;
    } else {
     var injections = injectionsFor(container, fullName);
     var factoryInjections = factoryInjectionsFor(container, fullName);
     factoryInjections._toString = container.makeToString(factory, fullName);
     injectedFactory = factory.extend(injections);
     injectedFactory.reopenClass(factoryInjections);
     cache.set(fullName, injectedFactory);
     return injectedFactory;
    }
   }
   function injectionsFor(container, fullName) {
    var splitName = fullName.split(":"), type = splitName[0], injections = [];
    injections = injections.concat(container.typeInjections.get(type) || []);
    injections = injections.concat(container.injections[fullName] || []);
    injections = buildInjections(container, injections);
    injections._debugContainerKey = fullName;
    injections.container = container;
    return injections;
   }
   function factoryInjectionsFor(container, fullName) {
    var splitName = fullName.split(":"), type = splitName[0], factoryInjections = [];
    factoryInjections = factoryInjections.concat(container.factoryTypeInjections.get(type) || []);
    factoryInjections = factoryInjections.concat(container.factoryInjections[fullName] || []);
    factoryInjections = buildInjections(container, factoryInjections);
    factoryInjections._debugContainerKey = fullName;
    return factoryInjections;
   }
   function instantiate(container, fullName) {
    var factory = factoryFor(container, fullName);
    if (option(container, fullName, "instantiate") === false) {
     return factory;
    }
    if (factory) {
     if (typeof factory.extend === "function") {
      return factory.create();
     } else {
      return factory.create(injectionsFor(container, fullName));
     }
    }
   }
   function eachDestroyable(container, callback) {
    container.cache.eachLocal(function(key, value) {
     if (option(container, key, "instantiate") === false) {
      return;
     }
     callback(value);
    });
   }
   function resetCache(container) {
    container.cache.eachLocal(function(key, value) {
     if (option(container, key, "instantiate") === false) {
      return;
     }
     value.destroy();
    });
    container.cache.dict = {};
   }
   function addTypeInjection(rules, type, property, fullName) {
    var injections = rules.get(type);
    if (!injections) {
     injections = [];
     rules.set(type, injections);
    }
    injections.push({
     property:property,
     fullName:fullName
    });
   }
   var VALID_FULL_NAME_REGEXP = /^[^:]+.+:[^:]+$/;
   function validateFullName(fullName) {
    if (!VALID_FULL_NAME_REGEXP.test(fullName)) {
     throw new TypeError("Invalid Fullname, expected: `type:name` got: " + fullName);
    }
   }
   function addInjection(rules, factoryName, property, injectionName) {
    var injections = rules[factoryName] = rules[factoryName] || [];
    injections.push({
     property:property,
     fullName:injectionName
    });
   }
   return Container;
  });
 })();
 (function() {
  var indexOf = Ember.EnumerableUtils.indexOf;
  Ember.compare = function compare(v, w) {
   if (v === w) {
    return 0;
   }
   var type1 = Ember.typeOf(v);
   var type2 = Ember.typeOf(w);
   var Comparable = Ember.Comparable;
   if (Comparable) {
    if (type1 === "instance" && Comparable.detect(v.constructor)) {
     return v.constructor.compare(v, w);
    }
    if (type2 === "instance" && Comparable.detect(w.constructor)) {
     return 1 - w.constructor.compare(w, v);
    }
   }
   var mapping = Ember.ORDER_DEFINITION_MAPPING;
   if (!mapping) {
    var order = Ember.ORDER_DEFINITION;
    mapping = Ember.ORDER_DEFINITION_MAPPING = {};
    var idx, len;
    for (idx = 0, len = order.length; idx < len; ++idx) {
     mapping[order[idx]] = idx;
    }
    delete Ember.ORDER_DEFINITION;
   }
   var type1Index = mapping[type1];
   var type2Index = mapping[type2];
   if (type1Index < type2Index) {
    return -1;
   }
   if (type1Index > type2Index) {
    return 1;
   }
   switch (type1) {
   case "boolean":
   case "number":
    if (v < w) {
     return -1;
    }
    if (v > w) {
     return 1;
    }
    return 0;

   case "string":
    var comp = v.localeCompare(w);
    if (comp < 0) {
     return -1;
    }
    if (comp > 0) {
     return 1;
    }
    return 0;

   case "array":
    var vLen = v.length;
    var wLen = w.length;
    var l = Math.min(vLen, wLen);
    var r = 0;
    var i = 0;
    while (r === 0 && i < l) {
     r = compare(v[i], w[i]);
     i++;
    }
    if (r !== 0) {
     return r;
    }
    if (vLen < wLen) {
     return -1;
    }
    if (vLen > wLen) {
     return 1;
    }
    return 0;

   case "instance":
    if (Ember.Comparable && Ember.Comparable.detect(v)) {
     return v.compare(v, w);
    }
    return 0;

   case "date":
    var vNum = v.getTime();
    var wNum = w.getTime();
    if (vNum < wNum) {
     return -1;
    }
    if (vNum > wNum) {
     return 1;
    }
    return 0;

   default:
    return 0;
   }
  };
  function _copy(obj, deep, seen, copies) {
   var ret, loc, key;
   if ("object" !== typeof obj || obj === null) return obj;
   if (deep && (loc = indexOf(seen, obj)) >= 0) return copies[loc];
   if (Ember.typeOf(obj) === "array") {
    ret = obj.slice();
    if (deep) {
     loc = ret.length;
     while (--loc >= 0) ret[loc] = _copy(ret[loc], deep, seen, copies);
    }
   } else if (Ember.Copyable && Ember.Copyable.detect(obj)) {
    ret = obj.copy(deep, seen, copies);
   } else {
    ret = {};
    for (key in obj) {
     if (!obj.hasOwnProperty(key)) continue;
     if (key.substring(0, 2) === "__") continue;
     ret[key] = deep ? _copy(obj[key], deep, seen, copies) :obj[key];
    }
   }
   if (deep) {
    seen.push(obj);
    copies.push(ret);
   }
   return ret;
  }
  Ember.copy = function(obj, deep) {
   if ("object" !== typeof obj || obj === null) return obj;
   if (Ember.Copyable && Ember.Copyable.detect(obj)) return obj.copy(deep);
   return _copy(obj, deep, deep ? [] :null, deep ? [] :null);
  };
  Ember.isEqual = function(a, b) {
   if (a && "function" === typeof a.isEqual) return a.isEqual(b);
   return a === b;
  };
  Ember.ORDER_DEFINITION = Ember.ENV.ORDER_DEFINITION || [ "undefined", "null", "boolean", "number", "string", "array", "object", "instance", "function", "class", "date" ];
  Ember.keys = Object.keys;
  if (!Ember.keys || Ember.create.isSimulated) {
   var prototypeProperties = [ "constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "valueOf", "toLocaleString", "toString" ], pushPropertyName = function(obj, array, key) {
    if (key.substring(0, 2) === "__") return;
    if (key === "_super") return;
    if (indexOf(array, key) >= 0) return;
    if (!obj.hasOwnProperty(key)) return;
    array.push(key);
   };
   Ember.keys = function(obj) {
    var ret = [], key;
    for (key in obj) {
     pushPropertyName(obj, ret, key);
    }
    for (var i = 0, l = prototypeProperties.length; i < l; i++) {
     key = prototypeProperties[i];
     pushPropertyName(obj, ret, key);
    }
    return ret;
   };
  }
 })();
 (function() {
  var STRING_DASHERIZE_REGEXP = /[ _]/g;
  var STRING_DASHERIZE_CACHE = {};
  var STRING_DECAMELIZE_REGEXP = /([a-z\d])([A-Z])/g;
  var STRING_CAMELIZE_REGEXP = /(\-|_|\.|\s)+(.)?/g;
  var STRING_UNDERSCORE_REGEXP_1 = /([a-z\d])([A-Z]+)/g;
  var STRING_UNDERSCORE_REGEXP_2 = /\-|\s+/g;
  var STRING_PARAMETERIZE_REGEXP_1 = /[_|\/|\s]+/g;
  var STRING_PARAMETERIZE_REGEXP_2 = /[^a-z0-9\-]+/gi;
  var STRING_PARAMETERIZE_REGEXP_3 = /[\-]+/g;
  var STRING_PARAMETERIZE_REGEXP_4 = /^-+|-+$/g;
  Ember.STRINGS = {};
  Ember.String = {
   fmt:function(str, formats) {
    var idx = 0;
    return str.replace(/%@([0-9]+)?/g, function(s, argIndex) {
     argIndex = argIndex ? parseInt(argIndex, 10) - 1 :idx++;
     s = formats[argIndex];
     return s === null ? "(null)" :s === undefined ? "" :Ember.inspect(s);
    });
   },
   loc:function(str, formats) {
    str = Ember.STRINGS[str] || str;
    return Ember.String.fmt(str, formats);
   },
   w:function(str) {
    return str.split(/\s+/);
   },
   decamelize:function(str) {
    return str.replace(STRING_DECAMELIZE_REGEXP, "$1_$2").toLowerCase();
   },
   dasherize:function(str) {
    var cache = STRING_DASHERIZE_CACHE, hit = cache.hasOwnProperty(str), ret;
    if (hit) {
     return cache[str];
    } else {
     ret = Ember.String.decamelize(str).replace(STRING_DASHERIZE_REGEXP, "-");
     cache[str] = ret;
    }
    return ret;
   },
   camelize:function(str) {
    return str.replace(STRING_CAMELIZE_REGEXP, function(match, separator, chr) {
     return chr ? chr.toUpperCase() :"";
    }).replace(/^([A-Z])/, function(match, separator, chr) {
     return match.toLowerCase();
    });
   },
   classify:function(str) {
    var parts = str.split("."), out = [];
    for (var i = 0, l = parts.length; i < l; i++) {
     var camelized = Ember.String.camelize(parts[i]);
     out.push(camelized.charAt(0).toUpperCase() + camelized.substr(1));
    }
    return out.join(".");
   },
   underscore:function(str) {
    return str.replace(STRING_UNDERSCORE_REGEXP_1, "$1_$2").replace(STRING_UNDERSCORE_REGEXP_2, "_").toLowerCase();
   },
   capitalize:function(str) {
    return str.charAt(0).toUpperCase() + str.substr(1);
   }
  };
  if (Ember.FEATURES.isEnabled("string-humanize")) {
   Ember.String.humanize = function(str) {
    return str.replace(/_id$/, "").replace(/_/g, " ").replace(/^\w/g, function(s) {
     return s.toUpperCase();
    });
   };
  }
  if (Ember.FEATURES.isEnabled("string-parameterize")) {
   Ember.String.parameterize = function(str) {
    return str.replace(STRING_PARAMETERIZE_REGEXP_1, "-").replace(STRING_PARAMETERIZE_REGEXP_2, "").replace(STRING_PARAMETERIZE_REGEXP_3, "-").replace(STRING_PARAMETERIZE_REGEXP_4, "").toLowerCase();
   };
  }
 })();
 (function() {
  var fmt = Ember.String.fmt, w = Ember.String.w, loc = Ember.String.loc, camelize = Ember.String.camelize, decamelize = Ember.String.decamelize, dasherize = Ember.String.dasherize, underscore = Ember.String.underscore, capitalize = Ember.String.capitalize, classify = Ember.String.classify;
  if (Ember.FEATURES.isEnabled("string-humanize")) {
   var humanize = Ember.String.humanize;
  }
  if (Ember.FEATURES.isEnabled("string-parameterize")) {
   var parameterize = Ember.String.parameterize;
  }
  if (Ember.EXTEND_PROTOTYPES === true || Ember.EXTEND_PROTOTYPES.String) {
   String.prototype.fmt = function() {
    return fmt(this, arguments);
   };
   String.prototype.w = function() {
    return w(this);
   };
   String.prototype.loc = function() {
    return loc(this, arguments);
   };
   String.prototype.camelize = function() {
    return camelize(this);
   };
   String.prototype.decamelize = function() {
    return decamelize(this);
   };
   String.prototype.dasherize = function() {
    return dasherize(this);
   };
   String.prototype.underscore = function() {
    return underscore(this);
   };
   String.prototype.classify = function() {
    return classify(this);
   };
   String.prototype.capitalize = function() {
    return capitalize(this);
   };
   if (Ember.FEATURES.isEnabled("string-humanize")) {
    String.prototype.humanize = function() {
     return humanize(this);
    };
   }
   if (Ember.FEATURES.isEnabled("string-parameterize")) {
    String.prototype.parameterize = function() {
     return parameterize(this);
    };
   }
  }
 })();
 (function() {
  var get = Ember.get, set = Ember.set, slice = Array.prototype.slice, getProperties = Ember.getProperties;
  Ember.Observable = Ember.Mixin.create({
   get:function(keyName) {
    return get(this, keyName);
   },
   getProperties:function() {
    return getProperties.apply(null, [ this ].concat(slice.call(arguments)));
   },
   set:function(keyName, value) {
    set(this, keyName, value);
    return this;
   },
   setProperties:function(hash) {
    return Ember.setProperties(this, hash);
   },
   beginPropertyChanges:function() {
    Ember.beginPropertyChanges();
    return this;
   },
   endPropertyChanges:function() {
    Ember.endPropertyChanges();
    return this;
   },
   propertyWillChange:function(keyName) {
    Ember.propertyWillChange(this, keyName);
    return this;
   },
   propertyDidChange:function(keyName) {
    Ember.propertyDidChange(this, keyName);
    return this;
   },
   notifyPropertyChange:function(keyName) {
    this.propertyWillChange(keyName);
    this.propertyDidChange(keyName);
    return this;
   },
   addBeforeObserver:function(key, target, method) {
    Ember.addBeforeObserver(this, key, target, method);
   },
   addObserver:function(key, target, method) {
    Ember.addObserver(this, key, target, method);
   },
   removeObserver:function(key, target, method) {
    Ember.removeObserver(this, key, target, method);
   },
   hasObserverFor:function(key) {
    return Ember.hasListeners(this, key + ":change");
   },
   getWithDefault:function(keyName, defaultValue) {
    return Ember.getWithDefault(this, keyName, defaultValue);
   },
   incrementProperty:function(keyName, increment) {
    if (Ember.isNone(increment)) {
     increment = 1;
    }
    set(this, keyName, (get(this, keyName) || 0) + increment);
    return get(this, keyName);
   },
   decrementProperty:function(keyName, decrement) {
    if (Ember.isNone(decrement)) {
     decrement = 1;
    }
    set(this, keyName, (get(this, keyName) || 0) - decrement);
    return get(this, keyName);
   },
   toggleProperty:function(keyName) {
    set(this, keyName, !get(this, keyName));
    return get(this, keyName);
   },
   cacheFor:function(keyName) {
    return Ember.cacheFor(this, keyName);
   },
   observersForKey:function(keyName) {
    return Ember.observersFor(this, keyName);
   }
  });
 })();
 (function() {
  var set = Ember.set, get = Ember.get, o_create = Ember.create, o_defineProperty = Ember.platform.defineProperty, GUID_KEY = Ember.GUID_KEY, guidFor = Ember.guidFor, generateGuid = Ember.generateGuid, meta = Ember.meta, META_KEY = Ember.META_KEY, rewatch = Ember.rewatch, finishChains = Ember.finishChains, sendEvent = Ember.sendEvent, destroy = Ember.destroy, schedule = Ember.run.schedule, Mixin = Ember.Mixin, applyMixin = Mixin._apply, finishPartial = Mixin.finishPartial, reopen = Mixin.prototype.reopen, MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER, indexOf = Ember.EnumerableUtils.indexOf;
  var undefinedDescriptor = {
   configurable:true,
   writable:true,
   enumerable:false,
   value:undefined
  };
  function makeCtor() {
   var wasApplied = false, initMixins, initProperties;
   var Class = function() {
    if (!wasApplied) {
     Class.proto();
    }
    o_defineProperty(this, GUID_KEY, undefinedDescriptor);
    o_defineProperty(this, "_super", undefinedDescriptor);
    var m = meta(this), proto = m.proto;
    m.proto = this;
    if (initMixins) {
     var mixins = initMixins;
     initMixins = null;
     this.reopen.apply(this, mixins);
    }
    if (initProperties) {
     var props = initProperties;
     initProperties = null;
     var concatenatedProperties = this.concatenatedProperties;
     for (var i = 0, l = props.length; i < l; i++) {
      var properties = props[i];
      if (typeof properties !== "object" && properties !== undefined) {
       throw new Ember.Error("Ember.Object.create only accepts objects.");
      }
      if (!properties) {
       continue;
      }
      var keyNames = Ember.keys(properties);
      for (var j = 0, ll = keyNames.length; j < ll; j++) {
       var keyName = keyNames[j];
       if (!properties.hasOwnProperty(keyName)) {
        continue;
       }
       var value = properties[keyName], IS_BINDING = Ember.IS_BINDING;
       if (IS_BINDING.test(keyName)) {
        var bindings = m.bindings;
        if (!bindings) {
         bindings = m.bindings = {};
        } else if (!m.hasOwnProperty("bindings")) {
         bindings = m.bindings = o_create(m.bindings);
        }
        bindings[keyName] = value;
       }
       var desc = m.descs[keyName];
       if (concatenatedProperties && indexOf(concatenatedProperties, keyName) >= 0) {
        var baseValue = this[keyName];
        if (baseValue) {
         if ("function" === typeof baseValue.concat) {
          value = baseValue.concat(value);
         } else {
          value = Ember.makeArray(baseValue).concat(value);
         }
        } else {
         value = Ember.makeArray(value);
        }
       }
       if (desc) {
        desc.set(this, keyName, value);
       } else {
        if (typeof this.setUnknownProperty === "function" && !(keyName in this)) {
         this.setUnknownProperty(keyName, value);
        } else if (MANDATORY_SETTER) {
         Ember.defineProperty(this, keyName, null, value);
        } else {
         this[keyName] = value;
        }
       }
      }
     }
    }
    finishPartial(this, m);
    this.init.apply(this, arguments);
    m.proto = proto;
    finishChains(this);
    sendEvent(this, "init");
   };
   Class.toString = Mixin.prototype.toString;
   Class.willReopen = function() {
    if (wasApplied) {
     Class.PrototypeMixin = Mixin.create(Class.PrototypeMixin);
    }
    wasApplied = false;
   };
   Class._initMixins = function(args) {
    initMixins = args;
   };
   Class._initProperties = function(args) {
    initProperties = args;
   };
   Class.proto = function() {
    var superclass = Class.superclass;
    if (superclass) {
     superclass.proto();
    }
    if (!wasApplied) {
     wasApplied = true;
     Class.PrototypeMixin.applyPartial(Class.prototype);
     rewatch(Class.prototype);
    }
    return this.prototype;
   };
   return Class;
  }
  var CoreObject = makeCtor();
  CoreObject.toString = function() {
   return "Ember.CoreObject";
  };
  CoreObject.PrototypeMixin = Mixin.create({
   reopen:function() {
    applyMixin(this, arguments, true);
    return this;
   },
   init:function() {},
   concatenatedProperties:null,
   isDestroyed:false,
   isDestroying:false,
   destroy:function() {
    if (this.isDestroying) {
     return;
    }
    this.isDestroying = true;
    schedule("actions", this, this.willDestroy);
    schedule("destroy", this, this._scheduledDestroy);
    return this;
   },
   willDestroy:Ember.K,
   _scheduledDestroy:function() {
    if (this.isDestroyed) {
     return;
    }
    destroy(this);
    this.isDestroyed = true;
   },
   bind:function(to, from) {
    if (!(from instanceof Ember.Binding)) {
     from = Ember.Binding.from(from);
    }
    from.to(to).connect(this);
    return from;
   },
   toString:function toString() {
    var hasToStringExtension = typeof this.toStringExtension === "function", extension = hasToStringExtension ? ":" + this.toStringExtension() :"";
    var ret = "<" + this.constructor.toString() + ":" + guidFor(this) + extension + ">";
    this.toString = makeToString(ret);
    return ret;
   }
  });
  CoreObject.PrototypeMixin.ownerConstructor = CoreObject;
  function makeToString(ret) {
   return function() {
    return ret;
   };
  }
  if (Ember.config.overridePrototypeMixin) {
   Ember.config.overridePrototypeMixin(CoreObject.PrototypeMixin);
  }
  CoreObject.__super__ = null;
  var ClassMixin = Mixin.create({
   ClassMixin:Ember.required(),
   PrototypeMixin:Ember.required(),
   isClass:true,
   isMethod:false,
   extend:function() {
    var Class = makeCtor(), proto;
    Class.ClassMixin = Mixin.create(this.ClassMixin);
    Class.PrototypeMixin = Mixin.create(this.PrototypeMixin);
    Class.ClassMixin.ownerConstructor = Class;
    Class.PrototypeMixin.ownerConstructor = Class;
    reopen.apply(Class.PrototypeMixin, arguments);
    Class.superclass = this;
    Class.__super__ = this.prototype;
    proto = Class.prototype = o_create(this.prototype);
    proto.constructor = Class;
    generateGuid(proto);
    meta(proto).proto = proto;
    Class.ClassMixin.apply(Class);
    return Class;
   },
   createWithMixins:function() {
    var C = this;
    if (arguments.length > 0) {
     this._initMixins(arguments);
    }
    return new C();
   },
   create:function() {
    var C = this;
    if (arguments.length > 0) {
     this._initProperties(arguments);
    }
    return new C();
   },
   reopen:function() {
    this.willReopen();
    reopen.apply(this.PrototypeMixin, arguments);
    return this;
   },
   reopenClass:function() {
    reopen.apply(this.ClassMixin, arguments);
    applyMixin(this, arguments, false);
    return this;
   },
   detect:function(obj) {
    if ("function" !== typeof obj) {
     return false;
    }
    while (obj) {
     if (obj === this) {
      return true;
     }
     obj = obj.superclass;
    }
    return false;
   },
   detectInstance:function(obj) {
    return obj instanceof this;
   },
   metaForProperty:function(key) {
    var meta = this.proto()[META_KEY], desc = meta && meta.descs[key];
    return desc._meta || {};
   },
   eachComputedProperty:function(callback, binding) {
    var proto = this.proto(), descs = meta(proto).descs, empty = {}, property;
    for (var name in descs) {
     property = descs[name];
     if (property instanceof Ember.ComputedProperty) {
      callback.call(binding || this, name, property._meta || empty);
     }
    }
   }
  });
  ClassMixin.ownerConstructor = CoreObject;
  if (Ember.config.overrideClassMixin) {
   Ember.config.overrideClassMixin(ClassMixin);
  }
  CoreObject.ClassMixin = ClassMixin;
  ClassMixin.apply(CoreObject);
  Ember.CoreObject = CoreObject;
 })();
 (function() {
  Ember.Object = Ember.CoreObject.extend(Ember.Observable);
  Ember.Object.toString = function() {
   return "Ember.Object";
  };
 })();
 (function() {
  var get = Ember.get, indexOf = Ember.ArrayPolyfills.indexOf;
  var Namespace = Ember.Namespace = Ember.Object.extend({
   isNamespace:true,
   init:function() {
    Ember.Namespace.NAMESPACES.push(this);
    Ember.Namespace.PROCESSED = false;
   },
   toString:function() {
    var name = get(this, "name");
    if (name) {
     return name;
    }
    findNamespaces();
    return this[Ember.GUID_KEY + "_name"];
   },
   nameClasses:function() {
    processNamespace([ this.toString() ], this, {});
   },
   destroy:function() {
    var namespaces = Ember.Namespace.NAMESPACES;
    Ember.lookup[this.toString()] = undefined;
    namespaces.splice(indexOf.call(namespaces, this), 1);
    this._super();
   }
  });
  Namespace.reopenClass({
   NAMESPACES:[ Ember ],
   NAMESPACES_BY_ID:{},
   PROCESSED:false,
   processAll:processAllNamespaces,
   byName:function(name) {
    if (!Ember.BOOTED) {
     processAllNamespaces();
    }
    return NAMESPACES_BY_ID[name];
   }
  });
  var NAMESPACES_BY_ID = Namespace.NAMESPACES_BY_ID;
  var hasOwnProp = {}.hasOwnProperty, guidFor = Ember.guidFor;
  function processNamespace(paths, root, seen) {
   var idx = paths.length;
   NAMESPACES_BY_ID[paths.join(".")] = root;
   for (var key in root) {
    if (!hasOwnProp.call(root, key)) {
     continue;
    }
    var obj = root[key];
    paths[idx] = key;
    if (obj && obj.toString === classToString) {
     obj.toString = makeToString(paths.join("."));
     obj[NAME_KEY] = paths.join(".");
    } else if (obj && obj.isNamespace) {
     if (seen[guidFor(obj)]) {
      continue;
     }
     seen[guidFor(obj)] = true;
     processNamespace(paths, obj, seen);
    }
   }
   paths.length = idx;
  }
  function findNamespaces() {
   var Namespace = Ember.Namespace, lookup = Ember.lookup, obj, isNamespace;
   if (Namespace.PROCESSED) {
    return;
   }
   for (var prop in lookup) {
    if (prop === "parent" || prop === "top" || prop === "frameElement" || prop === "webkitStorageInfo") {
     continue;
    }
    if (prop === "globalStorage" && lookup.StorageList && lookup.globalStorage instanceof lookup.StorageList) {
     continue;
    }
    if (lookup.hasOwnProperty && !lookup.hasOwnProperty(prop)) {
     continue;
    }
    try {
     obj = Ember.lookup[prop];
     isNamespace = obj && obj.isNamespace;
    } catch (e) {
     continue;
    }
    if (isNamespace) {
     obj[NAME_KEY] = prop;
    }
   }
  }
  var NAME_KEY = Ember.NAME_KEY = Ember.GUID_KEY + "_name";
  function superClassString(mixin) {
   var superclass = mixin.superclass;
   if (superclass) {
    if (superclass[NAME_KEY]) {
     return superclass[NAME_KEY];
    } else {
     return superClassString(superclass);
    }
   } else {
    return;
   }
  }
  function classToString() {
   if (!Ember.BOOTED && !this[NAME_KEY]) {
    processAllNamespaces();
   }
   var ret;
   if (this[NAME_KEY]) {
    ret = this[NAME_KEY];
   } else if (this._toString) {
    ret = this._toString;
   } else {
    var str = superClassString(this);
    if (str) {
     ret = "(subclass of " + str + ")";
    } else {
     ret = "(unknown mixin)";
    }
    this.toString = makeToString(ret);
   }
   return ret;
  }
  function processAllNamespaces() {
   var unprocessedNamespaces = !Namespace.PROCESSED, unprocessedMixins = Ember.anyUnprocessedMixins;
   if (unprocessedNamespaces) {
    findNamespaces();
    Namespace.PROCESSED = true;
   }
   if (unprocessedNamespaces || unprocessedMixins) {
    var namespaces = Namespace.NAMESPACES, namespace;
    for (var i = 0, l = namespaces.length; i < l; i++) {
     namespace = namespaces[i];
     processNamespace([ namespace.toString() ], namespace, {});
    }
    Ember.anyUnprocessedMixins = false;
   }
  }
  function makeToString(ret) {
   return function() {
    return ret;
   };
  }
  Ember.Mixin.prototype.toString = classToString;
 })();
 (function() {
  var get = Ember.get, set = Ember.set, fmt = Ember.String.fmt, addBeforeObserver = Ember.addBeforeObserver, addObserver = Ember.addObserver, removeBeforeObserver = Ember.removeBeforeObserver, removeObserver = Ember.removeObserver, propertyWillChange = Ember.propertyWillChange, propertyDidChange = Ember.propertyDidChange, meta = Ember.meta, defineProperty = Ember.defineProperty;
  function contentPropertyWillChange(content, contentKey) {
   var key = contentKey.slice(8);
   if (key in this) {
    return;
   }
   propertyWillChange(this, key);
  }
  function contentPropertyDidChange(content, contentKey) {
   var key = contentKey.slice(8);
   if (key in this) {
    return;
   }
   propertyDidChange(this, key);
  }
  Ember.ObjectProxy = Ember.Object.extend({
   content:null,
   _contentDidChange:Ember.observer("content", function() {}),
   isTruthy:Ember.computed.bool("content"),
   _debugContainerKey:null,
   willWatchProperty:function(key) {
    var contentKey = "content." + key;
    addBeforeObserver(this, contentKey, null, contentPropertyWillChange);
    addObserver(this, contentKey, null, contentPropertyDidChange);
   },
   didUnwatchProperty:function(key) {
    var contentKey = "content." + key;
    removeBeforeObserver(this, contentKey, null, contentPropertyWillChange);
    removeObserver(this, contentKey, null, contentPropertyDidChange);
   },
   unknownProperty:function(key) {
    var content = get(this, "content");
    if (content) {
     return get(content, key);
    }
   },
   setUnknownProperty:function(key, value) {
    var m = meta(this);
    if (m.proto === this) {
     defineProperty(this, key, null, value);
     return value;
    }
    var content = get(this, "content");
    return set(content, key, value);
   }
  });
 })();
 (function() {
  var get = Ember.get, set = Ember.set;
  var a_slice = Array.prototype.slice;
  var a_indexOf = Ember.EnumerableUtils.indexOf;
  var contexts = [];
  function popCtx() {
   return contexts.length === 0 ? {} :contexts.pop();
  }
  function pushCtx(ctx) {
   contexts.push(ctx);
   return null;
  }
  function iter(key, value) {
   var valueProvided = arguments.length === 2;
   function i(item) {
    var cur = get(item, key);
    return valueProvided ? value === cur :!!cur;
   }
   return i;
  }
  Ember.Enumerable = Ember.Mixin.create({
   nextObject:Ember.required(Function),
   firstObject:Ember.computed(function() {
    if (get(this, "length") === 0) return undefined;
    var context = popCtx(), ret;
    ret = this.nextObject(0, null, context);
    pushCtx(context);
    return ret;
   }).property("[]"),
   lastObject:Ember.computed(function() {
    var len = get(this, "length");
    if (len === 0) return undefined;
    var context = popCtx(), idx = 0, cur, last = null;
    do {
     last = cur;
     cur = this.nextObject(idx++, last, context);
    } while (cur !== undefined);
    pushCtx(context);
    return last;
   }).property("[]"),
   contains:function(obj) {
    return this.find(function(item) {
     return item === obj;
    }) !== undefined;
   },
   forEach:function(callback, target) {
    if (typeof callback !== "function") throw new TypeError();
    var len = get(this, "length"), last = null, context = popCtx();
    if (target === undefined) target = null;
    for (var idx = 0; idx < len; idx++) {
     var next = this.nextObject(idx, last, context);
     callback.call(target, next, idx, this);
     last = next;
    }
    last = null;
    context = pushCtx(context);
    return this;
   },
   getEach:function(key) {
    return this.mapBy(key);
   },
   setEach:function(key, value) {
    return this.forEach(function(item) {
     set(item, key, value);
    });
   },
   map:function(callback, target) {
    var ret = Ember.A();
    this.forEach(function(x, idx, i) {
     ret[idx] = callback.call(target, x, idx, i);
    });
    return ret;
   },
   mapBy:function(key) {
    return this.map(function(next) {
     return get(next, key);
    });
   },
   mapProperty:Ember.aliasMethod("mapBy"),
   filter:function(callback, target) {
    var ret = Ember.A();
    this.forEach(function(x, idx, i) {
     if (callback.call(target, x, idx, i)) ret.push(x);
    });
    return ret;
   },
   reject:function(callback, target) {
    return this.filter(function() {
     return !callback.apply(target, arguments);
    });
   },
   filterBy:function(key, value) {
    return this.filter(iter.apply(this, arguments));
   },
   filterProperty:Ember.aliasMethod("filterBy"),
   rejectBy:function(key, value) {
    var exactValue = function(item) {
     return get(item, key) === value;
    }, hasValue = function(item) {
     return !!get(item, key);
    }, use = arguments.length === 2 ? exactValue :hasValue;
    return this.reject(use);
   },
   rejectProperty:Ember.aliasMethod("rejectBy"),
   find:function(callback, target) {
    var len = get(this, "length");
    if (target === undefined) target = null;
    var last = null, next, found = false, ret;
    var context = popCtx();
    for (var idx = 0; idx < len && !found; idx++) {
     next = this.nextObject(idx, last, context);
     if (found = callback.call(target, next, idx, this)) ret = next;
     last = next;
    }
    next = last = null;
    context = pushCtx(context);
    return ret;
   },
   findBy:function(key, value) {
    return this.find(iter.apply(this, arguments));
   },
   findProperty:Ember.aliasMethod("findBy"),
   every:function(callback, target) {
    return !this.find(function(x, idx, i) {
     return !callback.call(target, x, idx, i);
    });
   },
   everyBy:Ember.aliasMethod("isEvery"),
   everyProperty:Ember.aliasMethod("isEvery"),
   isEvery:function(key, value) {
    return this.every(iter.apply(this, arguments));
   },
   any:function(callback, target) {
    var found = this.find(function(x, idx, i) {
     return !!callback.call(target, x, idx, i);
    });
    return typeof found !== "undefined";
   },
   some:Ember.aliasMethod("any"),
   isAny:function(key, value) {
    return this.any(iter.apply(this, arguments));
   },
   anyBy:Ember.aliasMethod("isAny"),
   someProperty:Ember.aliasMethod("isAny"),
   reduce:function(callback, initialValue, reducerProperty) {
    if (typeof callback !== "function") {
     throw new TypeError();
    }
    var ret = initialValue;
    this.forEach(function(item, i) {
     ret = callback(ret, item, i, this, reducerProperty);
    }, this);
    return ret;
   },
   invoke:function(methodName) {
    var args, ret = Ember.A();
    if (arguments.length > 1) args = a_slice.call(arguments, 1);
    this.forEach(function(x, idx) {
     var method = x && x[methodName];
     if ("function" === typeof method) {
      ret[idx] = args ? method.apply(x, args) :x[methodName]();
     }
    }, this);
    return ret;
   },
   toArray:function() {
    var ret = Ember.A();
    this.forEach(function(o, idx) {
     ret[idx] = o;
    });
    return ret;
   },
   compact:function() {
    return this.filter(function(value) {
     return value != null;
    });
   },
   without:function(value) {
    if (!this.contains(value)) return this;
    var ret = Ember.A();
    this.forEach(function(k) {
     if (k !== value) ret[ret.length] = k;
    });
    return ret;
   },
   uniq:function() {
    var ret = Ember.A();
    this.forEach(function(k) {
     if (a_indexOf(ret, k) < 0) ret.push(k);
    });
    return ret;
   },
   "[]":Ember.computed(function(key, value) {
    return this;
   }),
   addEnumerableObserver:function(target, opts) {
    var willChange = opts && opts.willChange || "enumerableWillChange", didChange = opts && opts.didChange || "enumerableDidChange";
    var hasObservers = get(this, "hasEnumerableObservers");
    if (!hasObservers) Ember.propertyWillChange(this, "hasEnumerableObservers");
    Ember.addListener(this, "@enumerable:before", target, willChange);
    Ember.addListener(this, "@enumerable:change", target, didChange);
    if (!hasObservers) Ember.propertyDidChange(this, "hasEnumerableObservers");
    return this;
   },
   removeEnumerableObserver:function(target, opts) {
    var willChange = opts && opts.willChange || "enumerableWillChange", didChange = opts && opts.didChange || "enumerableDidChange";
    var hasObservers = get(this, "hasEnumerableObservers");
    if (hasObservers) Ember.propertyWillChange(this, "hasEnumerableObservers");
    Ember.removeListener(this, "@enumerable:before", target, willChange);
    Ember.removeListener(this, "@enumerable:change", target, didChange);
    if (hasObservers) Ember.propertyDidChange(this, "hasEnumerableObservers");
    return this;
   },
   hasEnumerableObservers:Ember.computed(function() {
    return Ember.hasListeners(this, "@enumerable:change") || Ember.hasListeners(this, "@enumerable:before");
   }),
   enumerableContentWillChange:function(removing, adding) {
    var removeCnt, addCnt, hasDelta;
    if ("number" === typeof removing) removeCnt = removing; else if (removing) removeCnt = get(removing, "length"); else removeCnt = removing = -1;
    if ("number" === typeof adding) addCnt = adding; else if (adding) addCnt = get(adding, "length"); else addCnt = adding = -1;
    hasDelta = addCnt < 0 || removeCnt < 0 || addCnt - removeCnt !== 0;
    if (removing === -1) removing = null;
    if (adding === -1) adding = null;
    Ember.propertyWillChange(this, "[]");
    if (hasDelta) Ember.propertyWillChange(this, "length");
    Ember.sendEvent(this, "@enumerable:before", [ this, removing, adding ]);
    return this;
   },
   enumerableContentDidChange:function(removing, adding) {
    var removeCnt, addCnt, hasDelta;
    if ("number" === typeof removing) removeCnt = removing; else if (removing) removeCnt = get(removing, "length"); else removeCnt = removing = -1;
    if ("number" === typeof adding) addCnt = adding; else if (adding) addCnt = get(adding, "length"); else addCnt = adding = -1;
    hasDelta = addCnt < 0 || removeCnt < 0 || addCnt - removeCnt !== 0;
    if (removing === -1) removing = null;
    if (adding === -1) adding = null;
    Ember.sendEvent(this, "@enumerable:change", [ this, removing, adding ]);
    if (hasDelta) Ember.propertyDidChange(this, "length");
    Ember.propertyDidChange(this, "[]");
    return this;
   },
   sortBy:function() {
    var sortKeys = arguments;
    return this.toArray().sort(function(a, b) {
     for (var i = 0; i < sortKeys.length; i++) {
      var key = sortKeys[i], propA = get(a, key), propB = get(b, key);
      var compareValue = Ember.compare(propA, propB);
      if (compareValue) {
       return compareValue;
      }
     }
     return 0;
    });
   }
  });
 })();
 (function() {
  var get = Ember.get, set = Ember.set, isNone = Ember.isNone, map = Ember.EnumerableUtils.map, cacheFor = Ember.cacheFor;
  Ember.Array = Ember.Mixin.create(Ember.Enumerable, {
   length:Ember.required(),
   objectAt:function(idx) {
    if (idx < 0 || idx >= get(this, "length")) return undefined;
    return get(this, idx);
   },
   objectsAt:function(indexes) {
    var self = this;
    return map(indexes, function(idx) {
     return self.objectAt(idx);
    });
   },
   nextObject:function(idx) {
    return this.objectAt(idx);
   },
   "[]":Ember.computed(function(key, value) {
    if (value !== undefined) this.replace(0, get(this, "length"), value);
    return this;
   }),
   firstObject:Ember.computed(function() {
    return this.objectAt(0);
   }),
   lastObject:Ember.computed(function() {
    return this.objectAt(get(this, "length") - 1);
   }),
   contains:function(obj) {
    return this.indexOf(obj) >= 0;
   },
   slice:function(beginIndex, endIndex) {
    var ret = Ember.A();
    var length = get(this, "length");
    if (isNone(beginIndex)) beginIndex = 0;
    if (isNone(endIndex) || endIndex > length) endIndex = length;
    if (beginIndex < 0) beginIndex = length + beginIndex;
    if (endIndex < 0) endIndex = length + endIndex;
    while (beginIndex < endIndex) {
     ret[ret.length] = this.objectAt(beginIndex++);
    }
    return ret;
   },
   indexOf:function(object, startAt) {
    var idx, len = get(this, "length");
    if (startAt === undefined) startAt = 0;
    if (startAt < 0) startAt += len;
    for (idx = startAt; idx < len; idx++) {
     if (this.objectAt(idx) === object) return idx;
    }
    return -1;
   },
   lastIndexOf:function(object, startAt) {
    var idx, len = get(this, "length");
    if (startAt === undefined || startAt >= len) startAt = len - 1;
    if (startAt < 0) startAt += len;
    for (idx = startAt; idx >= 0; idx--) {
     if (this.objectAt(idx) === object) return idx;
    }
    return -1;
   },
   addArrayObserver:function(target, opts) {
    var willChange = opts && opts.willChange || "arrayWillChange", didChange = opts && opts.didChange || "arrayDidChange";
    var hasObservers = get(this, "hasArrayObservers");
    if (!hasObservers) Ember.propertyWillChange(this, "hasArrayObservers");
    Ember.addListener(this, "@array:before", target, willChange);
    Ember.addListener(this, "@array:change", target, didChange);
    if (!hasObservers) Ember.propertyDidChange(this, "hasArrayObservers");
    return this;
   },
   removeArrayObserver:function(target, opts) {
    var willChange = opts && opts.willChange || "arrayWillChange", didChange = opts && opts.didChange || "arrayDidChange";
    var hasObservers = get(this, "hasArrayObservers");
    if (hasObservers) Ember.propertyWillChange(this, "hasArrayObservers");
    Ember.removeListener(this, "@array:before", target, willChange);
    Ember.removeListener(this, "@array:change", target, didChange);
    if (hasObservers) Ember.propertyDidChange(this, "hasArrayObservers");
    return this;
   },
   hasArrayObservers:Ember.computed(function() {
    return Ember.hasListeners(this, "@array:change") || Ember.hasListeners(this, "@array:before");
   }),
   arrayContentWillChange:function(startIdx, removeAmt, addAmt) {
    if (startIdx === undefined) {
     startIdx = 0;
     removeAmt = addAmt = -1;
    } else {
     if (removeAmt === undefined) removeAmt = -1;
     if (addAmt === undefined) addAmt = -1;
    }
    if (Ember.isWatching(this, "@each")) {
     get(this, "@each");
    }
    Ember.sendEvent(this, "@array:before", [ this, startIdx, removeAmt, addAmt ]);
    var removing, lim;
    if (startIdx >= 0 && removeAmt >= 0 && get(this, "hasEnumerableObservers")) {
     removing = [];
     lim = startIdx + removeAmt;
     for (var idx = startIdx; idx < lim; idx++) removing.push(this.objectAt(idx));
    } else {
     removing = removeAmt;
    }
    this.enumerableContentWillChange(removing, addAmt);
    return this;
   },
   arrayContentDidChange:function(startIdx, removeAmt, addAmt) {
    if (startIdx === undefined) {
     startIdx = 0;
     removeAmt = addAmt = -1;
    } else {
     if (removeAmt === undefined) removeAmt = -1;
     if (addAmt === undefined) addAmt = -1;
    }
    var adding, lim;
    if (startIdx >= 0 && addAmt >= 0 && get(this, "hasEnumerableObservers")) {
     adding = [];
     lim = startIdx + addAmt;
     for (var idx = startIdx; idx < lim; idx++) adding.push(this.objectAt(idx));
    } else {
     adding = addAmt;
    }
    this.enumerableContentDidChange(removeAmt, adding);
    Ember.sendEvent(this, "@array:change", [ this, startIdx, removeAmt, addAmt ]);
    var length = get(this, "length"), cachedFirst = cacheFor(this, "firstObject"), cachedLast = cacheFor(this, "lastObject");
    if (this.objectAt(0) !== cachedFirst) {
     Ember.propertyWillChange(this, "firstObject");
     Ember.propertyDidChange(this, "firstObject");
    }
    if (this.objectAt(length - 1) !== cachedLast) {
     Ember.propertyWillChange(this, "lastObject");
     Ember.propertyDidChange(this, "lastObject");
    }
    return this;
   },
   "@each":Ember.computed(function() {
    if (!this.__each) this.__each = new Ember.EachProxy(this);
    return this.__each;
   })
  });
 })();
 (function() {
  var e_get = Ember.get, set = Ember.set, guidFor = Ember.guidFor, metaFor = Ember.meta, propertyWillChange = Ember.propertyWillChange, propertyDidChange = Ember.propertyDidChange, addBeforeObserver = Ember.addBeforeObserver, removeBeforeObserver = Ember.removeBeforeObserver, addObserver = Ember.addObserver, removeObserver = Ember.removeObserver, ComputedProperty = Ember.ComputedProperty, a_slice = [].slice, o_create = Ember.create, forEach = Ember.EnumerableUtils.forEach, eachPropertyPattern = /^(.*)\.@each\.(.*)/, doubleEachPropertyPattern = /(.*\.@each){2,}/, arrayBracketPattern = /\.\[\]$/;
  var expandProperties = Ember.expandProperties;
  function get(obj, key) {
   if (key === "@this") {
    return obj;
   }
   return e_get(obj, key);
  }
  function DependentArraysObserver(callbacks, cp, instanceMeta, context, propertyName, sugarMeta) {
   this.callbacks = callbacks;
   this.cp = cp;
   this.instanceMeta = instanceMeta;
   this.dependentKeysByGuid = {};
   this.trackedArraysByGuid = {};
   this.suspended = false;
   this.changedItems = {};
  }
  function ItemPropertyObserverContext(dependentArray, index, trackedArray) {
   this.dependentArray = dependentArray;
   this.index = index;
   this.item = dependentArray.objectAt(index);
   this.trackedArray = trackedArray;
   this.beforeObserver = null;
   this.observer = null;
   this.destroyed = false;
  }
  DependentArraysObserver.prototype = {
   setValue:function(newValue) {
    this.instanceMeta.setValue(newValue, true);
   },
   getValue:function() {
    return this.instanceMeta.getValue();
   },
   setupObservers:function(dependentArray, dependentKey) {
    this.dependentKeysByGuid[guidFor(dependentArray)] = dependentKey;
    dependentArray.addArrayObserver(this, {
     willChange:"dependentArrayWillChange",
     didChange:"dependentArrayDidChange"
    });
    if (this.cp._itemPropertyKeys[dependentKey]) {
     this.setupPropertyObservers(dependentKey, this.cp._itemPropertyKeys[dependentKey]);
    }
   },
   teardownObservers:function(dependentArray, dependentKey) {
    var itemPropertyKeys = this.cp._itemPropertyKeys[dependentKey] || [];
    delete this.dependentKeysByGuid[guidFor(dependentArray)];
    this.teardownPropertyObservers(dependentKey, itemPropertyKeys);
    dependentArray.removeArrayObserver(this, {
     willChange:"dependentArrayWillChange",
     didChange:"dependentArrayDidChange"
    });
   },
   suspendArrayObservers:function(callback, binding) {
    var oldSuspended = this.suspended;
    this.suspended = true;
    callback.call(binding);
    this.suspended = oldSuspended;
   },
   setupPropertyObservers:function(dependentKey, itemPropertyKeys) {
    var dependentArray = get(this.instanceMeta.context, dependentKey), length = get(dependentArray, "length"), observerContexts = new Array(length);
    this.resetTransformations(dependentKey, observerContexts);
    forEach(dependentArray, function(item, index) {
     var observerContext = this.createPropertyObserverContext(dependentArray, index, this.trackedArraysByGuid[dependentKey]);
     observerContexts[index] = observerContext;
     forEach(itemPropertyKeys, function(propertyKey) {
      addBeforeObserver(item, propertyKey, this, observerContext.beforeObserver);
      addObserver(item, propertyKey, this, observerContext.observer);
     }, this);
    }, this);
   },
   teardownPropertyObservers:function(dependentKey, itemPropertyKeys) {
    var dependentArrayObserver = this, trackedArray = this.trackedArraysByGuid[dependentKey], beforeObserver, observer, item;
    if (!trackedArray) {
     return;
    }
    trackedArray.apply(function(observerContexts, offset, operation) {
     if (operation === Ember.TrackedArray.DELETE) {
      return;
     }
     forEach(observerContexts, function(observerContext) {
      observerContext.destroyed = true;
      beforeObserver = observerContext.beforeObserver;
      observer = observerContext.observer;
      item = observerContext.item;
      forEach(itemPropertyKeys, function(propertyKey) {
       removeBeforeObserver(item, propertyKey, dependentArrayObserver, beforeObserver);
       removeObserver(item, propertyKey, dependentArrayObserver, observer);
      });
     });
    });
   },
   createPropertyObserverContext:function(dependentArray, index, trackedArray) {
    var observerContext = new ItemPropertyObserverContext(dependentArray, index, trackedArray);
    this.createPropertyObserver(observerContext);
    return observerContext;
   },
   createPropertyObserver:function(observerContext) {
    var dependentArrayObserver = this;
    observerContext.beforeObserver = function(obj, keyName) {
     return dependentArrayObserver.itemPropertyWillChange(obj, keyName, observerContext.dependentArray, observerContext);
    };
    observerContext.observer = function(obj, keyName) {
     return dependentArrayObserver.itemPropertyDidChange(obj, keyName, observerContext.dependentArray, observerContext);
    };
   },
   resetTransformations:function(dependentKey, observerContexts) {
    this.trackedArraysByGuid[dependentKey] = new Ember.TrackedArray(observerContexts);
   },
   trackAdd:function(dependentKey, index, newItems) {
    var trackedArray = this.trackedArraysByGuid[dependentKey];
    if (trackedArray) {
     trackedArray.addItems(index, newItems);
    }
   },
   trackRemove:function(dependentKey, index, removedCount) {
    var trackedArray = this.trackedArraysByGuid[dependentKey];
    if (trackedArray) {
     return trackedArray.removeItems(index, removedCount);
    }
    return [];
   },
   updateIndexes:function(trackedArray, array) {
    var length = get(array, "length");
    trackedArray.apply(function(observerContexts, offset, operation) {
     if (operation === Ember.TrackedArray.DELETE) {
      return;
     }
     if (operation === Ember.TrackedArray.RETAIN && observerContexts.length === length && offset === 0) {
      return;
     }
     forEach(observerContexts, function(context, index) {
      context.index = index + offset;
     });
    });
   },
   dependentArrayWillChange:function(dependentArray, index, removedCount, addedCount) {
    if (this.suspended) {
     return;
    }
    var removedItem = this.callbacks.removedItem, changeMeta, guid = guidFor(dependentArray), dependentKey = this.dependentKeysByGuid[guid], itemPropertyKeys = this.cp._itemPropertyKeys[dependentKey] || [], length = get(dependentArray, "length"), normalizedIndex = normalizeIndex(index, length, 0), normalizedRemoveCount = normalizeRemoveCount(normalizedIndex, length, removedCount), item, itemIndex, sliceIndex, observerContexts;
    observerContexts = this.trackRemove(dependentKey, normalizedIndex, normalizedRemoveCount);
    function removeObservers(propertyKey) {
     observerContexts[sliceIndex].destroyed = true;
     removeBeforeObserver(item, propertyKey, this, observerContexts[sliceIndex].beforeObserver);
     removeObserver(item, propertyKey, this, observerContexts[sliceIndex].observer);
    }
    for (sliceIndex = normalizedRemoveCount - 1; sliceIndex >= 0; --sliceIndex) {
     itemIndex = normalizedIndex + sliceIndex;
     if (itemIndex >= length) {
      break;
     }
     item = dependentArray.objectAt(itemIndex);
     forEach(itemPropertyKeys, removeObservers, this);
     changeMeta = createChangeMeta(dependentArray, item, itemIndex, this.instanceMeta.propertyName, this.cp);
     this.setValue(removedItem.call(this.instanceMeta.context, this.getValue(), item, changeMeta, this.instanceMeta.sugarMeta));
    }
   },
   dependentArrayDidChange:function(dependentArray, index, removedCount, addedCount) {
    if (this.suspended) {
     return;
    }
    var addedItem = this.callbacks.addedItem, guid = guidFor(dependentArray), dependentKey = this.dependentKeysByGuid[guid], observerContexts = new Array(addedCount), itemPropertyKeys = this.cp._itemPropertyKeys[dependentKey], length = get(dependentArray, "length"), normalizedIndex = normalizeIndex(index, length, addedCount), changeMeta, observerContext;
    forEach(dependentArray.slice(normalizedIndex, normalizedIndex + addedCount), function(item, sliceIndex) {
     if (itemPropertyKeys) {
      observerContext = observerContexts[sliceIndex] = this.createPropertyObserverContext(dependentArray, normalizedIndex + sliceIndex, this.trackedArraysByGuid[dependentKey]);
      forEach(itemPropertyKeys, function(propertyKey) {
       addBeforeObserver(item, propertyKey, this, observerContext.beforeObserver);
       addObserver(item, propertyKey, this, observerContext.observer);
      }, this);
     }
     changeMeta = createChangeMeta(dependentArray, item, normalizedIndex + sliceIndex, this.instanceMeta.propertyName, this.cp);
     this.setValue(addedItem.call(this.instanceMeta.context, this.getValue(), item, changeMeta, this.instanceMeta.sugarMeta));
    }, this);
    this.trackAdd(dependentKey, normalizedIndex, observerContexts);
   },
   itemPropertyWillChange:function(obj, keyName, array, observerContext) {
    var guid = guidFor(obj);
    if (!this.changedItems[guid]) {
     this.changedItems[guid] = {
      array:array,
      observerContext:observerContext,
      obj:obj,
      previousValues:{}
     };
    }
    this.changedItems[guid].previousValues[keyName] = get(obj, keyName);
   },
   itemPropertyDidChange:function(obj, keyName, array, observerContext) {
    this.flushChanges();
   },
   flushChanges:function() {
    var changedItems = this.changedItems, key, c, changeMeta;
    for (key in changedItems) {
     c = changedItems[key];
     if (c.observerContext.destroyed) {
      continue;
     }
     this.updateIndexes(c.observerContext.trackedArray, c.observerContext.dependentArray);
     changeMeta = createChangeMeta(c.array, c.obj, c.observerContext.index, this.instanceMeta.propertyName, this.cp, c.previousValues);
     this.setValue(this.callbacks.removedItem.call(this.instanceMeta.context, this.getValue(), c.obj, changeMeta, this.instanceMeta.sugarMeta));
     this.setValue(this.callbacks.addedItem.call(this.instanceMeta.context, this.getValue(), c.obj, changeMeta, this.instanceMeta.sugarMeta));
    }
    this.changedItems = {};
   }
  };
  function normalizeIndex(index, length, newItemsOffset) {
   if (index < 0) {
    return Math.max(0, length + index);
   } else if (index < length) {
    return index;
   } else {
    return Math.min(length - newItemsOffset, index);
   }
  }
  function normalizeRemoveCount(index, length, removedCount) {
   return Math.min(removedCount, length - index);
  }
  function createChangeMeta(dependentArray, item, index, propertyName, property, previousValues) {
   var meta = {
    arrayChanged:dependentArray,
    index:index,
    item:item,
    propertyName:propertyName,
    property:property
   };
   if (previousValues) {
    meta.previousValues = previousValues;
   }
   return meta;
  }
  function addItems(dependentArray, callbacks, cp, propertyName, meta) {
   forEach(dependentArray, function(item, index) {
    meta.setValue(callbacks.addedItem.call(this, meta.getValue(), item, createChangeMeta(dependentArray, item, index, propertyName, cp), meta.sugarMeta));
   }, this);
  }
  function reset(cp, propertyName) {
   var callbacks = cp._callbacks(), meta;
   if (cp._hasInstanceMeta(this, propertyName)) {
    meta = cp._instanceMeta(this, propertyName);
    meta.setValue(cp.resetValue(meta.getValue()));
   } else {
    meta = cp._instanceMeta(this, propertyName);
   }
   if (cp.options.initialize) {
    cp.options.initialize.call(this, meta.getValue(), {
     property:cp,
     propertyName:propertyName
    }, meta.sugarMeta);
   }
  }
  function partiallyRecomputeFor(obj, dependentKey) {
   if (arrayBracketPattern.test(dependentKey)) {
    return false;
   }
   var value = get(obj, dependentKey);
   return Ember.Array.detect(value);
  }
  function ReduceComputedPropertyInstanceMeta(context, propertyName, initialValue) {
   this.context = context;
   this.propertyName = propertyName;
   this.cache = metaFor(context).cache;
   this.dependentArrays = {};
   this.sugarMeta = {};
   this.initialValue = initialValue;
  }
  ReduceComputedPropertyInstanceMeta.prototype = {
   getValue:function() {
    if (this.propertyName in this.cache) {
     return this.cache[this.propertyName];
    } else {
     return this.initialValue;
    }
   },
   setValue:function(newValue, triggerObservers) {
    if (newValue !== undefined) {
     var fireObservers = triggerObservers && newValue !== this.cache[this.propertyName];
     if (fireObservers) {
      propertyWillChange(this.context, this.propertyName);
     }
     this.cache[this.propertyName] = newValue;
     if (fireObservers) {
      propertyDidChange(this.context, this.propertyName);
     }
    } else {
     delete this.cache[this.propertyName];
    }
   }
  };
  function ReduceComputedProperty(options) {
   var cp = this;
   this.options = options;
   this._instanceMetas = {};
   this._dependentKeys = null;
   this._itemPropertyKeys = {};
   this._previousItemPropertyKeys = {};
   this.readOnly();
   this.cacheable();
   this.recomputeOnce = function(propertyName) {
    Ember.run.once(this, recompute, propertyName);
   };
   var recompute = function(propertyName) {
    var dependentKeys = cp._dependentKeys, meta = cp._instanceMeta(this, propertyName), callbacks = cp._callbacks();
    reset.call(this, cp, propertyName);
    meta.dependentArraysObserver.suspendArrayObservers(function() {
     forEach(cp._dependentKeys, function(dependentKey) {
      if (!partiallyRecomputeFor(this, dependentKey)) {
       return;
      }
      var dependentArray = get(this, dependentKey), previousDependentArray = meta.dependentArrays[dependentKey];
      if (dependentArray === previousDependentArray) {
       if (cp._previousItemPropertyKeys[dependentKey]) {
        delete cp._previousItemPropertyKeys[dependentKey];
        meta.dependentArraysObserver.setupPropertyObservers(dependentKey, cp._itemPropertyKeys[dependentKey]);
       }
      } else {
       meta.dependentArrays[dependentKey] = dependentArray;
       if (previousDependentArray) {
        meta.dependentArraysObserver.teardownObservers(previousDependentArray, dependentKey);
       }
       if (dependentArray) {
        meta.dependentArraysObserver.setupObservers(dependentArray, dependentKey);
       }
      }
     }, this);
    }, this);
    forEach(cp._dependentKeys, function(dependentKey) {
     if (!partiallyRecomputeFor(this, dependentKey)) {
      return;
     }
     var dependentArray = get(this, dependentKey);
     if (dependentArray) {
      addItems.call(this, dependentArray, callbacks, cp, propertyName, meta);
     }
    }, this);
   };
   this.func = function(propertyName) {
    recompute.call(this, propertyName);
    return cp._instanceMeta(this, propertyName).getValue();
   };
  }
  Ember.ReduceComputedProperty = ReduceComputedProperty;
  ReduceComputedProperty.prototype = o_create(ComputedProperty.prototype);
  function defaultCallback(computedValue) {
   return computedValue;
  }
  ReduceComputedProperty.prototype._callbacks = function() {
   if (!this.callbacks) {
    var options = this.options;
    this.callbacks = {
     removedItem:options.removedItem || defaultCallback,
     addedItem:options.addedItem || defaultCallback
    };
   }
   return this.callbacks;
  };
  ReduceComputedProperty.prototype._hasInstanceMeta = function(context, propertyName) {
   var guid = guidFor(context), key = guid + ":" + propertyName;
   return !!this._instanceMetas[key];
  };
  ReduceComputedProperty.prototype._instanceMeta = function(context, propertyName) {
   var guid = guidFor(context), key = guid + ":" + propertyName, meta = this._instanceMetas[key];
   if (!meta) {
    meta = this._instanceMetas[key] = new ReduceComputedPropertyInstanceMeta(context, propertyName, this.initialValue());
    meta.dependentArraysObserver = new DependentArraysObserver(this._callbacks(), this, meta, context, propertyName, meta.sugarMeta);
   }
   return meta;
  };
  ReduceComputedProperty.prototype.initialValue = function() {
   if (typeof this.options.initialValue === "function") {
    return this.options.initialValue();
   } else {
    return this.options.initialValue;
   }
  };
  ReduceComputedProperty.prototype.resetValue = function(value) {
   return this.initialValue();
  };
  ReduceComputedProperty.prototype.itemPropertyKey = function(dependentArrayKey, itemPropertyKey) {
   this._itemPropertyKeys[dependentArrayKey] = this._itemPropertyKeys[dependentArrayKey] || [];
   this._itemPropertyKeys[dependentArrayKey].push(itemPropertyKey);
  };
  ReduceComputedProperty.prototype.clearItemPropertyKeys = function(dependentArrayKey) {
   if (this._itemPropertyKeys[dependentArrayKey]) {
    this._previousItemPropertyKeys[dependentArrayKey] = this._itemPropertyKeys[dependentArrayKey];
    this._itemPropertyKeys[dependentArrayKey] = [];
   }
  };
  ReduceComputedProperty.prototype.property = function() {
   var cp = this, args = a_slice.call(arguments), propertyArgs = new Ember.Set(), match, dependentArrayKey, itemPropertyKey;
   forEach(a_slice.call(arguments), function(dependentKey) {
    if (doubleEachPropertyPattern.test(dependentKey)) {
     throw new Ember.Error("Nested @each properties not supported: " + dependentKey);
    } else if (match = eachPropertyPattern.exec(dependentKey)) {
     dependentArrayKey = match[1];
     var itemPropertyKeyPattern = match[2], addItemPropertyKey = function(itemPropertyKey) {
      cp.itemPropertyKey(dependentArrayKey, itemPropertyKey);
     };
     expandProperties(itemPropertyKeyPattern, addItemPropertyKey);
     propertyArgs.add(dependentArrayKey);
    } else {
     propertyArgs.add(dependentKey);
    }
   });
   return ComputedProperty.prototype.property.apply(this, propertyArgs.toArray());
  };
  Ember.reduceComputed = function(options) {
   var args;
   if (arguments.length > 1) {
    args = a_slice.call(arguments, 0, -1);
    options = a_slice.call(arguments, -1)[0];
   }
   if (typeof options !== "object") {
    throw new Ember.Error("Reduce Computed Property declared without an options hash");
   }
   if (!("initialValue" in options)) {
    throw new Ember.Error("Reduce Computed Property declared without an initial value");
   }
   var cp = new ReduceComputedProperty(options);
   if (args) {
    cp.property.apply(cp, args);
   }
   return cp;
  };
 })();
 (function() {
  var ReduceComputedProperty = Ember.ReduceComputedProperty, a_slice = [].slice, o_create = Ember.create, forEach = Ember.EnumerableUtils.forEach;
  function ArrayComputedProperty() {
   var cp = this;
   ReduceComputedProperty.apply(this, arguments);
   this.func = function(reduceFunc) {
    return function(propertyName) {
     if (!cp._hasInstanceMeta(this, propertyName)) {
      forEach(cp._dependentKeys, function(dependentKey) {
       Ember.addObserver(this, dependentKey, function() {
        cp.recomputeOnce.call(this, propertyName);
       });
      }, this);
     }
     return reduceFunc.apply(this, arguments);
    };
   }(this.func);
   return this;
  }
  Ember.ArrayComputedProperty = ArrayComputedProperty;
  ArrayComputedProperty.prototype = o_create(ReduceComputedProperty.prototype);
  ArrayComputedProperty.prototype.initialValue = function() {
   return Ember.A();
  };
  ArrayComputedProperty.prototype.resetValue = function(array) {
   array.clear();
   return array;
  };
  ArrayComputedProperty.prototype.didChange = function(obj, keyName) {
   return;
  };
  Ember.arrayComputed = function(options) {
   var args;
   if (arguments.length > 1) {
    args = a_slice.call(arguments, 0, -1);
    options = a_slice.call(arguments, -1)[0];
   }
   if (typeof options !== "object") {
    throw new Ember.Error("Array Computed Property declared without an options hash");
   }
   var cp = new ArrayComputedProperty(options);
   if (args) {
    cp.property.apply(cp, args);
   }
   return cp;
  };
 })();
 (function() {
  var get = Ember.get, set = Ember.set, guidFor = Ember.guidFor, merge = Ember.merge, a_slice = [].slice, forEach = Ember.EnumerableUtils.forEach, map = Ember.EnumerableUtils.map, SearchProxy;
  Ember.computed.sum = function(dependentKey) {
   return Ember.reduceComputed(dependentKey, {
    initialValue:0,
    addedItem:function(accumulatedValue, item, changeMeta, instanceMeta) {
     return accumulatedValue + item;
    },
    removedItem:function(accumulatedValue, item, changeMeta, instanceMeta) {
     return accumulatedValue - item;
    }
   });
  };
  Ember.computed.max = function(dependentKey) {
   return Ember.reduceComputed(dependentKey, {
    initialValue:-Infinity,
    addedItem:function(accumulatedValue, item, changeMeta, instanceMeta) {
     return Math.max(accumulatedValue, item);
    },
    removedItem:function(accumulatedValue, item, changeMeta, instanceMeta) {
     if (item < accumulatedValue) {
      return accumulatedValue;
     }
    }
   });
  };
  Ember.computed.min = function(dependentKey) {
   return Ember.reduceComputed(dependentKey, {
    initialValue:Infinity,
    addedItem:function(accumulatedValue, item, changeMeta, instanceMeta) {
     return Math.min(accumulatedValue, item);
    },
    removedItem:function(accumulatedValue, item, changeMeta, instanceMeta) {
     if (item > accumulatedValue) {
      return accumulatedValue;
     }
    }
   });
  };
  Ember.computed.map = function(dependentKey, callback) {
   var options = {
    addedItem:function(array, item, changeMeta, instanceMeta) {
     var mapped = callback.call(this, item);
     array.insertAt(changeMeta.index, mapped);
     return array;
    },
    removedItem:function(array, item, changeMeta, instanceMeta) {
     array.removeAt(changeMeta.index, 1);
     return array;
    }
   };
   return Ember.arrayComputed(dependentKey, options);
  };
  Ember.computed.mapBy = function(dependentKey, propertyKey) {
   var callback = function(item) {
    return get(item, propertyKey);
   };
   return Ember.computed.map(dependentKey + ".@each." + propertyKey, callback);
  };
  Ember.computed.mapProperty = Ember.computed.mapBy;
  Ember.computed.filter = function(dependentKey, callback) {
   var options = {
    initialize:function(array, changeMeta, instanceMeta) {
     instanceMeta.filteredArrayIndexes = new Ember.SubArray();
    },
    addedItem:function(array, item, changeMeta, instanceMeta) {
     var match = !!callback.call(this, item), filterIndex = instanceMeta.filteredArrayIndexes.addItem(changeMeta.index, match);
     if (match) {
      array.insertAt(filterIndex, item);
     }
     return array;
    },
    removedItem:function(array, item, changeMeta, instanceMeta) {
     var filterIndex = instanceMeta.filteredArrayIndexes.removeItem(changeMeta.index);
     if (filterIndex > -1) {
      array.removeAt(filterIndex);
     }
     return array;
    }
   };
   return Ember.arrayComputed(dependentKey, options);
  };
  Ember.computed.filterBy = function(dependentKey, propertyKey, value) {
   var callback;
   if (arguments.length === 2) {
    callback = function(item) {
     return get(item, propertyKey);
    };
   } else {
    callback = function(item) {
     return get(item, propertyKey) === value;
    };
   }
   return Ember.computed.filter(dependentKey + ".@each." + propertyKey, callback);
  };
  Ember.computed.filterProperty = Ember.computed.filterBy;
  Ember.computed.uniq = function() {
   var args = a_slice.call(arguments);
   args.push({
    initialize:function(array, changeMeta, instanceMeta) {
     instanceMeta.itemCounts = {};
    },
    addedItem:function(array, item, changeMeta, instanceMeta) {
     var guid = guidFor(item);
     if (!instanceMeta.itemCounts[guid]) {
      instanceMeta.itemCounts[guid] = 1;
     } else {
      ++instanceMeta.itemCounts[guid];
     }
     array.addObject(item);
     return array;
    },
    removedItem:function(array, item, _, instanceMeta) {
     var guid = guidFor(item), itemCounts = instanceMeta.itemCounts;
     if (--itemCounts[guid] === 0) {
      array.removeObject(item);
     }
     return array;
    }
   });
   return Ember.arrayComputed.apply(null, args);
  };
  Ember.computed.union = Ember.computed.uniq;
  Ember.computed.intersect = function() {
   var getDependentKeyGuids = function(changeMeta) {
    return map(changeMeta.property._dependentKeys, function(dependentKey) {
     return guidFor(dependentKey);
    });
   };
   var args = a_slice.call(arguments);
   args.push({
    initialize:function(array, changeMeta, instanceMeta) {
     instanceMeta.itemCounts = {};
    },
    addedItem:function(array, item, changeMeta, instanceMeta) {
     var itemGuid = guidFor(item), dependentGuids = getDependentKeyGuids(changeMeta), dependentGuid = guidFor(changeMeta.arrayChanged), numberOfDependentArrays = changeMeta.property._dependentKeys.length, itemCounts = instanceMeta.itemCounts;
     if (!itemCounts[itemGuid]) {
      itemCounts[itemGuid] = {};
     }
     if (itemCounts[itemGuid][dependentGuid] === undefined) {
      itemCounts[itemGuid][dependentGuid] = 0;
     }
     if (++itemCounts[itemGuid][dependentGuid] === 1 && numberOfDependentArrays === Ember.keys(itemCounts[itemGuid]).length) {
      array.addObject(item);
     }
     return array;
    },
    removedItem:function(array, item, changeMeta, instanceMeta) {
     var itemGuid = guidFor(item), dependentGuids = getDependentKeyGuids(changeMeta), dependentGuid = guidFor(changeMeta.arrayChanged), numberOfDependentArrays = changeMeta.property._dependentKeys.length, numberOfArraysItemAppearsIn, itemCounts = instanceMeta.itemCounts;
     if (itemCounts[itemGuid][dependentGuid] === undefined) {
      itemCounts[itemGuid][dependentGuid] = 0;
     }
     if (--itemCounts[itemGuid][dependentGuid] === 0) {
      delete itemCounts[itemGuid][dependentGuid];
      numberOfArraysItemAppearsIn = Ember.keys(itemCounts[itemGuid]).length;
      if (numberOfArraysItemAppearsIn === 0) {
       delete itemCounts[itemGuid];
      }
      array.removeObject(item);
     }
     return array;
    }
   });
   return Ember.arrayComputed.apply(null, args);
  };
  Ember.computed.setDiff = function(setAProperty, setBProperty) {
   if (arguments.length !== 2) {
    throw new Ember.Error("setDiff requires exactly two dependent arrays.");
   }
   return Ember.arrayComputed(setAProperty, setBProperty, {
    addedItem:function(array, item, changeMeta, instanceMeta) {
     var setA = get(this, setAProperty), setB = get(this, setBProperty);
     if (changeMeta.arrayChanged === setA) {
      if (!setB.contains(item)) {
       array.addObject(item);
      }
     } else {
      array.removeObject(item);
     }
     return array;
    },
    removedItem:function(array, item, changeMeta, instanceMeta) {
     var setA = get(this, setAProperty), setB = get(this, setBProperty);
     if (changeMeta.arrayChanged === setB) {
      if (setA.contains(item)) {
       array.addObject(item);
      }
     } else {
      array.removeObject(item);
     }
     return array;
    }
   });
  };
  function binarySearch(array, item, low, high) {
   var mid, midItem, res, guidMid, guidItem;
   if (arguments.length < 4) {
    high = get(array, "length");
   }
   if (arguments.length < 3) {
    low = 0;
   }
   if (low === high) {
    return low;
   }
   mid = low + Math.floor((high - low) / 2);
   midItem = array.objectAt(mid);
   guidMid = _guidFor(midItem);
   guidItem = _guidFor(item);
   if (guidMid === guidItem) {
    return mid;
   }
   res = this.order(midItem, item);
   if (res === 0) {
    res = guidMid < guidItem ? -1 :1;
   }
   if (res < 0) {
    return this.binarySearch(array, item, mid + 1, high);
   } else if (res > 0) {
    return this.binarySearch(array, item, low, mid);
   }
   return mid;
   function _guidFor(item) {
    if (SearchProxy.detectInstance(item)) {
     return guidFor(get(item, "content"));
    }
    return guidFor(item);
   }
  }
  SearchProxy = Ember.ObjectProxy.extend();
  Ember.computed.sort = function(itemsKey, sortDefinition) {
   var initFn, sortPropertiesKey;
   if (typeof sortDefinition === "function") {
    initFn = function(array, changeMeta, instanceMeta) {
     instanceMeta.order = sortDefinition;
     instanceMeta.binarySearch = binarySearch;
    };
   } else {
    sortPropertiesKey = sortDefinition;
    initFn = function(array, changeMeta, instanceMeta) {
     function setupSortProperties() {
      var sortPropertyDefinitions = get(this, sortPropertiesKey), sortProperty, sortProperties = instanceMeta.sortProperties = [], sortPropertyAscending = instanceMeta.sortPropertyAscending = {}, idx, asc;
      changeMeta.property.clearItemPropertyKeys(itemsKey);
      forEach(sortPropertyDefinitions, function(sortPropertyDefinition) {
       if ((idx = sortPropertyDefinition.indexOf(":")) !== -1) {
        sortProperty = sortPropertyDefinition.substring(0, idx);
        asc = sortPropertyDefinition.substring(idx + 1).toLowerCase() !== "desc";
       } else {
        sortProperty = sortPropertyDefinition;
        asc = true;
       }
       sortProperties.push(sortProperty);
       sortPropertyAscending[sortProperty] = asc;
       changeMeta.property.itemPropertyKey(itemsKey, sortProperty);
      });
      sortPropertyDefinitions.addObserver("@each", this, updateSortPropertiesOnce);
     }
     function updateSortPropertiesOnce() {
      Ember.run.once(this, updateSortProperties, changeMeta.propertyName);
     }
     function updateSortProperties(propertyName) {
      setupSortProperties.call(this);
      changeMeta.property.recomputeOnce.call(this, propertyName);
     }
     Ember.addObserver(this, sortPropertiesKey, updateSortPropertiesOnce);
     setupSortProperties.call(this);
     instanceMeta.order = function(itemA, itemB) {
      var sortProperty, result, asc;
      for (var i = 0; i < this.sortProperties.length; ++i) {
       sortProperty = this.sortProperties[i];
       result = Ember.compare(get(itemA, sortProperty), get(itemB, sortProperty));
       if (result !== 0) {
        asc = this.sortPropertyAscending[sortProperty];
        return asc ? result :-1 * result;
       }
      }
      return 0;
     };
     instanceMeta.binarySearch = binarySearch;
    };
   }
   return Ember.arrayComputed(itemsKey, {
    initialize:initFn,
    addedItem:function(array, item, changeMeta, instanceMeta) {
     var index = instanceMeta.binarySearch(array, item);
     array.insertAt(index, item);
     return array;
    },
    removedItem:function(array, item, changeMeta, instanceMeta) {
     var proxyProperties, index, searchItem;
     if (changeMeta.previousValues) {
      proxyProperties = merge({
       content:item
      }, changeMeta.previousValues);
      searchItem = SearchProxy.create(proxyProperties);
     } else {
      searchItem = item;
     }
     index = instanceMeta.binarySearch(array, searchItem);
     array.removeAt(index);
     return array;
    }
   });
  };
 })();
 (function() {
  Ember.RSVP = requireModule("rsvp");
  Ember.RSVP.onerrorDefault = function(error) {
   if (error instanceof Error) {
    if (Ember.testing) {
     if (Ember.Test && Ember.Test.adapter) {
      Ember.Test.adapter.exception(error);
     } else {
      throw error;
     }
    } else {
     Ember.Logger.error(error.stack);
    }
   }
  };
  Ember.RSVP.on("error", Ember.RSVP.onerrorDefault);
 })();
 (function() {
  var a_slice = Array.prototype.slice;
  var expandProperties = Ember.expandProperties;
  if (Ember.EXTEND_PROTOTYPES === true || Ember.EXTEND_PROTOTYPES.Function) {
   Function.prototype.property = function() {
    var ret = Ember.computed(this);
    return ret.property.apply(ret, arguments);
   };
   Function.prototype.observes = function() {
    var addWatchedProperty = function(obs) {
     watched.push(obs);
    };
    var watched = [];
    for (var i = 0; i < arguments.length; ++i) {
     expandProperties(arguments[i], addWatchedProperty);
    }
    this.__ember_observes__ = watched;
    return this;
   };
   Function.prototype.observesImmediately = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
     var arg = arguments[i];
    }
    return this.observes.apply(this, arguments);
   };
   Function.prototype.observesBefore = function() {
    var addWatchedProperty = function(obs) {
     watched.push(obs);
    };
    var watched = [];
    for (var i = 0; i < arguments.length; ++i) {
     expandProperties(arguments[i], addWatchedProperty);
    }
    this.__ember_observesBefore__ = watched;
    return this;
   };
   Function.prototype.on = function() {
    var events = a_slice.call(arguments);
    this.__ember_listens__ = events;
    return this;
   };
  }
 })();
 (function() {})();
 (function() {
  Ember.Comparable = Ember.Mixin.create({
   compare:Ember.required(Function)
  });
 })();
 (function() {
  var get = Ember.get, set = Ember.set;
  Ember.Copyable = Ember.Mixin.create({
   copy:Ember.required(Function),
   frozenCopy:function() {
    if (Ember.Freezable && Ember.Freezable.detect(this)) {
     return get(this, "isFrozen") ? this :this.copy().freeze();
    } else {
     throw new Ember.Error(Ember.String.fmt("%@ does not support freezing", [ this ]));
    }
   }
  });
 })();
 (function() {
  var get = Ember.get, set = Ember.set;
  Ember.Freezable = Ember.Mixin.create({
   isFrozen:false,
   freeze:function() {
    if (get(this, "isFrozen")) return this;
    set(this, "isFrozen", true);
    return this;
   }
  });
  Ember.FROZEN_ERROR = "Frozen object cannot be modified.";
 })();
 (function() {
  var forEach = Ember.EnumerableUtils.forEach;
  Ember.MutableEnumerable = Ember.Mixin.create(Ember.Enumerable, {
   addObject:Ember.required(Function),
   addObjects:function(objects) {
    Ember.beginPropertyChanges(this);
    forEach(objects, function(obj) {
     this.addObject(obj);
    }, this);
    Ember.endPropertyChanges(this);
    return this;
   },
   removeObject:Ember.required(Function),
   removeObjects:function(objects) {
    Ember.beginPropertyChanges(this);
    forEach(objects, function(obj) {
     this.removeObject(obj);
    }, this);
    Ember.endPropertyChanges(this);
    return this;
   }
  });
 })();
 (function() {
  var OUT_OF_RANGE_EXCEPTION = "Index out of range";
  var EMPTY = [];
  var get = Ember.get, set = Ember.set;
  Ember.MutableArray = Ember.Mixin.create(Ember.Array, Ember.MutableEnumerable, {
   replace:Ember.required(),
   clear:function() {
    var len = get(this, "length");
    if (len === 0) return this;
    this.replace(0, len, EMPTY);
    return this;
   },
   insertAt:function(idx, object) {
    if (idx > get(this, "length")) throw new Ember.Error(OUT_OF_RANGE_EXCEPTION);
    this.replace(idx, 0, [ object ]);
    return this;
   },
   removeAt:function(start, len) {
    if ("number" === typeof start) {
     if (start < 0 || start >= get(this, "length")) {
      throw new Ember.Error(OUT_OF_RANGE_EXCEPTION);
     }
     if (len === undefined) len = 1;
     this.replace(start, len, EMPTY);
    }
    return this;
   },
   pushObject:function(obj) {
    this.insertAt(get(this, "length"), obj);
    return obj;
   },
   pushObjects:function(objects) {
    if (!(Ember.Enumerable.detect(objects) || Ember.isArray(objects))) {
     throw new TypeError("Must pass Ember.Enumerable to Ember.MutableArray#pushObjects");
    }
    this.replace(get(this, "length"), 0, objects);
    return this;
   },
   popObject:function() {
    var len = get(this, "length");
    if (len === 0) return null;
    var ret = this.objectAt(len - 1);
    this.removeAt(len - 1, 1);
    return ret;
   },
   shiftObject:function() {
    if (get(this, "length") === 0) return null;
    var ret = this.objectAt(0);
    this.removeAt(0);
    return ret;
   },
   unshiftObject:function(obj) {
    this.insertAt(0, obj);
    return obj;
   },
   unshiftObjects:function(objects) {
    this.replace(0, 0, objects);
    return this;
   },
   reverseObjects:function() {
    var len = get(this, "length");
    if (len === 0) return this;
    var objects = this.toArray().reverse();
    this.replace(0, len, objects);
    return this;
   },
   setObjects:function(objects) {
    if (objects.length === 0) return this.clear();
    var len = get(this, "length");
    this.replace(0, len, objects);
    return this;
   },
   removeObject:function(obj) {
    var loc = get(this, "length") || 0;
    while (--loc >= 0) {
     var curObject = this.objectAt(loc);
     if (curObject === obj) this.removeAt(loc);
    }
    return this;
   },
   addObject:function(obj) {
    if (!this.contains(obj)) this.pushObject(obj);
    return this;
   }
  });
 })();
 (function() {
  var get = Ember.get, set = Ember.set;
  Ember.TargetActionSupport = Ember.Mixin.create({
   target:null,
   action:null,
   actionContext:null,
   targetObject:Ember.computed(function() {
    var target = get(this, "target");
    if (Ember.typeOf(target) === "string") {
     var value = get(this, target);
     if (value === undefined) {
      value = get(Ember.lookup, target);
     }
     return value;
    } else {
     return target;
    }
   }).property("target"),
   actionContextObject:Ember.computed(function() {
    var actionContext = get(this, "actionContext");
    if (Ember.typeOf(actionContext) === "string") {
     var value = get(this, actionContext);
     if (value === undefined) {
      value = get(Ember.lookup, actionContext);
     }
     return value;
    } else {
     return actionContext;
    }
   }).property("actionContext"),
   triggerAction:function(opts) {
    opts = opts || {};
    var action = opts.action || get(this, "action"), target = opts.target || get(this, "targetObject"), actionContext = opts.actionContext;
    function args(options, actionName) {
     var ret = [];
     if (actionName) {
      ret.push(actionName);
     }
     return ret.concat(options);
    }
    if (typeof actionContext === "undefined") {
     actionContext = get(this, "actionContextObject") || this;
    }
    if (target && action) {
     var ret;
     if (target.send) {
      ret = target.send.apply(target, args(actionContext, action));
     } else {
      ret = target[action].apply(target, args(actionContext));
     }
     if (ret !== false) ret = true;
     return ret;
    } else {
     return false;
    }
   }
  });
 })();
 (function() {
  Ember.Evented = Ember.Mixin.create({
   on:function(name, target, method) {
    Ember.addListener(this, name, target, method);
    return this;
   },
   one:function(name, target, method) {
    if (!method) {
     method = target;
     target = null;
    }
    Ember.addListener(this, name, target, method, true);
    return this;
   },
   trigger:function(name) {
    var args = [], i, l;
    for (i = 1, l = arguments.length; i < l; i++) {
     args.push(arguments[i]);
    }
    Ember.sendEvent(this, name, args);
   },
   off:function(name, target, method) {
    Ember.removeListener(this, name, target, method);
    return this;
   },
   has:function(name) {
    return Ember.hasListeners(this, name);
   }
  });
 })();
 (function() {
  var RSVP = requireModule("rsvp");
  RSVP.configure("async", function(callback, promise) {
   Ember.run.schedule("actions", promise, callback, promise);
  });
  RSVP.Promise.prototype.fail = function(callback, label) {
   return this["catch"](callback, label);
  };
  var get = Ember.get;
  Ember.DeferredMixin = Ember.Mixin.create({
   then:function(resolve, reject, label) {
    var deferred, promise, entity;
    entity = this;
    deferred = get(this, "_deferred");
    promise = deferred.promise;
    function fulfillmentHandler(fulfillment) {
     if (fulfillment === promise) {
      return resolve(entity);
     } else {
      return resolve(fulfillment);
     }
    }
    return promise.then(resolve && fulfillmentHandler, reject, label);
   },
   resolve:function(value) {
    var deferred, promise;
    deferred = get(this, "_deferred");
    promise = deferred.promise;
    if (value === this) {
     deferred.resolve(promise);
    } else {
     deferred.resolve(value);
    }
   },
   reject:function(value) {
    get(this, "_deferred").reject(value);
   },
   _deferred:Ember.computed(function() {
    return RSVP.defer("Ember: DeferredMixin - " + this);
   })
  });
 })();
 (function() {
  var get = Ember.get, typeOf = Ember.typeOf;
  Ember.ActionHandler = Ember.Mixin.create({
   mergedProperties:[ "_actions" ],
   willMergeMixin:function(props) {
    var hashName;
    if (!props._actions) {
     if (typeOf(props.actions) === "object") {
      hashName = "actions";
     } else if (typeOf(props.events) === "object") {
      hashName = "events";
     }
     if (hashName) {
      props._actions = Ember.merge(props._actions || {}, props[hashName]);
     }
     delete props[hashName];
    }
   },
   send:function(actionName) {
    var args = [].slice.call(arguments, 1), target;
    if (this._actions && this._actions[actionName]) {
     if (this._actions[actionName].apply(this, args) === true) {} else {
      return;
     }
    } else if (this.deprecatedSend && this.deprecatedSendHandles && this.deprecatedSendHandles(actionName)) {
     if (this.deprecatedSend.apply(this, [].slice.call(arguments)) === true) {} else {
      return;
     }
    }
    if (target = get(this, "target")) {
     target.send.apply(target, arguments);
    }
   }
  });
 })();
 (function() {
  var set = Ember.set, get = Ember.get, not = Ember.computed.not, or = Ember.computed.or;
  function tap(proxy, promise) {
   return promise.then(function(value) {
    set(proxy, "isFulfilled", true);
    set(proxy, "content", value);
    return value;
   }, function(reason) {
    set(proxy, "isRejected", true);
    set(proxy, "reason", reason);
    throw reason;
   }, "Ember: PromiseProxy");
  }
  Ember.PromiseProxyMixin = Ember.Mixin.create({
   reason:null,
   isPending:not("isSettled").readOnly(),
   isSettled:or("isRejected", "isFulfilled").readOnly(),
   isRejected:false,
   isFulfilled:false,
   promise:Ember.computed(function(key, promise) {
    if (arguments.length === 2) {
     return tap(this, promise);
    } else {
     throw new Ember.Error("PromiseProxy's promise must be set");
    }
   }),
   then:promiseAlias("then"),
   "catch":promiseAlias("catch"),
   "finally":promiseAlias("finally")
  });
  function promiseAlias(name) {
   return function() {
    var promise = get(this, "promise");
    return promise[name].apply(promise, arguments);
   };
  }
 })();
 (function() {})();
 (function() {
  var get = Ember.get, forEach = Ember.EnumerableUtils.forEach, RETAIN = "r", INSERT = "i", DELETE = "d";
  Ember.TrackedArray = function(items) {
   if (arguments.length < 1) {
    items = [];
   }
   var length = get(items, "length");
   if (length) {
    this._operations = [ new ArrayOperation(RETAIN, length, items) ];
   } else {
    this._operations = [];
   }
  };
  Ember.TrackedArray.RETAIN = RETAIN;
  Ember.TrackedArray.INSERT = INSERT;
  Ember.TrackedArray.DELETE = DELETE;
  Ember.TrackedArray.prototype = {
   addItems:function(index, newItems) {
    var count = get(newItems, "length");
    if (count < 1) {
     return;
    }
    var match = this._findArrayOperation(index), arrayOperation = match.operation, arrayOperationIndex = match.index, arrayOperationRangeStart = match.rangeStart, composeIndex, splitIndex, splitItems, splitArrayOperation, newArrayOperation;
    newArrayOperation = new ArrayOperation(INSERT, count, newItems);
    if (arrayOperation) {
     if (!match.split) {
      this._operations.splice(arrayOperationIndex, 0, newArrayOperation);
      composeIndex = arrayOperationIndex;
     } else {
      this._split(arrayOperationIndex, index - arrayOperationRangeStart, newArrayOperation);
      composeIndex = arrayOperationIndex + 1;
     }
    } else {
     this._operations.push(newArrayOperation);
     composeIndex = arrayOperationIndex;
    }
    this._composeInsert(composeIndex);
   },
   removeItems:function(index, count) {
    if (count < 1) {
     return;
    }
    var match = this._findArrayOperation(index), arrayOperation = match.operation, arrayOperationIndex = match.index, arrayOperationRangeStart = match.rangeStart, newArrayOperation, composeIndex;
    newArrayOperation = new ArrayOperation(DELETE, count);
    if (!match.split) {
     this._operations.splice(arrayOperationIndex, 0, newArrayOperation);
     composeIndex = arrayOperationIndex;
    } else {
     this._split(arrayOperationIndex, index - arrayOperationRangeStart, newArrayOperation);
     composeIndex = arrayOperationIndex + 1;
    }
    return this._composeDelete(composeIndex);
   },
   apply:function(callback) {
    var items = [], offset = 0;
    forEach(this._operations, function(arrayOperation) {
     callback(arrayOperation.items, offset, arrayOperation.type);
     if (arrayOperation.type !== DELETE) {
      offset += arrayOperation.count;
      items = items.concat(arrayOperation.items);
     }
    });
    this._operations = [ new ArrayOperation(RETAIN, items.length, items) ];
   },
   _findArrayOperation:function(index) {
    var arrayOperationIndex, len, split = false, arrayOperation, arrayOperationRangeStart, arrayOperationRangeEnd;
    for (arrayOperationIndex = arrayOperationRangeStart = 0, len = this._operations.length; arrayOperationIndex < len; ++arrayOperationIndex) {
     arrayOperation = this._operations[arrayOperationIndex];
     if (arrayOperation.type === DELETE) {
      continue;
     }
     arrayOperationRangeEnd = arrayOperationRangeStart + arrayOperation.count - 1;
     if (index === arrayOperationRangeStart) {
      break;
     } else if (index > arrayOperationRangeStart && index <= arrayOperationRangeEnd) {
      split = true;
      break;
     } else {
      arrayOperationRangeStart = arrayOperationRangeEnd + 1;
     }
    }
    return new ArrayOperationMatch(arrayOperation, arrayOperationIndex, split, arrayOperationRangeStart);
   },
   _split:function(arrayOperationIndex, splitIndex, newArrayOperation) {
    var arrayOperation = this._operations[arrayOperationIndex], splitItems = arrayOperation.items.slice(splitIndex), splitArrayOperation = new ArrayOperation(arrayOperation.type, splitItems.length, splitItems);
    arrayOperation.count = splitIndex;
    arrayOperation.items = arrayOperation.items.slice(0, splitIndex);
    this._operations.splice(arrayOperationIndex + 1, 0, newArrayOperation, splitArrayOperation);
   },
   _composeInsert:function(index) {
    var newArrayOperation = this._operations[index], leftArrayOperation = this._operations[index - 1], rightArrayOperation = this._operations[index + 1], leftOp = leftArrayOperation && leftArrayOperation.type, rightOp = rightArrayOperation && rightArrayOperation.type;
    if (leftOp === INSERT) {
     leftArrayOperation.count += newArrayOperation.count;
     leftArrayOperation.items = leftArrayOperation.items.concat(newArrayOperation.items);
     if (rightOp === INSERT) {
      leftArrayOperation.count += rightArrayOperation.count;
      leftArrayOperation.items = leftArrayOperation.items.concat(rightArrayOperation.items);
      this._operations.splice(index, 2);
     } else {
      this._operations.splice(index, 1);
     }
    } else if (rightOp === INSERT) {
     newArrayOperation.count += rightArrayOperation.count;
     newArrayOperation.items = newArrayOperation.items.concat(rightArrayOperation.items);
     this._operations.splice(index + 1, 1);
    }
   },
   _composeDelete:function(index) {
    var arrayOperation = this._operations[index], deletesToGo = arrayOperation.count, leftArrayOperation = this._operations[index - 1], leftOp = leftArrayOperation && leftArrayOperation.type, nextArrayOperation, nextOp, nextCount, removeNewAndNextOp = false, removedItems = [];
    if (leftOp === DELETE) {
     arrayOperation = leftArrayOperation;
     index -= 1;
    }
    for (var i = index + 1; deletesToGo > 0; ++i) {
     nextArrayOperation = this._operations[i];
     nextOp = nextArrayOperation.type;
     nextCount = nextArrayOperation.count;
     if (nextOp === DELETE) {
      arrayOperation.count += nextCount;
      continue;
     }
     if (nextCount > deletesToGo) {
      removedItems = removedItems.concat(nextArrayOperation.items.splice(0, deletesToGo));
      nextArrayOperation.count -= deletesToGo;
      i -= 1;
      nextCount = deletesToGo;
      deletesToGo = 0;
     } else {
      if (nextCount === deletesToGo) {
       removeNewAndNextOp = true;
      }
      removedItems = removedItems.concat(nextArrayOperation.items);
      deletesToGo -= nextCount;
     }
     if (nextOp === INSERT) {
      arrayOperation.count -= nextCount;
     }
    }
    if (arrayOperation.count > 0) {
     this._operations.splice(index + 1, i - 1 - index);
    } else {
     this._operations.splice(index, removeNewAndNextOp ? 2 :1);
    }
    return removedItems;
   },
   toString:function() {
    var str = "";
    forEach(this._operations, function(operation) {
     str += " " + operation.type + ":" + operation.count;
    });
    return str.substring(1);
   }
  };
  function ArrayOperation(operation, count, items) {
   this.type = operation;
   this.count = count;
   this.items = items;
  }
  function ArrayOperationMatch(operation, index, split, rangeStart) {
   this.operation = operation;
   this.index = index;
   this.split = split;
   this.rangeStart = rangeStart;
  }
 })();
 (function() {
  var get = Ember.get, forEach = Ember.EnumerableUtils.forEach, RETAIN = "r", FILTER = "f";
  function Operation(type, count) {
   this.type = type;
   this.count = count;
  }
  Ember.SubArray = function(length) {
   if (arguments.length < 1) {
    length = 0;
   }
   if (length > 0) {
    this._operations = [ new Operation(RETAIN, length) ];
   } else {
    this._operations = [];
   }
  };
  Ember.SubArray.prototype = {
   addItem:function(index, match) {
    var returnValue = -1, itemType = match ? RETAIN :FILTER, self = this;
    this._findOperation(index, function(operation, operationIndex, rangeStart, rangeEnd, seenInSubArray) {
     var newOperation, splitOperation;
     if (itemType === operation.type) {
      ++operation.count;
     } else if (index === rangeStart) {
      self._operations.splice(operationIndex, 0, new Operation(itemType, 1));
     } else {
      newOperation = new Operation(itemType, 1);
      splitOperation = new Operation(operation.type, rangeEnd - index + 1);
      operation.count = index - rangeStart;
      self._operations.splice(operationIndex + 1, 0, newOperation, splitOperation);
     }
     if (match) {
      if (operation.type === RETAIN) {
       returnValue = seenInSubArray + (index - rangeStart);
      } else {
       returnValue = seenInSubArray;
      }
     }
     self._composeAt(operationIndex);
    }, function(seenInSubArray) {
     self._operations.push(new Operation(itemType, 1));
     if (match) {
      returnValue = seenInSubArray;
     }
     self._composeAt(self._operations.length - 1);
    });
    return returnValue;
   },
   removeItem:function(index) {
    var returnValue = -1, self = this;
    this._findOperation(index, function(operation, operationIndex, rangeStart, rangeEnd, seenInSubArray) {
     if (operation.type === RETAIN) {
      returnValue = seenInSubArray + (index - rangeStart);
     }
     if (operation.count > 1) {
      --operation.count;
     } else {
      self._operations.splice(operationIndex, 1);
      self._composeAt(operationIndex);
     }
    }, function() {
     throw new Ember.Error("Can't remove an item that has never been added.");
    });
    return returnValue;
   },
   _findOperation:function(index, foundCallback, notFoundCallback) {
    var operationIndex, len, operation, rangeStart, rangeEnd, seenInSubArray = 0;
    for (operationIndex = rangeStart = 0, len = this._operations.length; operationIndex < len; rangeStart = rangeEnd + 1, ++operationIndex) {
     operation = this._operations[operationIndex];
     rangeEnd = rangeStart + operation.count - 1;
     if (index >= rangeStart && index <= rangeEnd) {
      foundCallback(operation, operationIndex, rangeStart, rangeEnd, seenInSubArray);
      return;
     } else if (operation.type === RETAIN) {
      seenInSubArray += operation.count;
     }
    }
    notFoundCallback(seenInSubArray);
   },
   _composeAt:function(index) {
    var op = this._operations[index], otherOp;
    if (!op) {
     return;
    }
    if (index > 0) {
     otherOp = this._operations[index - 1];
     if (otherOp.type === op.type) {
      op.count += otherOp.count;
      this._operations.splice(index - 1, 1);
      --index;
     }
    }
    if (index < this._operations.length - 1) {
     otherOp = this._operations[index + 1];
     if (otherOp.type === op.type) {
      op.count += otherOp.count;
      this._operations.splice(index + 1, 1);
     }
    }
   },
   toString:function() {
    var str = "";
    forEach(this._operations, function(operation) {
     str += " " + operation.type + ":" + operation.count;
    });
    return str.substring(1);
   }
  };
 })();
 (function() {
  Ember.Container = requireModule("container");
  Ember.Container.set = Ember.set;
 })();
 (function() {
  Ember.Application = Ember.Namespace.extend();
 })();
 (function() {
  var OUT_OF_RANGE_EXCEPTION = "Index out of range";
  var EMPTY = [];
  var get = Ember.get, set = Ember.set;
  Ember.ArrayProxy = Ember.Object.extend(Ember.MutableArray, {
   content:null,
   arrangedContent:Ember.computed.alias("content"),
   objectAtContent:function(idx) {
    return get(this, "arrangedContent").objectAt(idx);
   },
   replaceContent:function(idx, amt, objects) {
    get(this, "content").replace(idx, amt, objects);
   },
   _contentWillChange:Ember.beforeObserver("content", function() {
    this._teardownContent();
   }),
   _teardownContent:function() {
    var content = get(this, "content");
    if (content) {
     content.removeArrayObserver(this, {
      willChange:"contentArrayWillChange",
      didChange:"contentArrayDidChange"
     });
    }
   },
   contentArrayWillChange:Ember.K,
   contentArrayDidChange:Ember.K,
   _contentDidChange:Ember.observer("content", function() {
    var content = get(this, "content");
    this._setupContent();
   }),
   _setupContent:function() {
    var content = get(this, "content");
    if (content) {
     content.addArrayObserver(this, {
      willChange:"contentArrayWillChange",
      didChange:"contentArrayDidChange"
     });
    }
   },
   _arrangedContentWillChange:Ember.beforeObserver("arrangedContent", function() {
    var arrangedContent = get(this, "arrangedContent"), len = arrangedContent ? get(arrangedContent, "length") :0;
    this.arrangedContentArrayWillChange(this, 0, len, undefined);
    this.arrangedContentWillChange(this);
    this._teardownArrangedContent(arrangedContent);
   }),
   _arrangedContentDidChange:Ember.observer("arrangedContent", function() {
    var arrangedContent = get(this, "arrangedContent"), len = arrangedContent ? get(arrangedContent, "length") :0;
    this._setupArrangedContent();
    this.arrangedContentDidChange(this);
    this.arrangedContentArrayDidChange(this, 0, undefined, len);
   }),
   _setupArrangedContent:function() {
    var arrangedContent = get(this, "arrangedContent");
    if (arrangedContent) {
     arrangedContent.addArrayObserver(this, {
      willChange:"arrangedContentArrayWillChange",
      didChange:"arrangedContentArrayDidChange"
     });
    }
   },
   _teardownArrangedContent:function() {
    var arrangedContent = get(this, "arrangedContent");
    if (arrangedContent) {
     arrangedContent.removeArrayObserver(this, {
      willChange:"arrangedContentArrayWillChange",
      didChange:"arrangedContentArrayDidChange"
     });
    }
   },
   arrangedContentWillChange:Ember.K,
   arrangedContentDidChange:Ember.K,
   objectAt:function(idx) {
    return get(this, "content") && this.objectAtContent(idx);
   },
   length:Ember.computed(function() {
    var arrangedContent = get(this, "arrangedContent");
    return arrangedContent ? get(arrangedContent, "length") :0;
   }),
   _replace:function(idx, amt, objects) {
    var content = get(this, "content");
    if (content) this.replaceContent(idx, amt, objects);
    return this;
   },
   replace:function() {
    if (get(this, "arrangedContent") === get(this, "content")) {
     this._replace.apply(this, arguments);
    } else {
     throw new Ember.Error("Using replace on an arranged ArrayProxy is not allowed.");
    }
   },
   _insertAt:function(idx, object) {
    if (idx > get(this, "content.length")) throw new Ember.Error(OUT_OF_RANGE_EXCEPTION);
    this._replace(idx, 0, [ object ]);
    return this;
   },
   insertAt:function(idx, object) {
    if (get(this, "arrangedContent") === get(this, "content")) {
     return this._insertAt(idx, object);
    } else {
     throw new Ember.Error("Using insertAt on an arranged ArrayProxy is not allowed.");
    }
   },
   removeAt:function(start, len) {
    if ("number" === typeof start) {
     var content = get(this, "content"), arrangedContent = get(this, "arrangedContent"), indices = [], i;
     if (start < 0 || start >= get(this, "length")) {
      throw new Ember.Error(OUT_OF_RANGE_EXCEPTION);
     }
     if (len === undefined) len = 1;
     for (i = start; i < start + len; i++) {
      indices.push(content.indexOf(arrangedContent.objectAt(i)));
     }
     indices.sort(function(a, b) {
      return b - a;
     });
     Ember.beginPropertyChanges();
     for (i = 0; i < indices.length; i++) {
      this._replace(indices[i], 1, EMPTY);
     }
     Ember.endPropertyChanges();
    }
    return this;
   },
   pushObject:function(obj) {
    this._insertAt(get(this, "content.length"), obj);
    return obj;
   },
   pushObjects:function(objects) {
    if (!(Ember.Enumerable.detect(objects) || Ember.isArray(objects))) {
     throw new TypeError("Must pass Ember.Enumerable to Ember.MutableArray#pushObjects");
    }
    this._replace(get(this, "length"), 0, objects);
    return this;
   },
   setObjects:function(objects) {
    if (objects.length === 0) return this.clear();
    var len = get(this, "length");
    this._replace(0, len, objects);
    return this;
   },
   unshiftObject:function(obj) {
    this._insertAt(0, obj);
    return obj;
   },
   unshiftObjects:function(objects) {
    this._replace(0, 0, objects);
    return this;
   },
   slice:function() {
    var arr = this.toArray();
    return arr.slice.apply(arr, arguments);
   },
   arrangedContentArrayWillChange:function(item, idx, removedCnt, addedCnt) {
    this.arrayContentWillChange(idx, removedCnt, addedCnt);
   },
   arrangedContentArrayDidChange:function(item, idx, removedCnt, addedCnt) {
    this.arrayContentDidChange(idx, removedCnt, addedCnt);
   },
   init:function() {
    this._super();
    this._setupContent();
    this._setupArrangedContent();
   },
   willDestroy:function() {
    this._teardownArrangedContent();
    this._teardownContent();
   }
  });
 })();
 (function() {
  var set = Ember.set, get = Ember.get, guidFor = Ember.guidFor;
  var forEach = Ember.EnumerableUtils.forEach, indexOf = Ember.ArrayPolyfills.indexOf;
  var EachArray = Ember.Object.extend(Ember.Array, {
   init:function(content, keyName, owner) {
    this._super();
    this._keyName = keyName;
    this._owner = owner;
    this._content = content;
   },
   objectAt:function(idx) {
    var item = this._content.objectAt(idx);
    return item && get(item, this._keyName);
   },
   length:Ember.computed(function() {
    var content = this._content;
    return content ? get(content, "length") :0;
   })
  });
  var IS_OBSERVER = /^.+:(before|change)$/;
  function addObserverForContentKey(content, keyName, proxy, idx, loc) {
   var objects = proxy._objects, guid;
   if (!objects) objects = proxy._objects = {};
   while (--loc >= idx) {
    var item = content.objectAt(loc);
    if (item) {
     Ember.addBeforeObserver(item, keyName, proxy, "contentKeyWillChange");
     Ember.addObserver(item, keyName, proxy, "contentKeyDidChange");
     guid = guidFor(item);
     if (!objects[guid]) objects[guid] = [];
     objects[guid].push(loc);
    }
   }
  }
  function removeObserverForContentKey(content, keyName, proxy, idx, loc) {
   var objects = proxy._objects;
   if (!objects) objects = proxy._objects = {};
   var indicies, guid;
   while (--loc >= idx) {
    var item = content.objectAt(loc);
    if (item) {
     Ember.removeBeforeObserver(item, keyName, proxy, "contentKeyWillChange");
     Ember.removeObserver(item, keyName, proxy, "contentKeyDidChange");
     guid = guidFor(item);
     indicies = objects[guid];
     indicies[indexOf.call(indicies, loc)] = null;
    }
   }
  }
  Ember.EachProxy = Ember.Object.extend({
   init:function(content) {
    this._super();
    this._content = content;
    content.addArrayObserver(this);
    forEach(Ember.watchedEvents(this), function(eventName) {
     this.didAddListener(eventName);
    }, this);
   },
   unknownProperty:function(keyName, value) {
    var ret;
    ret = new EachArray(this._content, keyName, this);
    Ember.defineProperty(this, keyName, null, ret);
    this.beginObservingContentKey(keyName);
    return ret;
   },
   arrayWillChange:function(content, idx, removedCnt, addedCnt) {
    var keys = this._keys, key, lim;
    lim = removedCnt > 0 ? idx + removedCnt :-1;
    Ember.beginPropertyChanges(this);
    for (key in keys) {
     if (!keys.hasOwnProperty(key)) {
      continue;
     }
     if (lim > 0) {
      removeObserverForContentKey(content, key, this, idx, lim);
     }
     Ember.propertyWillChange(this, key);
    }
    Ember.propertyWillChange(this._content, "@each");
    Ember.endPropertyChanges(this);
   },
   arrayDidChange:function(content, idx, removedCnt, addedCnt) {
    var keys = this._keys, lim;
    lim = addedCnt > 0 ? idx + addedCnt :-1;
    Ember.changeProperties(function() {
     for (var key in keys) {
      if (!keys.hasOwnProperty(key)) {
       continue;
      }
      if (lim > 0) {
       addObserverForContentKey(content, key, this, idx, lim);
      }
      Ember.propertyDidChange(this, key);
     }
     Ember.propertyDidChange(this._content, "@each");
    }, this);
   },
   didAddListener:function(eventName) {
    if (IS_OBSERVER.test(eventName)) {
     this.beginObservingContentKey(eventName.slice(0, -7));
    }
   },
   didRemoveListener:function(eventName) {
    if (IS_OBSERVER.test(eventName)) {
     this.stopObservingContentKey(eventName.slice(0, -7));
    }
   },
   beginObservingContentKey:function(keyName) {
    var keys = this._keys;
    if (!keys) keys = this._keys = {};
    if (!keys[keyName]) {
     keys[keyName] = 1;
     var content = this._content, len = get(content, "length");
     addObserverForContentKey(content, keyName, this, 0, len);
    } else {
     keys[keyName]++;
    }
   },
   stopObservingContentKey:function(keyName) {
    var keys = this._keys;
    if (keys && keys[keyName] > 0 && --keys[keyName] <= 0) {
     var content = this._content, len = get(content, "length");
     removeObserverForContentKey(content, keyName, this, 0, len);
    }
   },
   contentKeyWillChange:function(obj, keyName) {
    Ember.propertyWillChange(this, keyName);
   },
   contentKeyDidChange:function(obj, keyName) {
    Ember.propertyDidChange(this, keyName);
   }
  });
 })();
 (function() {
  var get = Ember.get, set = Ember.set, replace = Ember.EnumerableUtils._replace;
  var NativeArray = Ember.Mixin.create(Ember.MutableArray, Ember.Observable, Ember.Copyable, {
   get:function(key) {
    if (key === "length") return this.length; else if ("number" === typeof key) return this[key]; else return this._super(key);
   },
   objectAt:function(idx) {
    return this[idx];
   },
   replace:function(idx, amt, objects) {
    if (this.isFrozen) throw Ember.FROZEN_ERROR;
    var len = objects ? get(objects, "length") :0;
    this.arrayContentWillChange(idx, amt, len);
    if (len === 0) {
     this.splice(idx, amt);
    } else {
     replace(this, idx, amt, objects);
    }
    this.arrayContentDidChange(idx, amt, len);
    return this;
   },
   unknownProperty:function(key, value) {
    var ret;
    if (value !== undefined && ret === undefined) {
     ret = this[key] = value;
    }
    return ret;
   },
   indexOf:function(object, startAt) {
    var idx, len = this.length;
    if (startAt === undefined) startAt = 0; else startAt = startAt < 0 ? Math.ceil(startAt) :Math.floor(startAt);
    if (startAt < 0) startAt += len;
    for (idx = startAt; idx < len; idx++) {
     if (this[idx] === object) return idx;
    }
    return -1;
   },
   lastIndexOf:function(object, startAt) {
    var idx, len = this.length;
    if (startAt === undefined) startAt = len - 1; else startAt = startAt < 0 ? Math.ceil(startAt) :Math.floor(startAt);
    if (startAt < 0) startAt += len;
    for (idx = startAt; idx >= 0; idx--) {
     if (this[idx] === object) return idx;
    }
    return -1;
   },
   copy:function(deep) {
    if (deep) {
     return this.map(function(item) {
      return Ember.copy(item, true);
     });
    }
    return this.slice();
   }
  });
  var ignore = [ "length" ];
  Ember.EnumerableUtils.forEach(NativeArray.keys(), function(methodName) {
   if (Array.prototype[methodName]) ignore.push(methodName);
  });
  if (ignore.length > 0) {
   NativeArray = NativeArray.without.apply(NativeArray, ignore);
  }
  Ember.NativeArray = NativeArray;
  Ember.A = function(arr) {
   if (arr === undefined) {
    arr = [];
   }
   return Ember.Array.detect(arr) ? arr :Ember.NativeArray.apply(arr);
  };
  Ember.NativeArray.activate = function() {
   NativeArray.apply(Array.prototype);
   Ember.A = function(arr) {
    return arr || [];
   };
  };
  if (Ember.EXTEND_PROTOTYPES === true || Ember.EXTEND_PROTOTYPES.Array) {
   Ember.NativeArray.activate();
  }
 })();
 (function() {
  var get = Ember.get, set = Ember.set, guidFor = Ember.guidFor, isNone = Ember.isNone, fmt = Ember.String.fmt;
  Ember.Set = Ember.CoreObject.extend(Ember.MutableEnumerable, Ember.Copyable, Ember.Freezable, {
   length:0,
   clear:function() {
    if (this.isFrozen) {
     throw new Ember.Error(Ember.FROZEN_ERROR);
    }
    var len = get(this, "length");
    if (len === 0) {
     return this;
    }
    var guid;
    this.enumerableContentWillChange(len, 0);
    Ember.propertyWillChange(this, "firstObject");
    Ember.propertyWillChange(this, "lastObject");
    for (var i = 0; i < len; i++) {
     guid = guidFor(this[i]);
     delete this[guid];
     delete this[i];
    }
    set(this, "length", 0);
    Ember.propertyDidChange(this, "firstObject");
    Ember.propertyDidChange(this, "lastObject");
    this.enumerableContentDidChange(len, 0);
    return this;
   },
   isEqual:function(obj) {
    if (!Ember.Enumerable.detect(obj)) return false;
    var loc = get(this, "length");
    if (get(obj, "length") !== loc) return false;
    while (--loc >= 0) {
     if (!obj.contains(this[loc])) return false;
    }
    return true;
   },
   add:Ember.aliasMethod("addObject"),
   remove:Ember.aliasMethod("removeObject"),
   pop:function() {
    if (get(this, "isFrozen")) throw new Ember.Error(Ember.FROZEN_ERROR);
    var obj = this.length > 0 ? this[this.length - 1] :null;
    this.remove(obj);
    return obj;
   },
   push:Ember.aliasMethod("addObject"),
   shift:Ember.aliasMethod("pop"),
   unshift:Ember.aliasMethod("push"),
   addEach:Ember.aliasMethod("addObjects"),
   removeEach:Ember.aliasMethod("removeObjects"),
   init:function(items) {
    this._super();
    if (items) this.addObjects(items);
   },
   nextObject:function(idx) {
    return this[idx];
   },
   firstObject:Ember.computed(function() {
    return this.length > 0 ? this[0] :undefined;
   }),
   lastObject:Ember.computed(function() {
    return this.length > 0 ? this[this.length - 1] :undefined;
   }),
   addObject:function(obj) {
    if (get(this, "isFrozen")) throw new Ember.Error(Ember.FROZEN_ERROR);
    if (isNone(obj)) return this;
    var guid = guidFor(obj), idx = this[guid], len = get(this, "length"), added;
    if (idx >= 0 && idx < len && this[idx] === obj) return this;
    added = [ obj ];
    this.enumerableContentWillChange(null, added);
    Ember.propertyWillChange(this, "lastObject");
    len = get(this, "length");
    this[guid] = len;
    this[len] = obj;
    set(this, "length", len + 1);
    Ember.propertyDidChange(this, "lastObject");
    this.enumerableContentDidChange(null, added);
    return this;
   },
   removeObject:function(obj) {
    if (get(this, "isFrozen")) throw new Ember.Error(Ember.FROZEN_ERROR);
    if (isNone(obj)) return this;
    var guid = guidFor(obj), idx = this[guid], len = get(this, "length"), isFirst = idx === 0, isLast = idx === len - 1, last, removed;
    if (idx >= 0 && idx < len && this[idx] === obj) {
     removed = [ obj ];
     this.enumerableContentWillChange(removed, null);
     if (isFirst) {
      Ember.propertyWillChange(this, "firstObject");
     }
     if (isLast) {
      Ember.propertyWillChange(this, "lastObject");
     }
     if (idx < len - 1) {
      last = this[len - 1];
      this[idx] = last;
      this[guidFor(last)] = idx;
     }
     delete this[guid];
     delete this[len - 1];
     set(this, "length", len - 1);
     if (isFirst) {
      Ember.propertyDidChange(this, "firstObject");
     }
     if (isLast) {
      Ember.propertyDidChange(this, "lastObject");
     }
     this.enumerableContentDidChange(removed, null);
    }
    return this;
   },
   contains:function(obj) {
    return this[guidFor(obj)] >= 0;
   },
   copy:function() {
    var C = this.constructor, ret = new C(), loc = get(this, "length");
    set(ret, "length", loc);
    while (--loc >= 0) {
     ret[loc] = this[loc];
     ret[guidFor(this[loc])] = loc;
    }
    return ret;
   },
   toString:function() {
    var len = this.length, idx, array = [];
    for (idx = 0; idx < len; idx++) {
     array[idx] = this[idx];
    }
    return fmt("Ember.Set<%@>", [ array.join(",") ]);
   }
  });
 })();
 (function() {
  var DeferredMixin = Ember.DeferredMixin, get = Ember.get;
  var Deferred = Ember.Object.extend(DeferredMixin);
  Deferred.reopenClass({
   promise:function(callback, binding) {
    var deferred = Deferred.create();
    callback.call(binding, deferred);
    return deferred;
   }
  });
  Ember.Deferred = Deferred;
 })();
 (function() {
  var forEach = Ember.ArrayPolyfills.forEach;
  var loadHooks = Ember.ENV.EMBER_LOAD_HOOKS || {};
  var loaded = {};
  Ember.onLoad = function(name, callback) {
   var object;
   loadHooks[name] = loadHooks[name] || Ember.A();
   loadHooks[name].pushObject(callback);
   if (object = loaded[name]) {
    callback(object);
   }
  };
  Ember.runLoadHooks = function(name, object) {
   loaded[name] = object;
   if (loadHooks[name]) {
    forEach.call(loadHooks[name], function(callback) {
     callback(object);
    });
   }
  };
 })();
 (function() {})();
 (function() {
  var get = Ember.get;
  Ember.ControllerMixin = Ember.Mixin.create(Ember.ActionHandler, {
   isController:true,
   target:null,
   container:null,
   parentController:null,
   store:null,
   model:Ember.computed.alias("content"),
   deprecatedSendHandles:function(actionName) {
    return !!this[actionName];
   },
   deprecatedSend:function(actionName) {
    var args = [].slice.call(arguments, 1);
    this[actionName].apply(this, args);
    return;
   }
  });
  Ember.Controller = Ember.Object.extend(Ember.ControllerMixin);
 })();
 (function() {
  var get = Ember.get, set = Ember.set, forEach = Ember.EnumerableUtils.forEach;
  Ember.SortableMixin = Ember.Mixin.create(Ember.MutableEnumerable, {
   sortProperties:null,
   sortAscending:true,
   sortFunction:Ember.compare,
   orderBy:function(item1, item2) {
    var result = 0, sortProperties = get(this, "sortProperties"), sortAscending = get(this, "sortAscending"), sortFunction = get(this, "sortFunction");
    forEach(sortProperties, function(propertyName) {
     if (result === 0) {
      result = sortFunction(get(item1, propertyName), get(item2, propertyName));
      if (result !== 0 && !sortAscending) {
       result = -1 * result;
      }
     }
    });
    return result;
   },
   destroy:function() {
    var content = get(this, "content"), sortProperties = get(this, "sortProperties");
    if (content && sortProperties) {
     forEach(content, function(item) {
      forEach(sortProperties, function(sortProperty) {
       Ember.removeObserver(item, sortProperty, this, "contentItemSortPropertyDidChange");
      }, this);
     }, this);
    }
    return this._super();
   },
   isSorted:Ember.computed.bool("sortProperties"),
   arrangedContent:Ember.computed("content", "sortProperties.@each", function(key, value) {
    var content = get(this, "content"), isSorted = get(this, "isSorted"), sortProperties = get(this, "sortProperties"), self = this;
    if (content && isSorted) {
     content = content.slice();
     content.sort(function(item1, item2) {
      return self.orderBy(item1, item2);
     });
     forEach(content, function(item) {
      forEach(sortProperties, function(sortProperty) {
       Ember.addObserver(item, sortProperty, this, "contentItemSortPropertyDidChange");
      }, this);
     }, this);
     return Ember.A(content);
    }
    return content;
   }),
   _contentWillChange:Ember.beforeObserver("content", function() {
    var content = get(this, "content"), sortProperties = get(this, "sortProperties");
    if (content && sortProperties) {
     forEach(content, function(item) {
      forEach(sortProperties, function(sortProperty) {
       Ember.removeObserver(item, sortProperty, this, "contentItemSortPropertyDidChange");
      }, this);
     }, this);
    }
    this._super();
   }),
   sortAscendingWillChange:Ember.beforeObserver("sortAscending", function() {
    this._lastSortAscending = get(this, "sortAscending");
   }),
   sortAscendingDidChange:Ember.observer("sortAscending", function() {
    if (get(this, "sortAscending") !== this._lastSortAscending) {
     var arrangedContent = get(this, "arrangedContent");
     arrangedContent.reverseObjects();
    }
   }),
   contentArrayWillChange:function(array, idx, removedCount, addedCount) {
    var isSorted = get(this, "isSorted");
    if (isSorted) {
     var arrangedContent = get(this, "arrangedContent");
     var removedObjects = array.slice(idx, idx + removedCount);
     var sortProperties = get(this, "sortProperties");
     forEach(removedObjects, function(item) {
      arrangedContent.removeObject(item);
      forEach(sortProperties, function(sortProperty) {
       Ember.removeObserver(item, sortProperty, this, "contentItemSortPropertyDidChange");
      }, this);
     }, this);
    }
    return this._super(array, idx, removedCount, addedCount);
   },
   contentArrayDidChange:function(array, idx, removedCount, addedCount) {
    var isSorted = get(this, "isSorted"), sortProperties = get(this, "sortProperties");
    if (isSorted) {
     var addedObjects = array.slice(idx, idx + addedCount);
     forEach(addedObjects, function(item) {
      this.insertItemSorted(item);
      forEach(sortProperties, function(sortProperty) {
       Ember.addObserver(item, sortProperty, this, "contentItemSortPropertyDidChange");
      }, this);
     }, this);
    }
    return this._super(array, idx, removedCount, addedCount);
   },
   insertItemSorted:function(item) {
    var arrangedContent = get(this, "arrangedContent");
    var length = get(arrangedContent, "length");
    var idx = this._binarySearch(item, 0, length);
    arrangedContent.insertAt(idx, item);
   },
   contentItemSortPropertyDidChange:function(item) {
    var arrangedContent = get(this, "arrangedContent"), oldIndex = arrangedContent.indexOf(item), leftItem = arrangedContent.objectAt(oldIndex - 1), rightItem = arrangedContent.objectAt(oldIndex + 1), leftResult = leftItem && this.orderBy(item, leftItem), rightResult = rightItem && this.orderBy(item, rightItem);
    if (leftResult < 0 || rightResult > 0) {
     arrangedContent.removeObject(item);
     this.insertItemSorted(item);
    }
   },
   _binarySearch:function(item, low, high) {
    var mid, midItem, res, arrangedContent;
    if (low === high) {
     return low;
    }
    arrangedContent = get(this, "arrangedContent");
    mid = low + Math.floor((high - low) / 2);
    midItem = arrangedContent.objectAt(mid);
    res = this.orderBy(midItem, item);
    if (res < 0) {
     return this._binarySearch(item, mid + 1, high);
    } else if (res > 0) {
     return this._binarySearch(item, low, mid);
    }
    return mid;
   }
  });
 })();
 (function() {
  var get = Ember.get, set = Ember.set, forEach = Ember.EnumerableUtils.forEach, replace = Ember.EnumerableUtils.replace;
  Ember.ArrayController = Ember.ArrayProxy.extend(Ember.ControllerMixin, Ember.SortableMixin, {
   itemController:null,
   lookupItemController:function(object) {
    return get(this, "itemController");
   },
   objectAtContent:function(idx) {
    var length = get(this, "length"), arrangedContent = get(this, "arrangedContent"), object = arrangedContent && arrangedContent.objectAt(idx);
    if (idx >= 0 && idx < length) {
     var controllerClass = this.lookupItemController(object);
     if (controllerClass) {
      return this.controllerAt(idx, object, controllerClass);
     }
    }
    return object;
   },
   arrangedContentDidChange:function() {
    this._super();
    this._resetSubControllers();
   },
   arrayContentDidChange:function(idx, removedCnt, addedCnt) {
    var subControllers = get(this, "_subControllers"), subControllersToRemove = subControllers.slice(idx, idx + removedCnt);
    forEach(subControllersToRemove, function(subController) {
     if (subController) {
      subController.destroy();
     }
    });
    replace(subControllers, idx, removedCnt, new Array(addedCnt));
    this._super(idx, removedCnt, addedCnt);
   },
   init:function() {
    this._super();
    this.set("_subControllers", Ember.A());
   },
   content:Ember.computed(function() {
    return Ember.A();
   }),
   controllerAt:function(idx, object, controllerClass) {
    var container = get(this, "container"), subControllers = get(this, "_subControllers"), subController = subControllers[idx], factory, fullName;
    if (subController) {
     return subController;
    }
    fullName = "controller:" + controllerClass;
    if (!container.has(fullName)) {
     throw new Ember.Error('Could not resolve itemController: "' + controllerClass + '"');
    }
    subController = container.lookupFactory(fullName).create({
     target:this,
     parentController:get(this, "parentController") || this,
     content:object
    });
    subControllers[idx] = subController;
    return subController;
   },
   _subControllers:null,
   _resetSubControllers:function() {
    var subControllers = get(this, "_subControllers");
    if (subControllers) {
     forEach(subControllers, function(subController) {
      if (subController) {
       subController.destroy();
      }
     });
    }
    this.set("_subControllers", Ember.A());
   }
  });
 })();
 (function() {
  Ember.ObjectController = Ember.ObjectProxy.extend(Ember.ControllerMixin);
 })();
 (function() {})();
 (function() {})();
})();

if (typeof location !== "undefined" && (location.hostname === "localhost" || location.hostname === "127.0.0.1")) {
 Ember.Logger.warn("You are running a production build of Ember on localhost and won't receive detailed error messages. " + "If you want full error messages please use the non-minified build provided on the Ember website.");
}

define("ember", [ "jquery.noconflict" ], function(global) {
 return function() {
  var ret, fn;
  return ret || global.Ember;
 };
}(this));

define("ember.noconflict", [ "jquery.noconflict", "ember" ], function() {
 if (typeof window !== "undefined") {
  return window.Ember;
 }
});

(function($) {
 function safe_add(x, y) {
  var lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
 }
 function bit_rol(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
 }
 function md5_cmn(q, a, b, x, s, t) {
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
 }
 function md5_ff(a, b, c, d, x, s, t) {
  return md5_cmn(b & c | ~b & d, a, b, x, s, t);
 }
 function md5_gg(a, b, c, d, x, s, t) {
  return md5_cmn(b & d | c & ~d, a, b, x, s, t);
 }
 function md5_hh(a, b, c, d, x, s, t) {
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
 }
 function md5_ii(a, b, c, d, x, s, t) {
  return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
 }
 function binl_md5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[(len + 64 >>> 9 << 4) + 14] = len;
  var i, olda, oldb, oldc, oldd, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
  for (i = 0; i < x.length; i += 16) {
   olda = a;
   oldb = b;
   oldc = c;
   oldd = d;
   a = md5_ff(a, b, c, d, x[i], 7, -680876936);
   d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
   c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
   b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
   a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
   d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
   c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
   b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
   a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
   d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
   c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
   b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
   a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
   d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
   c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
   b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
   a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
   d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
   c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
   b = md5_gg(b, c, d, a, x[i], 20, -373897302);
   a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
   d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
   c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
   b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
   a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
   d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
   c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
   b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
   a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
   d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
   c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
   b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
   a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
   d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
   c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
   b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
   a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
   d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
   c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
   b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
   a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
   d = md5_hh(d, a, b, c, x[i], 11, -358537222);
   c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
   b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
   a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
   d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
   c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
   b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
   a = md5_ii(a, b, c, d, x[i], 6, -198630844);
   d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
   c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
   b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
   a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
   d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
   c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
   b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
   a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
   d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
   c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
   b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
   a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
   d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
   c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
   b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
   a = safe_add(a, olda);
   b = safe_add(b, oldb);
   c = safe_add(c, oldc);
   d = safe_add(d, oldd);
  }
  return [ a, b, c, d ];
 }
 function binl2rstr(input) {
  var i, output = "";
  for (i = 0; i < input.length * 32; i += 8) {
   output += String.fromCharCode(input[i >> 5] >>> i % 32 & 255);
  }
  return output;
 }
 function rstr2binl(input) {
  var i, output = [];
  output[(input.length >> 2) - 1] = undefined;
  for (i = 0; i < output.length; i += 1) {
   output[i] = 0;
  }
  for (i = 0; i < input.length * 8; i += 8) {
   output[i >> 5] |= (input.charCodeAt(i / 8) & 255) << i % 32;
  }
  return output;
 }
 function rstr_md5(s) {
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
 }
 function rstr_hmac_md5(key, data) {
  var i, bkey = rstr2binl(key), ipad = [], opad = [], hash;
  ipad[15] = opad[15] = undefined;
  if (bkey.length > 16) {
   bkey = binl_md5(bkey, key.length * 8);
  }
  for (i = 0; i < 16; i += 1) {
   ipad[i] = bkey[i] ^ 909522486;
   opad[i] = bkey[i] ^ 1549556828;
  }
  hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
 }
 function rstr2hex(input) {
  var hex_tab = "0123456789abcdef", output = "", x, i;
  for (i = 0; i < input.length; i += 1) {
   x = input.charCodeAt(i);
   output += hex_tab.charAt(x >>> 4 & 15) + hex_tab.charAt(x & 15);
  }
  return output;
 }
 function str2rstr_utf8(input) {
  return unescape(encodeURIComponent(input));
 }
 function raw_md5(s) {
  return rstr_md5(str2rstr_utf8(s));
 }
 function hex_md5(s) {
  return rstr2hex(raw_md5(s));
 }
 function raw_hmac_md5(k, d) {
  return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d));
 }
 function hex_hmac_md5(k, d) {
  return rstr2hex(raw_hmac_md5(k, d));
 }
 function md5(string, key, raw) {
  if (!key) {
   if (!raw) {
    return hex_md5(string);
   }
   return raw_md5(string);
  }
  if (!raw) {
   return hex_hmac_md5(key, string);
  }
  return raw_hmac_md5(key, string);
 }
 if (typeof define === "function" && define.amd) {
  define("crypto/md5", [], function() {
   return md5;
  });
 } else {
  $.md5 = md5;
 }
})(this);

!function(a, b) {
 function c(a, b) {
  var c, d;
  b = b || {}, a = "raven" + a.substr(0, 1).toUpperCase() + a.substr(1), document.createEvent ? (c = document.createEvent("HTMLEvents"), 
  c.initEvent(a, !0, !0)) :(c = document.createEventObject(), c.eventType = a);
  for (d in b) j(b, d) && (c[d] = b[d]);
  if (document.createEvent) document.dispatchEvent(c); else try {
   document.fireEvent("on" + c.eventType.toLowerCase(), c);
  } catch (e) {}
 }
 function d(a) {
  this.name = "RavenConfigError", this.message = a;
 }
 function e(a) {
  var b = Q.exec(a), c = {}, e = 7;
  try {
   for (;e--; ) c[P[e]] = b[e] || "";
  } catch (f) {
   throw new d("Invalid DSN: " + a);
  }
  if (c.pass) throw new d("Do not specify your private key in the DSN!");
  return c;
 }
 function f(a) {
  return "undefined" == typeof a;
 }
 function g(a) {
  return "function" == typeof a;
 }
 function h(a) {
  return "string" == typeof a;
 }
 function i(a) {
  for (var b in a) return !1;
  return !0;
 }
 function j(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
 }
 function k(a, b) {
  var c, d;
  if (f(a.length)) for (c in a) j(a, c) && b.call(null, c, a[c]); else if (d = a.length) for (c = 0; d > c; c++) b.call(null, c, a[c]);
 }
 function l() {
  J = "?sentry_version=4&sentry_client=raven-js/" + O.VERSION + "&sentry_key=" + H;
 }
 function m(a, b) {
  var d = [];
  a.stack && a.stack.length && k(a.stack, function(a, b) {
   var c = n(b);
   c && d.push(c);
  }), c("handle", {
   stackInfo:a,
   options:b
  }), p(a.name, a.message, a.url, a.lineno, d, b);
 }
 function n(a) {
  if (a.url) {
   var b, c = {
    filename:a.url,
    lineno:a.line,
    colno:a.column,
    "function":a.func || "?"
   }, d = o(a);
   if (d) {
    var e = [ "pre_context", "context_line", "post_context" ];
    for (b = 3; b--; ) c[e[b]] = d[b];
   }
   return c.in_app = !(!M.includePaths.test(c.filename) || /(Raven|TraceKit)\./.test(c["function"]) || /raven\.(min\.)?js$/.test(c.filename)), 
   c;
  }
 }
 function o(a) {
  if (a.context && M.fetchContext) {
   for (var b = a.context, c = ~~(b.length / 2), d = b.length, e = !1; d--; ) if (b[d].length > 300) {
    e = !0;
    break;
   }
   if (e) {
    if (f(a.column)) return;
    return [ [], b[c].substr(a.column, 50), [] ];
   }
   return [ b.slice(0, c), b[c], b.slice(c + 1) ];
  }
 }
 function p(a, b, c, d, e, f) {
  var g, h;
  b += "", ("Error" !== a || b) && (M.ignoreErrors.test(b) || (e && e.length ? (c = e[0].filename || c, e.reverse(), g = {
   frames:e
  }) :c && (g = {
   frames:[ {
    filename:c,
    lineno:d,
    in_app:!0
   } ]
  }), b = r(b, 100), M.ignoreUrls && M.ignoreUrls.test(c) || (!M.whitelistUrls || M.whitelistUrls.test(c)) && (h = d ? b + " at " + d :b, 
  t(q({
   exception:{
    type:a,
    value:b
   },
   stacktrace:g,
   culprit:c,
   message:h
  }, f)))));
 }
 function q(a, b) {
  return b ? (k(b, function(b, c) {
   a[b] = c;
  }), a) :a;
 }
 function r(a, b) {
  return a.length <= b ? a :a.substr(0, b) + "";
 }
 function s() {
  var a = {
   url:document.location.href,
   headers:{
    "User-Agent":navigator.userAgent
   }
  };
  return document.referrer && (a.headers.Referer = document.referrer), a;
 }
 function t(a) {
  v() && (a = q({
   project:I,
   logger:M.logger,
   site:M.site,
   platform:"javascript",
   request:s()
  }, a), a.tags = q(M.tags, a.tags), a.extra = q(M.extra, a.extra), i(a.tags) && delete a.tags, i(a.extra) && delete a.extra, 
  G && (a.user = G), g(M.dataCallback) && (a = M.dataCallback(a)), (!g(M.shouldSendCallback) || M.shouldSendCallback(a)) && (E = a.event_id || (a.event_id = x()), 
  u(a)));
 }
 function u(a) {
  var b = new Image(), d = F + J + "&sentry_data=" + encodeURIComponent(JSON.stringify(a));
  b.onload = function() {
   c("success", {
    data:a,
    src:d
   });
  }, b.onerror = b.onabort = function() {
   c("failure", {
    data:a,
    src:d
   });
  }, b.src = d;
 }
 function v() {
  return L ? F ? !0 :(y("error", "Error: Raven has not been configured."), !1) :!1;
 }
 function w(a) {
  for (var b, c = [], d = 0, e = a.length; e > d; d++) b = a[d], h(b) ? c.push(b.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1")) :b && b.source && c.push(b.source);
  return new RegExp(c.join("|"), "i");
 }
 function x() {
  return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(a) {
   var b = 16 * Math.random() | 0, c = "x" == a ? b :3 & b | 8;
   return c.toString(16);
  });
 }
 function y(b, c) {
  a.console && console[b] && O.debug && console[b](c);
 }
 function z() {
  var b = a.RavenConfig;
  b && O.config(b.dsn, b.config).install();
 }
 var A = {
  remoteFetching:!1,
  collectWindowErrors:!0,
  linesOfContext:7
 }, B = [].slice, C = "?";
 A.wrap = function(a) {
  function b() {
   try {
    return a.apply(this, arguments);
   } catch (b) {
    throw A.report(b), b;
   }
  }
  return b;
 }, A.report = function() {
  function c(a) {
   h(), o.push(a);
  }
  function d(a) {
   for (var b = o.length - 1; b >= 0; --b) o[b] === a && o.splice(b, 1);
  }
  function e() {
   i(), o = [];
  }
  function f(a, b) {
   var c = null;
   if (!b || A.collectWindowErrors) {
    for (var d in o) if (j(o, d)) try {
     o[d].apply(null, [ a ].concat(B.call(arguments, 2)));
    } catch (e) {
     c = e;
    }
    if (c) throw c;
   }
  }
  function g(a, b, c, d, e) {
   var g = null;
   if (r) A.computeStackTrace.augmentStackTraceWithInitialElement(r, b, c, a), k(); else if (e) g = A.computeStackTrace(e), 
   f(g, !0); else {
    var h = {
     url:b,
     line:c,
     column:d
    };
    h.func = A.computeStackTrace.guessFunctionName(h.url, h.line), h.context = A.computeStackTrace.gatherContext(h.url, h.line), 
    g = {
     message:a,
     url:document.location.href,
     stack:[ h ]
    }, f(g, !0);
   }
   return m ? m.apply(this, arguments) :!1;
  }
  function h() {
   n || (m = a.onerror, a.onerror = g, n = !0);
  }
  function i() {
   n && (a.onerror = m, n = !1, m = b);
  }
  function k() {
   var a = r, b = p;
   p = null, r = null, q = null, f.apply(null, [ a, !1 ].concat(b));
  }
  function l(b, c) {
   var d = B.call(arguments, 1);
   if (r) {
    if (q === b) return;
    k();
   }
   var e = A.computeStackTrace(b);
   if (r = e, q = b, p = d, a.setTimeout(function() {
    q === b && k();
   }, e.incomplete ? 2e3 :0), c !== !1) throw b;
  }
  var m, n, o = [], p = null, q = null, r = null;
  return l.subscribe = c, l.unsubscribe = d, l.uninstall = e, l;
 }(), A.computeStackTrace = function() {
  function b(b) {
   if (!A.remoteFetching) return "";
   try {
    var c = function() {
     try {
      return new a.XMLHttpRequest();
     } catch (b) {
      return new a.ActiveXObject("Microsoft.XMLHTTP");
     }
    }, d = c();
    return d.open("GET", b, !1), d.send(""), d.responseText;
   } catch (e) {
    return "";
   }
  }
  function c(a) {
   if (!h(a)) return [];
   if (!j(v, a)) {
    var c = "";
    -1 !== a.indexOf(document.domain) && (c = b(a)), v[a] = c ? c.split("\n") :[];
   }
   return v[a];
  }
  function d(a, b) {
   var d, e = /function ([^(]*)\(([^)]*)\)/, g = /['"]?([0-9A-Za-z$_]+)['"]?\s*[:=]\s*(function|eval|new Function)/, h = "", i = 10, j = c(a);
   if (!j.length) return C;
   for (var k = 0; i > k; ++k) if (h = j[b - k] + h, !f(h)) {
    if (d = g.exec(h)) return d[1];
    if (d = e.exec(h)) return d[1];
   }
   return C;
  }
  function e(a, b) {
   var d = c(a);
   if (!d.length) return null;
   var e = [], g = Math.floor(A.linesOfContext / 2), h = g + A.linesOfContext % 2, i = Math.max(0, b - g - 1), j = Math.min(d.length, b + h - 1);
   b -= 1;
   for (var k = i; j > k; ++k) f(d[k]) || e.push(d[k]);
   return e.length > 0 ? e :null;
  }
  function g(a) {
   return a.replace(/[\-\[\]{}()*+?.,\\\^$|#]/g, "\\$&");
  }
  function i(a) {
   return g(a).replace("<", "(?:<|&lt;)").replace(">", "(?:>|&gt;)").replace("&", "(?:&|&amp;)").replace('"', '(?:"|&quot;)').replace(/\s+/g, "\\s+");
  }
  function k(a, b) {
   for (var d, e, f = 0, g = b.length; g > f; ++f) if ((d = c(b[f])).length && (d = d.join("\n"), e = a.exec(d))) return {
    url:b[f],
    line:d.substring(0, e.index).split("\n").length,
    column:e.index - d.lastIndexOf("\n", e.index) - 1
   };
   return null;
  }
  function l(a, b, d) {
   var e, f = c(b), h = new RegExp("\\b" + g(a) + "\\b");
   return d -= 1, f && f.length > d && (e = h.exec(f[d])) ? e.index :null;
  }
  function m(b) {
   for (var c, d, e, f, h = [ a.location.href ], j = document.getElementsByTagName("script"), l = "" + b, m = /^function(?:\s+([\w$]+))?\s*\(([\w\s,]*)\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/, n = /^function on([\w$]+)\s*\(event\)\s*\{\s*(\S[\s\S]*\S)\s*\}\s*$/, o = 0; o < j.length; ++o) {
    var p = j[o];
    p.src && h.push(p.src);
   }
   if (e = m.exec(l)) {
    var q = e[1] ? "\\s+" + e[1] :"", r = e[2].split(",").join("\\s*,\\s*");
    c = g(e[3]).replace(/;$/, ";?"), d = new RegExp("function" + q + "\\s*\\(\\s*" + r + "\\s*\\)\\s*{\\s*" + c + "\\s*}");
   } else d = new RegExp(g(l).replace(/\s+/g, "\\s+"));
   if (f = k(d, h)) return f;
   if (e = n.exec(l)) {
    var s = e[1];
    if (c = i(e[2]), d = new RegExp("on" + s + "=[\\'\"]\\s*" + c + "\\s*[\\'\"]", "i"), f = k(d, h[0])) return f;
    if (d = new RegExp(c), f = k(d, h)) return f;
   }
   return null;
  }
  function n(a) {
   if (!a.stack) return null;
   for (var b, c, g = /^\s*at (?:((?:\[object object\])?\S+(?: \[as \S+\])?) )?\(?((?:file|https?|chrome-extension):.*?):(\d+)(?::(\d+))?\)?\s*$/i, h = /^\s*(\S*)(?:\((.*?)\))?@((?:file|https?|chrome).*?):(\d+)(?::(\d+))?\s*$/i, i = a.stack.split("\n"), j = [], k = /^(.*) is undefined$/.exec(a.message), m = 0, n = i.length; n > m; ++m) {
    if (b = h.exec(i[m])) c = {
     url:b[3],
     func:b[1] || C,
     args:b[2] ? b[2].split(",") :"",
     line:+b[4],
     column:b[5] ? +b[5] :null
    }; else {
     if (!(b = g.exec(i[m]))) continue;
     c = {
      url:b[2],
      func:b[1] || C,
      line:+b[3],
      column:b[4] ? +b[4] :null
     };
    }
    !c.func && c.line && (c.func = d(c.url, c.line)), c.line && (c.context = e(c.url, c.line)), j.push(c);
   }
   return j.length ? (j[0].line && !j[0].column && k ? j[0].column = l(k[1], j[0].url, j[0].line) :j[0].column || f(a.columnNumber) || (j[0].column = a.columnNumber + 1), 
   {
    name:a.name,
    message:a.message,
    url:document.location.href,
    stack:j
   }) :null;
  }
  function o(a) {
   for (var b, c = a.stacktrace, f = / line (\d+), column (\d+) in (?:<anonymous function: ([^>]+)>|([^\)]+))\((.*)\) in (.*):\s*$/i, g = c.split("\n"), h = [], i = 0, j = g.length; j > i; i += 2) if (b = f.exec(g[i])) {
    var k = {
     line:+b[1],
     column:+b[2],
     func:b[3] || b[4],
     args:b[5] ? b[5].split(",") :[],
     url:b[6]
    };
    if (!k.func && k.line && (k.func = d(k.url, k.line)), k.line) try {
     k.context = e(k.url, k.line);
    } catch (l) {}
    k.context || (k.context = [ g[i + 1] ]), h.push(k);
   }
   return h.length ? {
    name:a.name,
    message:a.message,
    url:document.location.href,
    stack:h
   } :null;
  }
  function p(b) {
   var f = b.message.split("\n");
   if (f.length < 4) return null;
   var g, h, l, m, n = /^\s*Line (\d+) of linked script ((?:file|https?)\S+)(?:: in function (\S+))?\s*$/i, o = /^\s*Line (\d+) of inline#(\d+) script in ((?:file|https?)\S+)(?:: in function (\S+))?\s*$/i, p = /^\s*Line (\d+) of function script\s*$/i, q = [], r = document.getElementsByTagName("script"), s = [];
   for (h in r) j(r, h) && !r[h].src && s.push(r[h]);
   for (h = 2, l = f.length; l > h; h += 2) {
    var t = null;
    if (g = n.exec(f[h])) t = {
     url:g[2],
     func:g[3],
     line:+g[1]
    }; else if (g = o.exec(f[h])) {
     t = {
      url:g[3],
      func:g[4]
     };
     var u = +g[1], v = s[g[2] - 1];
     if (v && (m = c(t.url))) {
      m = m.join("\n");
      var w = m.indexOf(v.innerText);
      w >= 0 && (t.line = u + m.substring(0, w).split("\n").length);
     }
    } else if (g = p.exec(f[h])) {
     var x = a.location.href.replace(/#.*$/, ""), y = g[1], z = new RegExp(i(f[h + 1]));
     m = k(z, [ x ]), t = {
      url:x,
      line:m ? m.line :y,
      func:""
     };
    }
    if (t) {
     t.func || (t.func = d(t.url, t.line));
     var A = e(t.url, t.line), B = A ? A[Math.floor(A.length / 2)] :null;
     t.context = A && B.replace(/^\s*/, "") === f[h + 1].replace(/^\s*/, "") ? A :[ f[h + 1] ], q.push(t);
    }
   }
   return q.length ? {
    name:b.name,
    message:f[0],
    url:document.location.href,
    stack:q
   } :null;
  }
  function q(a, b, c, f) {
   var g = {
    url:b,
    line:c
   };
   if (g.url && g.line) {
    a.incomplete = !1, g.func || (g.func = d(g.url, g.line)), g.context || (g.context = e(g.url, g.line));
    var h = / '([^']+)' /.exec(f);
    if (h && (g.column = l(h[1], g.url, g.line)), a.stack.length > 0 && a.stack[0].url === g.url) {
     if (a.stack[0].line === g.line) return !1;
     if (!a.stack[0].line && a.stack[0].func === g.func) return a.stack[0].line = g.line, a.stack[0].context = g.context, !1;
    }
    return a.stack.unshift(g), a.partial = !0, !0;
   }
   return a.incomplete = !0, !1;
  }
  function r(a, b) {
   for (var c, e, f, g = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i, h = [], i = {}, j = !1, k = r.caller; k && !j; k = k.caller) if (k !== s && k !== A.report) {
    if (e = {
     url:null,
     func:C,
     line:null,
     column:null
    }, k.name ? e.func = k.name :(c = g.exec(k.toString())) && (e.func = c[1]), f = m(k)) {
     e.url = f.url, e.line = f.line, e.func === C && (e.func = d(e.url, e.line));
     var n = / '([^']+)' /.exec(a.message || a.description);
     n && (e.column = l(n[1], f.url, f.line));
    }
    i["" + k] ? j = !0 :i["" + k] = !0, h.push(e);
   }
   b && h.splice(0, b);
   var o = {
    name:a.name,
    message:a.message,
    url:document.location.href,
    stack:h
   };
   return q(o, a.sourceURL || a.fileName, a.line || a.lineNumber, a.message || a.description), o;
  }
  function s(a, b) {
   var c = null;
   b = null == b ? 0 :+b;
   try {
    if (c = o(a)) return c;
   } catch (d) {
    if (u) throw d;
   }
   try {
    if (c = n(a)) return c;
   } catch (d) {
    if (u) throw d;
   }
   try {
    if (c = p(a)) return c;
   } catch (d) {
    if (u) throw d;
   }
   try {
    if (c = r(a, b + 1)) return c;
   } catch (d) {
    if (u) throw d;
   }
   return {};
  }
  function t(a) {
   a = (null == a ? 0 :+a) + 1;
   try {
    throw new Error();
   } catch (b) {
    return s(b, a + 1);
   }
  }
  var u = !1, v = {};
  return s.augmentStackTraceWithInitialElement = q, s.guessFunctionName = d, s.gatherContext = e, s.ofCaller = t, s;
 }();
 var D, E, F, G, H, I, J, K = a.Raven, L = !(!a.JSON || !a.JSON.stringify), M = {
  logger:"javascript",
  ignoreErrors:[],
  ignoreUrls:[],
  whitelistUrls:[],
  includePaths:[],
  collectWindowErrors:!0,
  tags:{},
  extra:{}
 }, N = !1, O = {
  VERSION:"1.1.16",
  debug:!0,
  noConflict:function() {
   return a.Raven = K, O;
  },
  config:function(a, b) {
   if (F) return y("error", "Error: Raven has already been configured"), O;
   if (!a) return O;
   var c = e(a), d = c.path.lastIndexOf("/"), f = c.path.substr(1, d);
   return b && k(b, function(a, b) {
    M[a] = b;
   }), M.ignoreErrors.push("Script error."), M.ignoreErrors.push("Script error"), M.ignoreErrors.push("Javascript error: Script error on line 0"), 
   M.ignoreErrors.push("Javascript error: Script error. on line 0"), M.ignoreErrors = w(M.ignoreErrors), M.ignoreUrls = M.ignoreUrls.length ? w(M.ignoreUrls) :!1, 
   M.whitelistUrls = M.whitelistUrls.length ? w(M.whitelistUrls) :!1, M.includePaths = w(M.includePaths), H = c.user, I = c.path.substr(d + 1), 
   F = "//" + c.host + (c.port ? ":" + c.port :"") + "/" + f + "api/" + I + "/store/", c.protocol && (F = c.protocol + ":" + F), 
   M.fetchContext && (A.remoteFetching = !0), M.linesOfContext && (A.linesOfContext = M.linesOfContext), A.collectWindowErrors = !!M.collectWindowErrors, 
   l(), O;
  },
  install:function() {
   return v() && !N && (A.report.subscribe(m), N = !0), O;
  },
  context:function(a, c, d) {
   return g(a) && (d = c || [], c = a, a = b), O.wrap(a, c).apply(this, d);
  },
  wrap:function(a, c) {
   function d() {
    for (var b = [], d = arguments.length, e = !a || a && a.deep !== !1; d--; ) b[d] = e ? O.wrap(a, arguments[d]) :arguments[d];
    try {
     return c.apply(this, b);
    } catch (f) {
     throw O.captureException(f, a), f;
    }
   }
   if (f(c) && !g(a)) return a;
   if (g(a) && (c = a, a = b), !g(c)) return c;
   if (c.__raven__) return c;
   for (var e in c) j(c, e) && (d[e] = c[e]);
   return d.__raven__ = !0, d.__inner__ = c, d;
  },
  uninstall:function() {
   return A.report.uninstall(), N = !1, O;
  },
  captureException:function(a, b) {
   if (!(a instanceof Error)) return O.captureMessage(a, b);
   D = a;
   try {
    A.report(a, b);
   } catch (c) {
    if (a !== c) throw c;
   }
   return O;
  },
  captureMessage:function(a, b) {
   return t(q({
    message:a + ""
   }, b)), O;
  },
  setUserContext:function(a) {
   return G = a, O;
  },
  setExtraContext:function(a) {
   return M.extra = a || {}, O;
  },
  setTagsContext:function(a) {
   return M.tags = a || {}, O;
  },
  lastException:function() {
   return D;
  },
  lastEventId:function() {
   return E;
  }
 };
 O.setUser = O.setUserContext;
 var P = "source protocol user pass host port path".split(" "), Q = /^(?:(\w+):)?\/\/(\w+)(:\w+)?@([\w\.-]+)(?::(\d+))?(\/.*)/;
 d.prototype = new Error(), d.prototype.constructor = d, z(), a.Raven = O, "function" == typeof define && define.amd && define("raven", [], function() {
  return O;
 });
}(this);

define("raven.hapyak", [ "raven", "configuration" ], function(Raven, configuration, undefined) {
 var i, whitelistUrls;
 var sentry = {
  feature:"https://7ae3a37b0be24a8987d6f58a1dec1fe3@app.getsentry.com/4690",
  production:"https://5c1ea37229604fc0b6af526a44921e84@app.getsentry.com/2286",
  staging:"https://93681531623544f9bc54b3c606e30dc9@app.getsentry.com/2287"
 }, sentryEndpoint = sentry[hapyak && hapyak.environment];
 if (sentryEndpoint) {
  whitelistUrls = [ /hapyak\.com/, /d2qrdklrsxowl2\.cloudfront\.net/, /d3bo0fj9s1pd3n\.cloudfront\.net/, /dxwi20mo6v954\.cloudfront\.net/ ];
  if (configuration.sentry.whitelistUrls) {
   for (i = 0; i < configuration.sentry.whitelistUrls.length; i++) {
    whitelistUrls.push(new RegExp(configuration.sentry.whitelistUrls[i].replace(/\./g, "\\.")));
   }
  }
  Raven.config(sentryEndpoint, {
   collectWindowErrors:false,
   whitelistUrls:whitelistUrls,
   includePaths:whitelistUrls.concat([ new RegExp(window.location.host.replace(/\./g, "\\.")) ]),
   ignoreErrors:[ "top.GLOBALS", "originalCreateNotification", "canvas.contentDocument", "MyApp_RemoveAllHighlights", "http://tt.epicplay.com", "Can't find variable: ZiteReader", "jigsaw is not defined", "ComboSearch is not defined", "http://loading.retry.widdit.com/", "atomicFindClose", "fb_xd_fragment", "bmi_SafeAddOnload", "EBCallBackMessageReceived", "conduitPage" ],
   ignoreUrls:[ /graph\.facebook\.com/i, /connect\.facebook\.net\/en_US\/all\.js/i, /eatdifferent\.com\.woopra-ns\.com/i, /static\.woopra\.com\/js\/woopra\.js/i, /extensions\//i, /^chrome:\/\//i, /127\.0\.0\.1:4001\/isrunning/i, /webappstoolbarba\.texthelp\.com\//i, /metrics\.itunes\.apple\.com\.edgesuite\.net\//i ],
   tags:{
    hapyak_version:hapyak && hapyak.VERSION || 0
   }
  }).install();
 }
 return Raven;
});

define("cookie", [], function() {
 var cookie = {
  set:function(key, value, days) {
   var expires, date;
   if (days) {
    date = new Date();
    date.setTime(date.getTime() + days * 864e5);
    expires = "; expires=" + date.toGMTString();
   } else {
    expires = "";
   }
   document.cookie = key + "=" + value + expires + "; path=/";
  },
  get:function(key) {
   var identifier = key + "=", cookies = document.cookie.split(";");
   for (var i = 0; i < cookies.length; i++) {
    var cookie = cookies[i];
    while (cookie.charAt(0) === " ") {
     cookie = cookie.substring(1, cookie.length);
    }
    if (cookie.indexOf(identifier) === 0) {
     return cookie.substring(identifier.length, cookie.length);
    }
   }
   return null;
  },
  remove:function(key) {
   this.set(key, "", -1);
  }
 };
 if (typeof window !== "undefined") {
  window.HapyakCookie = cookie;
 }
 return cookie;
});

define("utils.uuid", [], function() {
 var hex = function() {
  var a = [], i;
  for (i = 0; i < 16; i++) {
   a.push(i.toString(16));
  }
  return a;
 }();
 return function() {
  function randInt() {
   return Math.floor(4294967296 * Math.random());
  }
  function calcUUID(w1, w2, w3, w4, version) {
   var uuid, data, i, j, k, r, rnd;
   uuid = new Array(36);
   data = [ w1 & 4294967295, w2 & 4294905855 | (version || 4) << 12, w3 & 1073741823 | 2147483648, w4 & 4294967295 ];
   for (i = 0, k = 0; i < 4; i++) {
    rnd = data[i];
    for (j = 0; j < 8; j++) {
     if (k === 8 || k === 13 || k === 18 || k === 23) {
      uuid[k++] = "-";
     }
     r = rnd >>> 28 & 15;
     rnd = (rnd & 268435455) << 4;
     uuid[k++] = hex[r];
    }
   }
   return uuid.join("");
  }
  return calcUUID(randInt(), randInt(), randInt(), randInt(), 4);
 };
});

(function() {
 function n(n, t, e) {
  e = (e || 0) - 1;
  for (var r = n ? n.length :0; ++e < r; ) if (n[e] === t) return e;
  return -1;
 }
 function t(t, e) {
  var r = typeof e;
  if (t = t.l, "boolean" == r || null == e) return t[e] ? 0 :-1;
  "number" != r && "string" != r && (r = "object");
  var u = "number" == r ? e :m + e;
  return t = (t = t[r]) && t[u], "object" == r ? t && -1 < n(t, e) ? 0 :-1 :t ? 0 :-1;
 }
 function e(n) {
  var t = this.l, e = typeof n;
  if ("boolean" == e || null == n) t[n] = true; else {
   "number" != e && "string" != e && (e = "object");
   var r = "number" == e ? n :m + n, t = t[e] || (t[e] = {});
   "object" == e ? (t[r] || (t[r] = [])).push(n) :t[r] = true;
  }
 }
 function r(n) {
  return n.charCodeAt(0);
 }
 function u(n, t) {
  for (var e = n.m, r = t.m, u = -1, o = e.length; ++u < o; ) {
   var i = e[u], a = r[u];
   if (i !== a) {
    if (i > a || typeof i == "undefined") return 1;
    if (i < a || typeof a == "undefined") return -1;
   }
  }
  return n.n - t.n;
 }
 function o(n) {
  var t = -1, r = n.length, u = n[0], o = n[r / 2 | 0], i = n[r - 1];
  if (u && typeof u == "object" && o && typeof o == "object" && i && typeof i == "object") return false;
  for (u = f(), u["false"] = u["null"] = u["true"] = u.undefined = false, o = f(), o.k = n, o.l = u, o.push = e; ++t < r; ) o.push(n[t]);
  return o;
 }
 function i(n) {
  return "\\" + U[n];
 }
 function a() {
  return h.pop() || [];
 }
 function f() {
  return g.pop() || {
   k:null,
   l:null,
   m:null,
   "false":false,
   n:0,
   "null":false,
   number:null,
   object:null,
   push:null,
   string:null,
   "true":false,
   undefined:false,
   o:null
  };
 }
 function l(n) {
  n.length = 0, h.length < _ && h.push(n);
 }
 function c(n) {
  var t = n.l;
  t && c(t), n.k = n.l = n.m = n.object = n.number = n.string = n.o = null, g.length < _ && g.push(n);
 }
 function p(n, t, e) {
  t || (t = 0), typeof e == "undefined" && (e = n ? n.length :0);
  var r = -1;
  e = e - t || 0;
  for (var u = Array(0 > e ? 0 :e); ++r < e; ) u[r] = n[t + r];
  return u;
 }
 function s(e) {
  function h(n, t, e) {
   if (!n || !V[typeof n]) return n;
   t = t && typeof e == "undefined" ? t :tt(t, e, 3);
   for (var r = -1, u = V[typeof n] && Fe(n), o = u ? u.length :0; ++r < o && (e = u[r], false !== t(n[e], e, n)); ) ;
   return n;
  }
  function g(n, t, e) {
   var r;
   if (!n || !V[typeof n]) return n;
   t = t && typeof e == "undefined" ? t :tt(t, e, 3);
   for (r in n) if (false === t(n[r], r, n)) break;
   return n;
  }
  function _(n, t, e) {
   var r, u = n, o = u;
   if (!u) return o;
   for (var i = arguments, a = 0, f = typeof e == "number" ? 2 :i.length; ++a < f; ) if ((u = i[a]) && V[typeof u]) for (var l = -1, c = V[typeof u] && Fe(u), p = c ? c.length :0; ++l < p; ) r = c[l], 
   "undefined" == typeof o[r] && (o[r] = u[r]);
   return o;
  }
  function U(n, t, e) {
   var r, u = n, o = u;
   if (!u) return o;
   var i = arguments, a = 0, f = typeof e == "number" ? 2 :i.length;
   if (3 < f && "function" == typeof i[f - 2]) var l = tt(i[--f - 1], i[f--], 2); else 2 < f && "function" == typeof i[f - 1] && (l = i[--f]);
   for (;++a < f; ) if ((u = i[a]) && V[typeof u]) for (var c = -1, p = V[typeof u] && Fe(u), s = p ? p.length :0; ++c < s; ) r = p[c], 
   o[r] = l ? l(o[r], u[r]) :u[r];
   return o;
  }
  function H(n) {
   var t, e = [];
   if (!n || !V[typeof n]) return e;
   for (t in n) me.call(n, t) && e.push(t);
   return e;
  }
  function J(n) {
   return n && typeof n == "object" && !Te(n) && me.call(n, "__wrapped__") ? n :new Q(n);
  }
  function Q(n, t) {
   this.__chain__ = !!t, this.__wrapped__ = n;
  }
  function X(n) {
   function t() {
    if (r) {
     var n = p(r);
     be.apply(n, arguments);
    }
    if (this instanceof t) {
     var o = nt(e.prototype), n = e.apply(o, n || arguments);
     return wt(n) ? n :o;
    }
    return e.apply(u, n || arguments);
   }
   var e = n[0], r = n[2], u = n[4];
   return $e(t, n), t;
  }
  function Z(n, t, e, r, u) {
   if (e) {
    var o = e(n);
    if (typeof o != "undefined") return o;
   }
   if (!wt(n)) return n;
   var i = ce.call(n);
   if (!K[i]) return n;
   var f = Ae[i];
   switch (i) {
   case T:
   case F:
    return new f(+n);

   case W:
   case P:
    return new f(n);

   case z:
    return o = f(n.source, C.exec(n)), o.lastIndex = n.lastIndex, o;
   }
   if (i = Te(n), t) {
    var c = !r;
    r || (r = a()), u || (u = a());
    for (var s = r.length; s--; ) if (r[s] == n) return u[s];
    o = i ? f(n.length) :{};
   } else o = i ? p(n) :U({}, n);
   return i && (me.call(n, "index") && (o.index = n.index), me.call(n, "input") && (o.input = n.input)), t ? (r.push(n), u.push(o), 
   (i ? St :h)(n, function(n, i) {
    o[i] = Z(n, t, e, r, u);
   }), c && (l(r), l(u)), o) :o;
  }
  function nt(n) {
   return wt(n) ? ke(n) :{};
  }
  function tt(n, t, e) {
   if (typeof n != "function") return Ut;
   if (typeof t == "undefined" || !("prototype" in n)) return n;
   var r = n.__bindData__;
   if (typeof r == "undefined" && (De.funcNames && (r = !n.name), r = r || !De.funcDecomp, !r)) {
    var u = ge.call(n);
    De.funcNames || (r = !O.test(u)), r || (r = E.test(u), $e(n, r));
   }
   if (false === r || true !== r && 1 & r[1]) return n;
   switch (e) {
   case 1:
    return function(e) {
     return n.call(t, e);
    };

   case 2:
    return function(e, r) {
     return n.call(t, e, r);
    };

   case 3:
    return function(e, r, u) {
     return n.call(t, e, r, u);
    };

   case 4:
    return function(e, r, u, o) {
     return n.call(t, e, r, u, o);
    };
   }
   return Mt(n, t);
  }
  function et(n) {
   function t() {
    var n = f ? i :this;
    if (u) {
     var h = p(u);
     be.apply(h, arguments);
    }
    return (o || c) && (h || (h = p(arguments)), o && be.apply(h, o), c && h.length < a) ? (r |= 16, et([ e, s ? r :-4 & r, h, null, i, a ])) :(h || (h = arguments), 
    l && (e = n[v]), this instanceof t ? (n = nt(e.prototype), h = e.apply(n, h), wt(h) ? h :n) :e.apply(n, h));
   }
   var e = n[0], r = n[1], u = n[2], o = n[3], i = n[4], a = n[5], f = 1 & r, l = 2 & r, c = 4 & r, s = 8 & r, v = e;
   return $e(t, n), t;
  }
  function rt(e, r) {
   var u = -1, i = st(), a = e ? e.length :0, f = a >= b && i === n, l = [];
   if (f) {
    var p = o(r);
    p ? (i = t, r = p) :f = false;
   }
   for (;++u < a; ) p = e[u], 0 > i(r, p) && l.push(p);
   return f && c(r), l;
  }
  function ut(n, t, e, r) {
   r = (r || 0) - 1;
   for (var u = n ? n.length :0, o = []; ++r < u; ) {
    var i = n[r];
    if (i && typeof i == "object" && typeof i.length == "number" && (Te(i) || yt(i))) {
     t || (i = ut(i, t, e));
     var a = -1, f = i.length, l = o.length;
     for (o.length += f; ++a < f; ) o[l++] = i[a];
    } else e || o.push(i);
   }
   return o;
  }
  function ot(n, t, e, r, u, o) {
   if (e) {
    var i = e(n, t);
    if (typeof i != "undefined") return !!i;
   }
   if (n === t) return 0 !== n || 1 / n == 1 / t;
   if (n === n && !(n && V[typeof n] || t && V[typeof t])) return false;
   if (null == n || null == t) return n === t;
   var f = ce.call(n), c = ce.call(t);
   if (f == D && (f = q), c == D && (c = q), f != c) return false;
   switch (f) {
   case T:
   case F:
    return +n == +t;

   case W:
    return n != +n ? t != +t :0 == n ? 1 / n == 1 / t :n == +t;

   case z:
   case P:
    return n == oe(t);
   }
   if (c = f == $, !c) {
    var p = me.call(n, "__wrapped__"), s = me.call(t, "__wrapped__");
    if (p || s) return ot(p ? n.__wrapped__ :n, s ? t.__wrapped__ :t, e, r, u, o);
    if (f != q) return false;
    if (f = n.constructor, p = t.constructor, f != p && !(dt(f) && f instanceof f && dt(p) && p instanceof p) && "constructor" in n && "constructor" in t) return false;
   }
   for (f = !u, u || (u = a()), o || (o = a()), p = u.length; p--; ) if (u[p] == n) return o[p] == t;
   var v = 0, i = true;
   if (u.push(n), o.push(t), c) {
    if (p = n.length, v = t.length, (i = v == p) || r) for (;v--; ) if (c = p, s = t[v], r) for (;c-- && !(i = ot(n[c], s, e, r, u, o)); ) ; else if (!(i = ot(n[v], s, e, r, u, o))) break;
   } else g(t, function(t, a, f) {
    return me.call(f, a) ? (v++, i = me.call(n, a) && ot(n[a], t, e, r, u, o)) :void 0;
   }), i && !r && g(n, function(n, t, e) {
    return me.call(e, t) ? i = -1 < --v :void 0;
   });
   return u.pop(), o.pop(), f && (l(u), l(o)), i;
  }
  function it(n, t, e, r, u) {
   (Te(t) ? St :h)(t, function(t, o) {
    var i, a, f = t, l = n[o];
    if (t && ((a = Te(t)) || Pe(t))) {
     for (f = r.length; f--; ) if (i = r[f] == t) {
      l = u[f];
      break;
     }
     if (!i) {
      var c;
      e && (f = e(l, t), c = typeof f != "undefined") && (l = f), c || (l = a ? Te(l) ? l :[] :Pe(l) ? l :{}), r.push(t), u.push(l), 
      c || it(l, t, e, r, u);
     }
    } else e && (f = e(l, t), typeof f == "undefined" && (f = t)), typeof f != "undefined" && (l = f);
    n[o] = l;
   });
  }
  function at(n, t) {
   return n + he(Re() * (t - n + 1));
  }
  function ft(e, r, u) {
   var i = -1, f = st(), p = e ? e.length :0, s = [], v = !r && p >= b && f === n, h = u || v ? a() :s;
   for (v && (h = o(h), f = t); ++i < p; ) {
    var g = e[i], y = u ? u(g, i, e) :g;
    (r ? !i || h[h.length - 1] !== y :0 > f(h, y)) && ((u || v) && h.push(y), s.push(g));
   }
   return v ? (l(h.k), c(h)) :u && l(h), s;
  }
  function lt(n) {
   return function(t, e, r) {
    var u = {};
    e = J.createCallback(e, r, 3), r = -1;
    var o = t ? t.length :0;
    if (typeof o == "number") for (;++r < o; ) {
     var i = t[r];
     n(u, i, e(i, r, t), t);
    } else h(t, function(t, r, o) {
     n(u, t, e(t, r, o), o);
    });
    return u;
   };
  }
  function ct(n, t, e, r, u, o) {
   var i = 1 & t, a = 4 & t, f = 16 & t, l = 32 & t;
   if (!(2 & t || dt(n))) throw new ie();
   f && !e.length && (t &= -17, f = e = false), l && !r.length && (t &= -33, l = r = false);
   var c = n && n.__bindData__;
   return c && true !== c ? (c = p(c), c[2] && (c[2] = p(c[2])), c[3] && (c[3] = p(c[3])), !i || 1 & c[1] || (c[4] = u), !i && 1 & c[1] && (t |= 8), 
   !a || 4 & c[1] || (c[5] = o), f && be.apply(c[2] || (c[2] = []), e), l && we.apply(c[3] || (c[3] = []), r), c[1] |= t, ct.apply(null, c)) :(1 == t || 17 === t ? X :et)([ n, t, e, r, u, o ]);
  }
  function pt(n) {
   return Be[n];
  }
  function st() {
   var t = (t = J.indexOf) === Wt ? n :t;
   return t;
  }
  function vt(n) {
   return typeof n == "function" && pe.test(n);
  }
  function ht(n) {
   var t, e;
   return n && ce.call(n) == q && (t = n.constructor, !dt(t) || t instanceof t) ? (g(n, function(n, t) {
    e = t;
   }), typeof e == "undefined" || me.call(n, e)) :false;
  }
  function gt(n) {
   return We[n];
  }
  function yt(n) {
   return n && typeof n == "object" && typeof n.length == "number" && ce.call(n) == D || false;
  }
  function mt(n, t, e) {
   var r = Fe(n), u = r.length;
   for (t = tt(t, e, 3); u-- && (e = r[u], false !== t(n[e], e, n)); ) ;
   return n;
  }
  function bt(n) {
   var t = [];
   return g(n, function(n, e) {
    dt(n) && t.push(e);
   }), t.sort();
  }
  function _t(n) {
   for (var t = -1, e = Fe(n), r = e.length, u = {}; ++t < r; ) {
    var o = e[t];
    u[n[o]] = o;
   }
   return u;
  }
  function dt(n) {
   return typeof n == "function";
  }
  function wt(n) {
   return !(!n || !V[typeof n]);
  }
  function jt(n) {
   return typeof n == "number" || n && typeof n == "object" && ce.call(n) == W || false;
  }
  function kt(n) {
   return typeof n == "string" || n && typeof n == "object" && ce.call(n) == P || false;
  }
  function xt(n) {
   for (var t = -1, e = Fe(n), r = e.length, u = Xt(r); ++t < r; ) u[t] = n[e[t]];
   return u;
  }
  function Ct(n, t, e) {
   var r = -1, u = st(), o = n ? n.length :0, i = false;
   return e = (0 > e ? Ie(0, o + e) :e) || 0, Te(n) ? i = -1 < u(n, t, e) :typeof o == "number" ? i = -1 < (kt(n) ? n.indexOf(t, e) :u(n, t, e)) :h(n, function(n) {
    return ++r < e ? void 0 :!(i = n === t);
   }), i;
  }
  function Ot(n, t, e) {
   var r = true;
   t = J.createCallback(t, e, 3), e = -1;
   var u = n ? n.length :0;
   if (typeof u == "number") for (;++e < u && (r = !!t(n[e], e, n)); ) ; else h(n, function(n, e, u) {
    return r = !!t(n, e, u);
   });
   return r;
  }
  function Nt(n, t, e) {
   var r = [];
   t = J.createCallback(t, e, 3), e = -1;
   var u = n ? n.length :0;
   if (typeof u == "number") for (;++e < u; ) {
    var o = n[e];
    t(o, e, n) && r.push(o);
   } else h(n, function(n, e, u) {
    t(n, e, u) && r.push(n);
   });
   return r;
  }
  function It(n, t, e) {
   t = J.createCallback(t, e, 3), e = -1;
   var r = n ? n.length :0;
   if (typeof r != "number") {
    var u;
    return h(n, function(n, e, r) {
     return t(n, e, r) ? (u = n, false) :void 0;
    }), u;
   }
   for (;++e < r; ) {
    var o = n[e];
    if (t(o, e, n)) return o;
   }
  }
  function St(n, t, e) {
   var r = -1, u = n ? n.length :0;
   if (t = t && typeof e == "undefined" ? t :tt(t, e, 3), typeof u == "number") for (;++r < u && false !== t(n[r], r, n); ) ; else h(n, t);
   return n;
  }
  function Et(n, t, e) {
   var r = n ? n.length :0;
   if (t = t && typeof e == "undefined" ? t :tt(t, e, 3), typeof r == "number") for (;r-- && false !== t(n[r], r, n); ) ; else {
    var u = Fe(n), r = u.length;
    h(n, function(n, e, o) {
     return e = u ? u[--r] :--r, t(o[e], e, o);
    });
   }
   return n;
  }
  function Rt(n, t, e) {
   var r = -1, u = n ? n.length :0;
   if (t = J.createCallback(t, e, 3), typeof u == "number") for (var o = Xt(u); ++r < u; ) o[r] = t(n[r], r, n); else o = [], 
   h(n, function(n, e, u) {
    o[++r] = t(n, e, u);
   });
   return o;
  }
  function At(n, t, e) {
   var u = -1 / 0, o = u;
   if (typeof t != "function" && e && e[t] === n && (t = null), null == t && Te(n)) {
    e = -1;
    for (var i = n.length; ++e < i; ) {
     var a = n[e];
     a > o && (o = a);
    }
   } else t = null == t && kt(n) ? r :J.createCallback(t, e, 3), St(n, function(n, e, r) {
    e = t(n, e, r), e > u && (u = e, o = n);
   });
   return o;
  }
  function Dt(n, t, e, r) {
   if (!n) return e;
   var u = 3 > arguments.length;
   t = J.createCallback(t, r, 4);
   var o = -1, i = n.length;
   if (typeof i == "number") for (u && (e = n[++o]); ++o < i; ) e = t(e, n[o], o, n); else h(n, function(n, r, o) {
    e = u ? (u = false, n) :t(e, n, r, o);
   });
   return e;
  }
  function $t(n, t, e, r) {
   var u = 3 > arguments.length;
   return t = J.createCallback(t, r, 4), Et(n, function(n, r, o) {
    e = u ? (u = false, n) :t(e, n, r, o);
   }), e;
  }
  function Tt(n) {
   var t = -1, e = n ? n.length :0, r = Xt(typeof e == "number" ? e :0);
   return St(n, function(n) {
    var e = at(0, ++t);
    r[t] = r[e], r[e] = n;
   }), r;
  }
  function Ft(n, t, e) {
   var r;
   t = J.createCallback(t, e, 3), e = -1;
   var u = n ? n.length :0;
   if (typeof u == "number") for (;++e < u && !(r = t(n[e], e, n)); ) ; else h(n, function(n, e, u) {
    return !(r = t(n, e, u));
   });
   return !!r;
  }
  function Bt(n, t, e) {
   var r = 0, u = n ? n.length :0;
   if (typeof t != "number" && null != t) {
    var o = -1;
    for (t = J.createCallback(t, e, 3); ++o < u && t(n[o], o, n); ) r++;
   } else if (r = t, null == r || e) return n ? n[0] :v;
   return p(n, 0, Se(Ie(0, r), u));
  }
  function Wt(t, e, r) {
   if (typeof r == "number") {
    var u = t ? t.length :0;
    r = 0 > r ? Ie(0, u + r) :r || 0;
   } else if (r) return r = zt(t, e), t[r] === e ? r :-1;
   return n(t, e, r);
  }
  function qt(n, t, e) {
   if (typeof t != "number" && null != t) {
    var r = 0, u = -1, o = n ? n.length :0;
    for (t = J.createCallback(t, e, 3); ++u < o && t(n[u], u, n); ) r++;
   } else r = null == t || e ? 1 :Ie(0, t);
   return p(n, r);
  }
  function zt(n, t, e, r) {
   var u = 0, o = n ? n.length :u;
   for (e = e ? J.createCallback(e, r, 1) :Ut, t = e(t); u < o; ) r = u + o >>> 1, e(n[r]) < t ? u = r + 1 :o = r;
   return u;
  }
  function Pt(n, t, e, r) {
   return typeof t != "boolean" && null != t && (r = e, e = typeof t != "function" && r && r[t] === n ? null :t, t = false), 
   null != e && (e = J.createCallback(e, r, 3)), ft(n, t, e);
  }
  function Kt() {
   for (var n = 1 < arguments.length ? arguments :arguments[0], t = -1, e = n ? At(Ve(n, "length")) :0, r = Xt(0 > e ? 0 :e); ++t < e; ) r[t] = Ve(n, t);
   return r;
  }
  function Lt(n, t) {
   var e = -1, r = n ? n.length :0, u = {};
   for (t || !r || Te(n[0]) || (t = []); ++e < r; ) {
    var o = n[e];
    t ? u[o] = t[e] :o && (u[o[0]] = o[1]);
   }
   return u;
  }
  function Mt(n, t) {
   return 2 < arguments.length ? ct(n, 17, p(arguments, 2), null, t) :ct(n, 1, null, null, t);
  }
  function Vt(n, t, e) {
   function r() {
    c && ve(c), i = c = p = v, (g || h !== t) && (s = Ue(), a = n.apply(l, o), c || i || (o = l = null));
   }
   function u() {
    var e = t - (Ue() - f);
    0 < e ? c = _e(u, e) :(i && ve(i), e = p, i = c = p = v, e && (s = Ue(), a = n.apply(l, o), c || i || (o = l = null)));
   }
   var o, i, a, f, l, c, p, s = 0, h = false, g = true;
   if (!dt(n)) throw new ie();
   if (t = Ie(0, t) || 0, true === e) var y = true, g = false; else wt(e) && (y = e.leading, h = "maxWait" in e && (Ie(t, e.maxWait) || 0), 
   g = "trailing" in e ? e.trailing :g);
   return function() {
    if (o = arguments, f = Ue(), l = this, p = g && (c || !y), false === h) var e = y && !c; else {
     i || y || (s = f);
     var v = h - (f - s), m = 0 >= v;
     m ? (i && (i = ve(i)), s = f, a = n.apply(l, o)) :i || (i = _e(r, v));
    }
    return m && c ? c = ve(c) :c || t === h || (c = _e(u, t)), e && (m = true, a = n.apply(l, o)), !m || c || i || (o = l = null), 
    a;
   };
  }
  function Ut(n) {
   return n;
  }
  function Gt(n, t, e) {
   var r = true, u = t && bt(t);
   t && (e || u.length) || (null == e && (e = t), o = Q, t = n, n = J, u = bt(t)), false === e ? r = false :wt(e) && "chain" in e && (r = e.chain);
   var o = n, i = dt(o);
   St(u, function(e) {
    var u = n[e] = t[e];
    i && (o.prototype[e] = function() {
     var t = this.__chain__, e = this.__wrapped__, i = [ e ];
     if (be.apply(i, arguments), i = u.apply(n, i), r || t) {
      if (e === i && wt(i)) return this;
      i = new o(i), i.__chain__ = t;
     }
     return i;
    });
   });
  }
  function Ht() {}
  function Jt(n) {
   return function(t) {
    return t[n];
   };
  }
  function Qt() {
   return this.__wrapped__;
  }
  e = e ? Y.defaults(G.Object(), e, Y.pick(G, A)) :G;
  var Xt = e.Array, Yt = e.Boolean, Zt = e.Date, ne = e.Function, te = e.Math, ee = e.Number, re = e.Object, ue = e.RegExp, oe = e.String, ie = e.TypeError, ae = [], fe = re.prototype, le = e._, ce = fe.toString, pe = ue("^" + oe(ce).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$"), se = te.ceil, ve = e.clearTimeout, he = te.floor, ge = ne.prototype.toString, ye = vt(ye = re.getPrototypeOf) && ye, me = fe.hasOwnProperty, be = ae.push, _e = e.setTimeout, de = ae.splice, we = ae.unshift, je = function() {
   try {
    var n = {}, t = vt(t = re.defineProperty) && t, e = t(n, n, n) && t;
   } catch (r) {}
   return e;
  }(), ke = vt(ke = re.create) && ke, xe = vt(xe = Xt.isArray) && xe, Ce = e.isFinite, Oe = e.isNaN, Ne = vt(Ne = re.keys) && Ne, Ie = te.max, Se = te.min, Ee = e.parseInt, Re = te.random, Ae = {};
  Ae[$] = Xt, Ae[T] = Yt, Ae[F] = Zt, Ae[B] = ne, Ae[q] = re, Ae[W] = ee, Ae[z] = ue, Ae[P] = oe, Q.prototype = J.prototype;
  var De = J.support = {};
  De.funcDecomp = !vt(e.a) && E.test(s), De.funcNames = typeof ne.name == "string", J.templateSettings = {
   escape:/<%-([\s\S]+?)%>/g,
   evaluate:/<%([\s\S]+?)%>/g,
   interpolate:N,
   variable:"",
   imports:{
    _:J
   }
  }, ke || (nt = function() {
   function n() {}
   return function(t) {
    if (wt(t)) {
     n.prototype = t;
     var r = new n();
     n.prototype = null;
    }
    return r || e.Object();
   };
  }());
  var $e = je ? function(n, t) {
   M.value = t, je(n, "__bindData__", M);
  } :Ht, Te = xe || function(n) {
   return n && typeof n == "object" && typeof n.length == "number" && ce.call(n) == $ || false;
  }, Fe = Ne ? function(n) {
   return wt(n) ? Ne(n) :[];
  } :H, Be = {
   "&":"&amp;",
   "<":"&lt;",
   ">":"&gt;",
   '"':"&quot;",
   "'":"&#39;"
  }, We = _t(Be), qe = ue("(" + Fe(We).join("|") + ")", "g"), ze = ue("[" + Fe(Be).join("") + "]", "g"), Pe = ye ? function(n) {
   if (!n || ce.call(n) != q) return false;
   var t = n.valueOf, e = vt(t) && (e = ye(t)) && ye(e);
   return e ? n == e || ye(n) == e :ht(n);
  } :ht, Ke = lt(function(n, t, e) {
   me.call(n, e) ? n[e]++ :n[e] = 1;
  }), Le = lt(function(n, t, e) {
   (me.call(n, e) ? n[e] :n[e] = []).push(t);
  }), Me = lt(function(n, t, e) {
   n[e] = t;
  }), Ve = Rt, Ue = vt(Ue = Zt.now) && Ue || function() {
   return new Zt().getTime();
  }, Ge = 8 == Ee(d + "08") ? Ee :function(n, t) {
   return Ee(kt(n) ? n.replace(I, "") :n, t || 0);
  };
  return J.after = function(n, t) {
   if (!dt(t)) throw new ie();
   return function() {
    return 1 > --n ? t.apply(this, arguments) :void 0;
   };
  }, J.assign = U, J.at = function(n) {
   for (var t = arguments, e = -1, r = ut(t, true, false, 1), t = t[2] && t[2][t[1]] === n ? 1 :r.length, u = Xt(t); ++e < t; ) u[e] = n[r[e]];
   return u;
  }, J.bind = Mt, J.bindAll = function(n) {
   for (var t = 1 < arguments.length ? ut(arguments, true, false, 1) :bt(n), e = -1, r = t.length; ++e < r; ) {
    var u = t[e];
    n[u] = ct(n[u], 1, null, null, n);
   }
   return n;
  }, J.bindKey = function(n, t) {
   return 2 < arguments.length ? ct(t, 19, p(arguments, 2), null, n) :ct(t, 3, null, null, n);
  }, J.chain = function(n) {
   return n = new Q(n), n.__chain__ = true, n;
  }, J.compact = function(n) {
   for (var t = -1, e = n ? n.length :0, r = []; ++t < e; ) {
    var u = n[t];
    u && r.push(u);
   }
   return r;
  }, J.compose = function() {
   for (var n = arguments, t = n.length; t--; ) if (!dt(n[t])) throw new ie();
   return function() {
    for (var t = arguments, e = n.length; e--; ) t = [ n[e].apply(this, t) ];
    return t[0];
   };
  }, J.constant = function(n) {
   return function() {
    return n;
   };
  }, J.countBy = Ke, J.create = function(n, t) {
   var e = nt(n);
   return t ? U(e, t) :e;
  }, J.createCallback = function(n, t, e) {
   var r = typeof n;
   if (null == n || "function" == r) return tt(n, t, e);
   if ("object" != r) return Jt(n);
   var u = Fe(n), o = u[0], i = n[o];
   return 1 != u.length || i !== i || wt(i) ? function(t) {
    for (var e = u.length, r = false; e-- && (r = ot(t[u[e]], n[u[e]], null, true)); ) ;
    return r;
   } :function(n) {
    return n = n[o], i === n && (0 !== i || 1 / i == 1 / n);
   };
  }, J.curry = function(n, t) {
   return t = typeof t == "number" ? t :+t || n.length, ct(n, 4, null, null, null, t);
  }, J.debounce = Vt, J.defaults = _, J.defer = function(n) {
   if (!dt(n)) throw new ie();
   var t = p(arguments, 1);
   return _e(function() {
    n.apply(v, t);
   }, 1);
  }, J.delay = function(n, t) {
   if (!dt(n)) throw new ie();
   var e = p(arguments, 2);
   return _e(function() {
    n.apply(v, e);
   }, t);
  }, J.difference = function(n) {
   return rt(n, ut(arguments, true, true, 1));
  }, J.filter = Nt, J.flatten = function(n, t, e, r) {
   return typeof t != "boolean" && null != t && (r = e, e = typeof t != "function" && r && r[t] === n ? null :t, t = false), 
   null != e && (n = Rt(n, e, r)), ut(n, t);
  }, J.forEach = St, J.forEachRight = Et, J.forIn = g, J.forInRight = function(n, t, e) {
   var r = [];
   g(n, function(n, t) {
    r.push(t, n);
   });
   var u = r.length;
   for (t = tt(t, e, 3); u-- && false !== t(r[u--], r[u], n); ) ;
   return n;
  }, J.forOwn = h, J.forOwnRight = mt, J.functions = bt, J.groupBy = Le, J.indexBy = Me, J.initial = function(n, t, e) {
   var r = 0, u = n ? n.length :0;
   if (typeof t != "number" && null != t) {
    var o = u;
    for (t = J.createCallback(t, e, 3); o-- && t(n[o], o, n); ) r++;
   } else r = null == t || e ? 1 :t || r;
   return p(n, 0, Se(Ie(0, u - r), u));
  }, J.intersection = function() {
   for (var e = [], r = -1, u = arguments.length, i = a(), f = st(), p = f === n, s = a(); ++r < u; ) {
    var v = arguments[r];
    (Te(v) || yt(v)) && (e.push(v), i.push(p && v.length >= b && o(r ? e[r] :s)));
   }
   var p = e[0], h = -1, g = p ? p.length :0, y = [];
   n:for (;++h < g; ) {
    var m = i[0], v = p[h];
    if (0 > (m ? t(m, v) :f(s, v))) {
     for (r = u, (m || s).push(v); --r; ) if (m = i[r], 0 > (m ? t(m, v) :f(e[r], v))) continue n;
     y.push(v);
    }
   }
   for (;u--; ) (m = i[u]) && c(m);
   return l(i), l(s), y;
  }, J.invert = _t, J.invoke = function(n, t) {
   var e = p(arguments, 2), r = -1, u = typeof t == "function", o = n ? n.length :0, i = Xt(typeof o == "number" ? o :0);
   return St(n, function(n) {
    i[++r] = (u ? t :n[t]).apply(n, e);
   }), i;
  }, J.keys = Fe, J.map = Rt, J.mapValues = function(n, t, e) {
   var r = {};
   return t = J.createCallback(t, e, 3), h(n, function(n, e, u) {
    r[e] = t(n, e, u);
   }), r;
  }, J.max = At, J.memoize = function(n, t) {
   function e() {
    var r = e.cache, u = t ? t.apply(this, arguments) :m + arguments[0];
    return me.call(r, u) ? r[u] :r[u] = n.apply(this, arguments);
   }
   if (!dt(n)) throw new ie();
   return e.cache = {}, e;
  }, J.merge = function(n) {
   var t = arguments, e = 2;
   if (!wt(n)) return n;
   if ("number" != typeof t[2] && (e = t.length), 3 < e && "function" == typeof t[e - 2]) var r = tt(t[--e - 1], t[e--], 2); else 2 < e && "function" == typeof t[e - 1] && (r = t[--e]);
   for (var t = p(arguments, 1, e), u = -1, o = a(), i = a(); ++u < e; ) it(n, t[u], r, o, i);
   return l(o), l(i), n;
  }, J.min = function(n, t, e) {
   var u = 1 / 0, o = u;
   if (typeof t != "function" && e && e[t] === n && (t = null), null == t && Te(n)) {
    e = -1;
    for (var i = n.length; ++e < i; ) {
     var a = n[e];
     a < o && (o = a);
    }
   } else t = null == t && kt(n) ? r :J.createCallback(t, e, 3), St(n, function(n, e, r) {
    e = t(n, e, r), e < u && (u = e, o = n);
   });
   return o;
  }, J.omit = function(n, t, e) {
   var r = {};
   if (typeof t != "function") {
    var u = [];
    g(n, function(n, t) {
     u.push(t);
    });
    for (var u = rt(u, ut(arguments, true, false, 1)), o = -1, i = u.length; ++o < i; ) {
     var a = u[o];
     r[a] = n[a];
    }
   } else t = J.createCallback(t, e, 3), g(n, function(n, e, u) {
    t(n, e, u) || (r[e] = n);
   });
   return r;
  }, J.once = function(n) {
   var t, e;
   if (!dt(n)) throw new ie();
   return function() {
    return t ? e :(t = true, e = n.apply(this, arguments), n = null, e);
   };
  }, J.pairs = function(n) {
   for (var t = -1, e = Fe(n), r = e.length, u = Xt(r); ++t < r; ) {
    var o = e[t];
    u[t] = [ o, n[o] ];
   }
   return u;
  }, J.partial = function(n) {
   return ct(n, 16, p(arguments, 1));
  }, J.partialRight = function(n) {
   return ct(n, 32, null, p(arguments, 1));
  }, J.pick = function(n, t, e) {
   var r = {};
   if (typeof t != "function") for (var u = -1, o = ut(arguments, true, false, 1), i = wt(n) ? o.length :0; ++u < i; ) {
    var a = o[u];
    a in n && (r[a] = n[a]);
   } else t = J.createCallback(t, e, 3), g(n, function(n, e, u) {
    t(n, e, u) && (r[e] = n);
   });
   return r;
  }, J.pluck = Ve, J.property = Jt, J.pull = function(n) {
   for (var t = arguments, e = 0, r = t.length, u = n ? n.length :0; ++e < r; ) for (var o = -1, i = t[e]; ++o < u; ) n[o] === i && (de.call(n, o--, 1), 
   u--);
   return n;
  }, J.range = function(n, t, e) {
   n = +n || 0, e = typeof e == "number" ? e :+e || 1, null == t && (t = n, n = 0);
   var r = -1;
   t = Ie(0, se((t - n) / (e || 1)));
   for (var u = Xt(t); ++r < t; ) u[r] = n, n += e;
   return u;
  }, J.reject = function(n, t, e) {
   return t = J.createCallback(t, e, 3), Nt(n, function(n, e, r) {
    return !t(n, e, r);
   });
  }, J.remove = function(n, t, e) {
   var r = -1, u = n ? n.length :0, o = [];
   for (t = J.createCallback(t, e, 3); ++r < u; ) e = n[r], t(e, r, n) && (o.push(e), de.call(n, r--, 1), u--);
   return o;
  }, J.rest = qt, J.shuffle = Tt, J.sortBy = function(n, t, e) {
   var r = -1, o = Te(t), i = n ? n.length :0, p = Xt(typeof i == "number" ? i :0);
   for (o || (t = J.createCallback(t, e, 3)), St(n, function(n, e, u) {
    var i = p[++r] = f();
    o ? i.m = Rt(t, function(t) {
     return n[t];
    }) :(i.m = a())[0] = t(n, e, u), i.n = r, i.o = n;
   }), i = p.length, p.sort(u); i--; ) n = p[i], p[i] = n.o, o || l(n.m), c(n);
   return p;
  }, J.tap = function(n, t) {
   return t(n), n;
  }, J.throttle = function(n, t, e) {
   var r = true, u = true;
   if (!dt(n)) throw new ie();
   return false === e ? r = false :wt(e) && (r = "leading" in e ? e.leading :r, u = "trailing" in e ? e.trailing :u), L.leading = r, 
   L.maxWait = t, L.trailing = u, Vt(n, t, L);
  }, J.times = function(n, t, e) {
   n = -1 < (n = +n) ? n :0;
   var r = -1, u = Xt(n);
   for (t = tt(t, e, 1); ++r < n; ) u[r] = t(r);
   return u;
  }, J.toArray = function(n) {
   return n && typeof n.length == "number" ? p(n) :xt(n);
  }, J.transform = function(n, t, e, r) {
   var u = Te(n);
   if (null == e) if (u) e = []; else {
    var o = n && n.constructor;
    e = nt(o && o.prototype);
   }
   return t && (t = J.createCallback(t, r, 4), (u ? St :h)(n, function(n, r, u) {
    return t(e, n, r, u);
   })), e;
  }, J.union = function() {
   return ft(ut(arguments, true, true));
  }, J.uniq = Pt, J.values = xt, J.where = Nt, J.without = function(n) {
   return rt(n, p(arguments, 1));
  }, J.wrap = function(n, t) {
   return ct(t, 16, [ n ]);
  }, J.xor = function() {
   for (var n = -1, t = arguments.length; ++n < t; ) {
    var e = arguments[n];
    if (Te(e) || yt(e)) var r = r ? ft(rt(r, e).concat(rt(e, r))) :e;
   }
   return r || [];
  }, J.zip = Kt, J.zipObject = Lt, J.collect = Rt, J.drop = qt, J.each = St, J.eachRight = Et, J.extend = U, J.methods = bt, 
  J.object = Lt, J.select = Nt, J.tail = qt, J.unique = Pt, J.unzip = Kt, Gt(J), J.clone = function(n, t, e, r) {
   return typeof t != "boolean" && null != t && (r = e, e = t, t = false), Z(n, t, typeof e == "function" && tt(e, r, 1));
  }, J.cloneDeep = function(n, t, e) {
   return Z(n, true, typeof t == "function" && tt(t, e, 1));
  }, J.contains = Ct, J.escape = function(n) {
   return null == n ? "" :oe(n).replace(ze, pt);
  }, J.every = Ot, J.find = It, J.findIndex = function(n, t, e) {
   var r = -1, u = n ? n.length :0;
   for (t = J.createCallback(t, e, 3); ++r < u; ) if (t(n[r], r, n)) return r;
   return -1;
  }, J.findKey = function(n, t, e) {
   var r;
   return t = J.createCallback(t, e, 3), h(n, function(n, e, u) {
    return t(n, e, u) ? (r = e, false) :void 0;
   }), r;
  }, J.findLast = function(n, t, e) {
   var r;
   return t = J.createCallback(t, e, 3), Et(n, function(n, e, u) {
    return t(n, e, u) ? (r = n, false) :void 0;
   }), r;
  }, J.findLastIndex = function(n, t, e) {
   var r = n ? n.length :0;
   for (t = J.createCallback(t, e, 3); r--; ) if (t(n[r], r, n)) return r;
   return -1;
  }, J.findLastKey = function(n, t, e) {
   var r;
   return t = J.createCallback(t, e, 3), mt(n, function(n, e, u) {
    return t(n, e, u) ? (r = e, false) :void 0;
   }), r;
  }, J.has = function(n, t) {
   return n ? me.call(n, t) :false;
  }, J.identity = Ut, J.indexOf = Wt, J.isArguments = yt, J.isArray = Te, J.isBoolean = function(n) {
   return true === n || false === n || n && typeof n == "object" && ce.call(n) == T || false;
  }, J.isDate = function(n) {
   return n && typeof n == "object" && ce.call(n) == F || false;
  }, J.isElement = function(n) {
   return n && 1 === n.nodeType || false;
  }, J.isEmpty = function(n) {
   var t = true;
   if (!n) return t;
   var e = ce.call(n), r = n.length;
   return e == $ || e == P || e == D || e == q && typeof r == "number" && dt(n.splice) ? !r :(h(n, function() {
    return t = false;
   }), t);
  }, J.isEqual = function(n, t, e, r) {
   return ot(n, t, typeof e == "function" && tt(e, r, 2));
  }, J.isFinite = function(n) {
   return Ce(n) && !Oe(parseFloat(n));
  }, J.isFunction = dt, J.isNaN = function(n) {
   return jt(n) && n != +n;
  }, J.isNull = function(n) {
   return null === n;
  }, J.isNumber = jt, J.isObject = wt, J.isPlainObject = Pe, J.isRegExp = function(n) {
   return n && typeof n == "object" && ce.call(n) == z || false;
  }, J.isString = kt, J.isUndefined = function(n) {
   return typeof n == "undefined";
  }, J.lastIndexOf = function(n, t, e) {
   var r = n ? n.length :0;
   for (typeof e == "number" && (r = (0 > e ? Ie(0, r + e) :Se(e, r - 1)) + 1); r--; ) if (n[r] === t) return r;
   return -1;
  }, J.mixin = Gt, J.noConflict = function() {
   return e._ = le, this;
  }, J.noop = Ht, J.now = Ue, J.parseInt = Ge, J.random = function(n, t, e) {
   var r = null == n, u = null == t;
   return null == e && (typeof n == "boolean" && u ? (e = n, n = 1) :u || typeof t != "boolean" || (e = t, u = true)), r && u && (t = 1), 
   n = +n || 0, u ? (t = n, n = 0) :t = +t || 0, e || n % 1 || t % 1 ? (e = Re(), Se(n + e * (t - n + parseFloat("1e-" + ((e + "").length - 1))), t)) :at(n, t);
  }, J.reduce = Dt, J.reduceRight = $t, J.result = function(n, t) {
   if (n) {
    var e = n[t];
    return dt(e) ? n[t]() :e;
   }
  }, J.runInContext = s, J.size = function(n) {
   var t = n ? n.length :0;
   return typeof t == "number" ? t :Fe(n).length;
  }, J.some = Ft, J.sortedIndex = zt, J.template = function(n, t, e) {
   var r = J.templateSettings;
   n = oe(n || ""), e = _({}, e, r);
   var u, o = _({}, e.imports, r.imports), r = Fe(o), o = xt(o), a = 0, f = e.interpolate || S, l = "__p+='", f = ue((e.escape || S).source + "|" + f.source + "|" + (f === N ? x :S).source + "|" + (e.evaluate || S).source + "|$", "g");
   n.replace(f, function(t, e, r, o, f, c) {
    return r || (r = o), l += n.slice(a, c).replace(R, i), e && (l += "'+__e(" + e + ")+'"), f && (u = true, l += "';" + f + ";\n__p+='"), 
    r && (l += "'+((__t=(" + r + "))==null?'':__t)+'"), a = c + t.length, t;
   }), l += "';", f = e = e.variable, f || (e = "obj", l = "with(" + e + "){" + l + "}"), l = (u ? l.replace(w, "") :l).replace(j, "$1").replace(k, "$1;"), 
   l = "function(" + e + "){" + (f ? "" :e + "||(" + e + "={});") + "var __t,__p='',__e=_.escape" + (u ? ",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}" :";") + l + "return __p}";
   try {
    var c = ne(r, "return " + l).apply(v, o);
   } catch (p) {
    throw p.source = l, p;
   }
   return t ? c(t) :(c.source = l, c);
  }, J.unescape = function(n) {
   return null == n ? "" :oe(n).replace(qe, gt);
  }, J.uniqueId = function(n) {
   var t = ++y;
   return oe(null == n ? "" :n) + t;
  }, J.all = Ot, J.any = Ft, J.detect = It, J.findWhere = It, J.foldl = Dt, J.foldr = $t, J.include = Ct, J.inject = Dt, Gt(function() {
   var n = {};
   return h(J, function(t, e) {
    J.prototype[e] || (n[e] = t);
   }), n;
  }(), false), J.first = Bt, J.last = function(n, t, e) {
   var r = 0, u = n ? n.length :0;
   if (typeof t != "number" && null != t) {
    var o = u;
    for (t = J.createCallback(t, e, 3); o-- && t(n[o], o, n); ) r++;
   } else if (r = t, null == r || e) return n ? n[u - 1] :v;
   return p(n, Ie(0, u - r));
  }, J.sample = function(n, t, e) {
   return n && typeof n.length != "number" && (n = xt(n)), null == t || e ? n ? n[at(0, n.length - 1)] :v :(n = Tt(n), n.length = Se(Ie(0, t), n.length), 
   n);
  }, J.take = Bt, J.head = Bt, h(J, function(n, t) {
   var e = "sample" !== t;
   J.prototype[t] || (J.prototype[t] = function(t, r) {
    var u = this.__chain__, o = n(this.__wrapped__, t, r);
    return u || null != t && (!r || e && typeof t == "function") ? new Q(o, u) :o;
   });
  }), J.VERSION = "2.4.1", J.prototype.chain = function() {
   return this.__chain__ = true, this;
  }, J.prototype.toString = function() {
   return oe(this.__wrapped__);
  }, J.prototype.value = Qt, J.prototype.valueOf = Qt, St([ "join", "pop", "shift" ], function(n) {
   var t = ae[n];
   J.prototype[n] = function() {
    var n = this.__chain__, e = t.apply(this.__wrapped__, arguments);
    return n ? new Q(e, n) :e;
   };
  }), St([ "push", "reverse", "sort", "unshift" ], function(n) {
   var t = ae[n];
   J.prototype[n] = function() {
    return t.apply(this.__wrapped__, arguments), this;
   };
  }), St([ "concat", "slice", "splice" ], function(n) {
   var t = ae[n];
   J.prototype[n] = function() {
    return new Q(t.apply(this.__wrapped__, arguments), this.__chain__);
   };
  }), J;
 }
 var v, h = [], g = [], y = 0, m = +new Date() + "", b = 75, _ = 40, d = " 	\f\n\r\u2028\u2029", w = /\b__p\+='';/g, j = /\b(__p\+=)''\+/g, k = /(__e\(.*?\)|\b__t\))\+'';/g, x = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, C = /\w*$/, O = /^\s*function[ \n\r\t]+\w/, N = /<%=([\s\S]+?)%>/g, I = RegExp("^[" + d + "]*0+(?=.$)"), S = /($^)/, E = /\bthis\b/, R = /['\n\r\t\u2028\u2029\\]/g, A = "Array Boolean Date Function Math Number Object RegExp String _ attachEvent clearTimeout isFinite isNaN parseInt setTimeout".split(" "), D = "[object Arguments]", $ = "[object Array]", T = "[object Boolean]", F = "[object Date]", B = "[object Function]", W = "[object Number]", q = "[object Object]", z = "[object RegExp]", P = "[object String]", K = {};
 K[B] = false, K[D] = K[$] = K[T] = K[F] = K[W] = K[q] = K[z] = K[P] = true;
 var L = {
  leading:false,
  maxWait:0,
  trailing:false
 }, M = {
  configurable:false,
  enumerable:false,
  value:null,
  writable:false
 }, V = {
  "boolean":false,
  "function":true,
  object:true,
  number:false,
  string:false,
  undefined:false
 }, U = {
  "\\":"\\",
  "'":"'",
  "\n":"n",
  "\r":"r",
  "	":"t",
  "\u2028":"u2028",
  "\u2029":"u2029"
 }, G = V[typeof window] && window || this, H = V[typeof exports] && exports && !exports.nodeType && exports, J = V[typeof module] && module && !module.nodeType && module, Q = J && J.exports === H && H, X = V[typeof global] && global;
 !X || X.global !== X && X.window !== X || (G = X);
 var Y = s();
 typeof define == "function" && typeof define.amd == "object" && define.amd ? (G._ = Y, define("lodash", [], function() {
  return Y;
 })) :H && J ? Q ? (J.exports = Y)._ = Y :H._ = Y :G._ = Y;
}).call(this);

define("lodash.noconflict", [ "lodash" ], function(_) {
 return _.noConflict();
});

define("utils.omitinvalid", [ "lodash.noconflict" ], function(_) {
 function isInvalid(property) {
  return !_.isBoolean(property) && !_.isNumber(property) && _.isEmpty(property);
 }
 return function(properties) {
  return _.omit(properties, isInvalid);
 };
});

define("utils.embed", [ "module", "lodash.noconflict", "configuration" ], function(module, _, configuration, undefined) {
 var cssUrlRegex = /^(?:https?\:\/|\/)\/(?:[a-z]\.|[a-z][a-z0-9-]{0,61}[a-z0-9]\.)*?[\w\d\.\/_-]+\.css(?:\?[^?]*)?$/i, cssUrlHeightRegex = /_([0-9]+)\.css/i, isIOS = navigator.userAgent.match(/iP(od|ad|hone)/), moduleConfig = module.config();
 return {
  dotget:function(obj, desc, d) {
   var value;
   if (obj && desc) {
    var arr = desc.split(".");
    while (obj && arr.length) {
     obj = obj[arr.shift()];
    }
    value = obj;
   }
   return value !== undefined ? value :d;
  },
  controlStyle:function(injectCss, nativePlayer) {
   var controlBarHeight = 59, controlStyle, controlStyleHeight, controlType, assetMap;
   controlStyle = moduleConfig.controlStyle || this.dotget(configuration, "player.viewer.controlStyle") || "bottom";
   controlType = controlStyle;
   assetMap = {
    overlay:"/css/generated/control_overlay.css",
    light_bottom:"/css/generated/control_light_bottom.css",
    "default":"/css/generated/control_bottom.css"
   };
   if (isIOS && nativePlayer) {
    controlStyle = controlType = "overlay";
   }
   if (!moduleConfig.edit || moduleConfig.external) {
    if (controlStyle === "overlay") {
     controlBarHeight = isIOS ? 37 :0;
    } else if (controlStyle === "light_bottom") {
     controlBarHeight = 37;
    } else if (controlStyle && controlStyle.match(cssUrlRegex)) {
     controlType = "custom";
     controlStyleHeight = controlStyle.match(cssUrlHeightRegex);
     if (_.isArray(controlStyleHeight) && controlStyleHeight.length === 2) {
      controlBarHeight = +controlStyleHeight[1];
     }
    } else {
     controlType = "default";
    }
    if (moduleConfig.controlBarHeight !== undefined) {
     controlBarHeight = moduleConfig.controlBarHeight;
    } else {
     controlBarHeight = this.dotget(configuration, "player.viewer.controlBarHeight", controlBarHeight);
    }
   } else {
    controlType = "default";
   }
   if (injectCss) {
    if (controlType === "custom") {
     hapyak.asset.css(controlStyle);
    } else {
     hapyak.asset.css(hapyak.assets + assetMap[controlType]);
    }
   }
   return controlBarHeight;
  },
  getQueryParams:function(url, keysStartingWith) {
   var queryParams = {}, qPos = url && url.indexOf("?");
   if (qPos !== undefined && qPos !== -1) {
    url.substr(qPos + 1).split("&").forEach(function(param) {
     var parts = param.split("="), key = parts[0];
     if (param && keysStartingWith === undefined || key.indexOf(keysStartingWith) === 0) {
      if (keysStartingWith) {
       key = key.replace(keysStartingWith, "");
      }
      queryParams[key] = decodeURIComponent(parts[1].replace(/\+/g, "%20"));
     }
    });
   }
   return queryParams;
  },
  shortDate:function(value, timeFormat) {
   var hours, minutes, ampm, output;
   if (!value) {
    return;
   }
   if (!(value instanceof Date)) {
    value = new Date(value);
   }
   output = value.getMonth() + 1 + "/" + value.getDate() + "/" + value.getFullYear();
   if (typeof timeFormat !== "undefined" && (+timeFormat === 24 || !timeFormat)) {
    output += " " + value.getHours() + ":" + value.getMinutes();
   } else if (typeof timeFormat !== "undefined") {
    hours = value.getHours() % 12;
    minutes = value.getMinutes();
    hours = hours ? hours :12;
    minutes = minutes < 10 ? "0" + minutes :minutes;
    ampm = value.getHours() < 12 ? "AM" :"PM";
    output += " " + hours + ":" + minutes + " " + ampm;
   }
   return output;
  }
 };
});

define("analytics", [ "require", "module", "configuration", "utils.embed", "lodash.noconflict" ], function(require, module, configuration, utils, _) {
 var integrations = utils.dotget(configuration, "analytics.modules") || [ "analytics.mixpanel" ], moduleConfig = module.config(), isIframe = moduleConfig.iframed, isLogging = moduleConfig.logLevel === "metrics";
 function logMethod() {
  if (!arguments.length || !isLogging) {
   return;
  }
  var args = Array.prototype.slice.call(arguments, 0), eventName = args[1], properties = args[2];
  if (_.isString(args[0])) {
   args[0] = "HapyakAnalytics." + args[0] + "()";
  }
  require([ "logging" ], function(logging) {
   logging.dev.apply(this, eventName && properties ? [ args[0], eventName, properties ] :args);
  });
 }
 function HapyakAnalyticsIntegration() {
  this.identify = function() {};
  this.track = function() {
   throw new Error('HapyakAnalyticsIntegration requires "track" function: (eventName, properties, options, callback)');
  };
  this.log = function() {
   logMethod.apply(this, arguments);
  };
 }
 function HapyakAnalytics() {
  var registered = {};
  function multiplex() {
   var args = Array.prototype.slice.call(arguments, 0);
   if (!args.length || !_.isString(args[0])) {
    return;
   }
   var methodName = args[0];
   _.each(integrations, function(moduleName) {
    require([ moduleName ], function(integration) {
     if (integration instanceof HapyakAnalyticsIntegration && _.isFunction(integration[methodName])) {
      integration[methodName].apply(integration, args.slice(1));
     }
    });
   });
  }
  this.register = function(properties) {
   _.extend(registered, properties);
  };
  this.unregister = function(propertyName) {
   registered = _.omit(registered, [ propertyName ]);
  };
  this.identify = function(userId, traits, options, callback) {
   multiplex.call(this, "identify", userId, traits, options, callback);
   if (_.isFunction(callback)) {
    callback();
   }
  };
  this.track = function(eventName, properties, options, callback) {
   var postMessageWindow = isIframe ? window.parent :window, extended = _.extend({}, properties, registered);
   multiplex.call(this, "track", eventName, extended, options, callback);
   if (postMessageWindow && _.isFunction(postMessageWindow.postMessage)) {
    postMessageWindow.postMessage(JSON.stringify({
     context:"hapyak-tracking",
     event:eventName,
     properties:extended
    }), "*");
   }
   if (_.isFunction(callback)) {
    callback();
   }
  };
  this.on = function(methodName, callback) {
   logMethod("on", methodName);
   if (_.isFunction(callback)) {
    callback();
   }
  };
  this.ready = function(callback) {
   logMethod("ready");
   if (_.isFunction(callback)) {
    callback();
   }
  };
  this.eventMatchesFilter = function(filter, eventName, properties) {
   if (filter === true) {
    return true;
   } else {
    var expr = filter[eventName];
    return expr === true || _.isObject(expr) && _.isEqual(expr, _.pick(properties, _.keys(expr)));
   }
  };
  this.shouldTrack = function(filter, eventName, properties) {
   if (filter) {
    if (filter.include && !this.eventMatchesFilter(filter.include, eventName, properties)) {
     return false;
    }
    if (filter.exclude && this.eventMatchesFilter(filter.exclude, eventName, properties)) {
     return false;
    }
   }
   return true;
  };
 }
 HapyakAnalytics.prototype.integration = HapyakAnalyticsIntegration;
 return new HapyakAnalytics();
});

define("logging", [ "require", "module", "configuration", "raven.hapyak", "cookie", "utils.uuid", "utils.omitinvalid", "lodash.noconflict", "analytics" ], function(require, module, configuration, Raven, cookie, uuid, omitInvalid, _, analytics) {
 var logging = {
  log:function() {
   if (arguments.length && window.console && window.console.log) {
    var args = [].slice.apply(arguments);
    args[0] = "hapyak: " + args[0];
    if (!!window.console.log.apply) {
     window.console.log.apply(window.console, args);
    } else {
     window.console.log(args[0]);
    }
   }
  },
  info:function() {
   if (arguments.length && window.console && window.console.info) {
    var args = [].slice.apply(arguments);
    args[0] = "hapyak (i): " + args[0];
    if (!!window.console.info.apply) {
     window.console.info.apply(window.console, args);
    } else {
     window.console.info(args[0]);
    }
   }
  },
  error:function() {
   if (arguments.length && window.console && window.console.error) {
    var args = [].slice.apply(arguments);
    args[0] = "hapyak (e): " + args[0];
    if (!!window.console.error.apply) {
     window.console.error.apply(window.console, args);
    } else {
     window.console.error(args[0]);
    }
   }
  },
  warn:function() {
   if (arguments.length && window.console && window.console.warn) {
    var args = [].slice.apply(arguments);
    args[0] = "hapyak (w): " + args[0];
    if (!!window.console.warn.apply) {
     window.console.warn.apply(window.console, args);
    } else {
     window.console.warn(args[0]);
    }
   }
  },
  trace:function() {
   if (arguments.length && window.console && window.console.trace) {
    var args = [].slice.apply(arguments);
    args[0] = "hapyak (t): " + args[0];
    if (!!window.console.trace.apply) {
     window.console.trace.apply(window.console, args);
    } else {
     window.console.trace(args[0]);
    }
   }
  },
  debug:function() {
   if (arguments.length && window.console && window.console.debug) {
    var args = [].slice.apply(arguments);
    args[0] = "hapyak (d): " + args[0];
    if (!!window.console.debug.apply) {
     window.console.debug.apply(window.console, args);
    } else {
     window.console.debug(args[0]);
    }
   }
  },
  dev:function() {
   if (module.config().environment !== "dev") {
    return;
   }
   if (arguments.length && window.console && window.console.info) {
    var args = [].slice.apply(arguments);
    args[0] = "hapyak (!): " + args[0];
    if (!!window.console.info.apply) {
     window.console.info.apply(window.console, args);
    } else {
     window.console.info(args[0]);
    }
   }
  },
  captureException:function(err) {
   Raven.captureException(err);
  },
  captureMessage:function(message) {
   logging.warn(message);
   Raven.captureMessage(message);
  },
  logLevels:[ "trace", "metrics", "debug", "info", "warn", "error" ]
 };
 if (typeof window !== "undefined") {
  window.haplog = logging;
 }
 var logLevel = logging.logLevels.indexOf(module.config().logLevel);
 logging.logLevel = logLevel;
 logging.identify = function(user) {
  analytics.identify(user);
 };
 logging.register = function(properties) {
  analytics.register(properties);
 };
 logging.registerPartnerProperties = function(properties, prefix) {
  var bigQueryPartnerData, prefixedProperties;
  if (properties) {
   prefixedProperties = {};
   bigQueryPartnerData = {
    excludeKeys:[],
    "Partner Data":[]
   };
   prefix = prefix || "Partner / ";
   _.each(properties, function(value, key) {
    if (value && key !== "cdn" && key !== "tracking" && key !== "context") {
     if (_.isObject(value)) {
      logging.registerPartnerProperties(value, prefix + key + ".");
     } else {
      prefixedProperties[prefix + key] = value;
      bigQueryPartnerData.excludeKeys.push(prefix + key);
      bigQueryPartnerData["Partner Data"].push({
       key:String(key),
       value:String(value)
      });
     }
    }
   });
   logging.register(omitInvalid(bigQueryPartnerData));
   logging.register(prefixedProperties);
  }
 };
 logging.unregister = function(propertyName) {
  analytics.unregister(propertyName);
 };
 logging.track = function(name, properties, callback) {
  var psid = cookie.get("hapyak_psid");
  if (!psid) {
   psid = uuid().replace(/\-/g, "");
  }
  cookie.set("hapyak_psid", psid, 1 / 48);
  logging.register({
   Session:psid
  });
  analytics.track(name, properties, undefined, callback);
 };
 var currentVideo = null, currentTrack = null, player = null, reportTimeEvery = 0, lastTimeReport = 0, nextTimeReport = 0, streamStarted = false, lastTrackingEvent, lastTrackingData, lastTrackingTime = 0;
 logging.tracking = {
  startContext:function(p) {
   logging.register(p);
  },
  startPageContext:function(page) {
   logging.tracking.startContext({
    Page:page
   });
  },
  endPageContext:function() {
   logging.tracking.endContext([ "Page" ]);
  },
  startUserContext:function(user) {
   logging.tracking.startContext({
    "User ID":user.get("id"),
    Username:user.get("username")
   });
  },
  startProjectContext:function(project) {
   var trackingData = {
    "Project ID":project.get("id"),
    "Project Title":project.get("title")
   }, tags = project.get("tags"), templates = project.get("templates");
   if (tags) {
    trackingData["Project Tags"] = tags;
   }
   if (templates) {
    trackingData["Templates"] = templates;
   }
   logging.tracking.startContext(trackingData);
  },
  endProjectContext:function() {
   logging.tracking.endContext([ "Project ID", "Project Title" ]);
  },
  startVideoContext:function(video, config) {
   currentVideo = video;
   lastTimeReport = 0;
   nextTimeReport = 0;
   reportTimeEvery = 0;
   streamStarted = false;
   logging.tracking.startContext({
    "Play Session":uuid().replace(/\-/g, ""),
    "Player Type":config ? config.playerType || video.get("source") :video.get("source"),
    "Video ID":video.get("id"),
    "Video Title":video.get("title"),
    "Video Category":video.get("source_category"),
    "Video Source":video.get("source"),
    "Video Source ID":video.get("source_id"),
    "Video Offset":0,
    "Video Accrued":0,
    "Video Percent Complete":0
   });
  },
  endVideoContext:function() {
   logging.tracking.endContext([ "Video ID", "Video Title", "Video Category", "Video Source", "Video Source ID", "Video Offset", "Video Accrued", "Video Percent Complete" ]);
   currentVideo = null;
  },
  startTrackContext:function(track) {
   currentTrack = track;
   var trackingData = {
    "Track ID":track.get("id"),
    "Num Annotations":track.get("num_annotations"),
    "Annotation Types":track.get("num_annotations_by_type")
   }, templates = track.get("templates");
   if (templates) {
    trackingData["Templates"] = templates;
   }
   logging.tracking.startContext(trackingData);
  },
  endTrackContext:function() {
   logging.tracking.endContext([ "Track ID" ]);
   currentTrack = null;
  },
  startAnnotationContext:function(annotation) {
   if (!annotation) {
    return;
   }
   logging.tracking.startContext({
    "Annotation ID":annotation.get("id"),
    "Annotation Type":annotation.get("type")
   });
  },
  endAnnotationContext:function() {
   logging.tracking.endContext([ "Annotation ID" ]);
  },
  startCategoryContext:function(category) {
   logging.tracking.startContext({
    "Category ID":category.get("id"),
    "Category Title":category.get("label")
   });
  },
  endCategoryContext:function() {
   logging.tracking.endContext([ "Category ID", "Category Title" ]);
  },
  startVisitUserContext:function(user) {
   logging.tracking.startContext({
    "Visited Username":user.get("username"),
    "Visited User ID":user.get("id")
   });
  },
  endVisitUserContext:function() {
   logging.tracking.endContext([ "Visited Username", "Visited User ID" ]);
  },
  startPlayerContext:function(p, options) {
   logging.tracking.startContext({
    "Playlist ID":options.playlistId,
    "Playlist Name":options.playlistName,
    "Video Title":options.videoTitle
   });
   player = p;
  },
  endPlayerContext:function() {
   logging.tracking.endContext([ "Playlist ID", "Playlist Name", "Video Title" ]);
   player = null;
  },
  endContext:function(fields) {
   _.each(fields, function(field) {
    logging.unregister(field);
   });
  },
  track:function(event, type, action, p) {
   p = _.extend({
    Type:type
   }, p);
   if (action) {
    p.Action = action;
   }
   logging.track(event, p);
   if (action !== "Progress") {
    if (event === lastTrackingEvent && _.isEqual(p, lastTrackingData) && new Date().getTime() - lastTrackingTime < 150) {
     logging.warn("Duplicate analytics tracking detected, " + "event=" + event + ", type=" + type + ", action=" + action);
    }
    lastTrackingEvent = event;
    lastTrackingData = p;
    lastTrackingTime = new Date().getTime();
   }
  },
  pageView:function(page, p) {
   logging.tracking.track("Page View", page, null, p);
   logging.tracking.startPageContext(page);
  },
  pageAction:function(type, action, p) {
   logging.tracking.track("Page Action", type, action, p);
  },
  playerView:function(type, p) {
   logging.tracking.track("Player View", type, null, p);
  },
  playerAction:function(type, action, p) {
   logging.tracking.track("Player Action", type, action, p);
  },
  setupAnnotationEvent:function(annotation, p) {
   var duration, position, gating, iframe_source, link, navigation, pausing, startTime, type;
   if (!annotation) {
    return;
   }
   type = annotation.get("type");
   startTime = annotation.get("start_time");
   duration = annotation.get("duration");
   pausing = !!annotation.get("properties.popcorn.pause");
   gating = annotation.get("properties.popcorn.gate");
   iframe_source = annotation.get("properties.popcorn.src");
   position = player.annotationPosition(annotation);
   if (typeof duration === "undefined") {
    duration = 3;
   }
   p = _.extend({
    "Annotation ID":annotation.get("id"),
    "Annotation Type":type,
    "Annotation Start Time":startTime,
    "Annotation Duration":duration,
    Pausing:pausing,
    Gating:gating,
    "Extension Source":iframe_source,
    "Annotation Position":position[0],
    "Annotation Coordinates":position[1]
   }, p);
   if (type === "pop" || type === "image" || type === "hotlink") {
    link = annotation.get("properties.popcorn.onClick.gotoLink") || annotation.get("properties.popcorn.link");
    p.Rollup = p.Rollup || [];
    if (link) {
     p.Target = link;
     p.Rollup.push("link");
    }
    navigation = annotation.get("properties.popcorn.onClick.gotoTrack");
    if (navigation) {
     p.Rollup.push("navigation");
    }
   }
   if (type === "pop") {
    if (annotation.get("properties.popcorn.text")) {
     p.Text = annotation.get("properties.popcorn.text");
    }
   } else if (type === "bookmark" && annotation.get("properties.popcorn.text")) {
    p.Text = annotation.get("properties.popcorn.text");
   }
   return p;
  },
  annotationView:function(annotation, p) {
   if (!annotation || player && player.editMode()) {
    return;
   }
   var type = annotation.get("type");
   p = logging.tracking.setupAnnotationEvent(annotation, p);
   logging.tracking.updateVideoPlayback(true);
   logging.tracking.track("Annotation View", type, null, p);
  },
  annotationEnded:function(annotation, p) {
   if (!annotation || player && player.editMode()) {
    return;
   }
   var type = annotation.get("type");
   p = logging.tracking.setupAnnotationEvent(annotation, p);
   logging.tracking.track("Annotation Ended", type, null, p);
  },
  annotationAction:function(annotation, action, p) {
   if (!annotation || player && player.editMode()) {
    return;
   }
   logging.tracking.updateVideoPlayback(true);
   logging.tracking.track("Annotation Action", annotation.get("type"), action, _.extend({
    "Annotation ID":annotation.get("id"),
    "Annotation Type":annotation.get("type")
   }, p));
  },
  annotationActionById:function(annotationId, annotationType, action, p) {
   if (!annotationId || annotationId.toString().indexOf("_") > -1 || player && player.editMode()) {
    return;
   }
   var model = require("model"), dao = require("dao"), annotation = model && dao && dao.store.find(model.Comment, annotationId);
   if (annotation && annotation.get("id")) {
    p = logging.tracking.setupAnnotationEvent(annotation, p);
    annotationType = annotation.get("type");
   }
   logging.tracking.updateVideoPlayback(true);
   if (annotationType === "toc") {
    annotationType = "contents";
   }
   logging.tracking.track("Annotation Action", annotationType, action, _.extend({
    "Annotation ID":annotationId,
    "Annotation Type":annotationType
   }, p));
  },
  updateVideoPlayback:function(force) {
   if (!player) {
    return;
   }
   var currentTime = Math.round(player.currentTime()), elapsedTime = Math.round(player.elapsedTime()), videoDuration = Math.round(player.duration()), percentComplete = Math.round(player.videoViewed() * 100), isLive = player.mediaType() === "live", obj;
   obj = {
    "Video Accrued":elapsedTime,
    "Live Video":isLive
   };
   if (!isLive && currentTime <= videoDuration) {
    _.extend(obj, {
     "Video Offset":currentTime,
     "Video Duration":videoDuration,
     "Video Percent Complete":percentComplete
    });
   }
   logging.register(obj);
   if (isLive && !reportTimeEvery) {
    reportTimeEvery = 30;
   } else if (!reportTimeEvery && videoDuration) {
    reportTimeEvery = Math.min(Math.round(videoDuration * .2), 30);
   }
   if (elapsedTime > 0) {
    if (!streamStarted) {
     logging.tracking.track("Player Action", "Video", "Play");
     streamStarted = true;
    }
    if (lastTimeReport !== elapsedTime && (elapsedTime >= nextTimeReport || force)) {
     logging.tracking.track("Player Action", "Video", "Progress", {
      "Video Elapsed Difference":elapsedTime - lastTimeReport
     });
     lastTimeReport = elapsedTime;
     nextTimeReport += reportTimeEvery || 10;
    }
   }
  }
 };
 function updateAuthTracking(auth) {
  var partnerAuth = auth.partner;
  if (!_.isEmpty(partnerAuth)) {
   logging.register({
    "Partner User ID":partnerAuth.userId,
    "Partner Username":partnerAuth.username,
    "Partner Email":partnerAuth.email
   });
  }
 }
 updateAuthTracking(hapyak.auth());
 hapyak.addEventListener("auth", updateAuthTracking);
 if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1 && typeof window.console !== "undefined") {
  if (typeof window.console.log !== "undefined" && logLevel <= logging.logLevels.indexOf("debug")) {
   logging.log = window.console.log.bind(window.console, "hapyak:");
  }
  if (typeof window.console.trace !== "undefined" && logLevel <= logging.logLevels.indexOf("trace")) {
   logging.trace = window.console.trace.bind(window.console, "hapyak (t):");
  }
  if (typeof window.console.debug !== "undefined" && logLevel <= logging.logLevels.indexOf("debug")) {
   logging.debug = window.console.debug.bind(window.console, "hapyak (d):");
  }
  if (typeof window.console.info !== "undefined" && logLevel <= logging.logLevels.indexOf("info")) {
   logging.info = window.console.info.bind(window.console, "hapyak (i):");
   if (module.config().environment === "dev") {
    logging.dev = window.console.info.bind(window.console, "hapyak (!):");
   }
  }
  if (typeof window.console.warn !== "undefined" && logLevel <= logging.logLevels.indexOf("warn")) {
   logging.warn = window.console.warn.bind(window.console, "hapyak (w):");
  }
  if (typeof window.console.error !== "undefined" && logLevel <= logging.logLevels.indexOf("error")) {
   logging.error = window.console.error.bind(window.console, "hapyak (e):");
  }
 }
 return logging;
});

define("dao", [ "module", "jquery.noconflict", "crypto/md5", "logging", "lodash.noconflict", "ember.noconflict" ], function(module, $, md5, logging, _) {
 var isJSONP = module.config().jsonp || window.location.href.indexOf(module.config().api) === -1, queryCache = module.config().queryCache, cdn = module.config().apiCdn, cdnPrefix, cdnQueryString, cdnEnabledPrefixes = [ "/api/srt/" ], readOnly = module.config().readOnly || false, AUTH_HEADERS = {
  "X-Hapyak-Partner-Group":"groupId",
  "X-Hapyak-Partner-Group-Token":"groupToken",
  "X-Hapyak-Partner-User":"userId",
  "X-Hapyak-Partner-Username":"username",
  "X-Hapyak-Partner-User-Token":"userToken"
 }, AUTH_QUERY_PARAMS = {
  partner_group:"groupId",
  partner_group_token:"groupToken",
  partner_user:"userId",
  partner_username:"username",
  partner_user_token:"userToken"
 };
 if (cdn && (cdn.enabled === undefined || cdn.enabled === true)) {
  cdnPrefix = cdn.prefix;
  cdnQueryString = cdn.query;
 }
 var Store = Ember.Object.extend(Ember.Evented, {
  model:null,
  nextRecordId:0,
  apiKey:module.config().apiKey,
  records:Ember.MapWithDefault.create({
   defaultValue:function(key) {
    return Ember.Map.create();
   }
  }),
  changeList:[],
  backup:{},
  inTransaction:false,
  status:"ok",
  commitStatus:"ok",
  commitAttempts:1,
  commitIndex:1,
  autoSaveInterval:3e3,
  isDirty:false,
  isCommitting:false,
  shutdown:false,
  startTransaction:function() {
   var store = this;
   this.set("inTransaction", true);
   if (this.get("scheduledCommit")) {
    clearTimeout(this.get("scheduledCommit"));
   }
   return {
    commit:function(callback) {
     store.commit(callback, true);
    },
    abort:function(callback) {
     store.abort(callback, true);
    }
   };
  },
  getNextId:function() {
   var cid = "_" + this.get("nextRecordId");
   this.incrementProperty("nextRecordId");
   return cid;
  },
  recordRecord:function(record) {
   this.get("records").get(record.constructor).set(record.get("id"), record);
   this.notifyPropertyChange("records");
  },
  getRecord:function(type, id) {
   return this.get("records").get(type).get(id);
  },
  removeRecord:function(type, id) {
   var record = this.getRecord(type, id);
   if (record) {
    this.get("records").get(type).remove(id);
    this.notifyPropertyChange("records");
   }
   return record;
  },
  load:function(type, data) {
   var resolveQueue = [];
   var result = this._load(type, data, resolveQueue);
   _.each(resolveQueue, function(fn) {
    fn();
   });
   return result;
  },
  _load:function(type, data, resolveQueue) {
   var record;
   if (data instanceof Array) {
    return _.map(data, function(item) {
     return this._load(type, item, resolveQueue);
    }, this);
   } else {
    record = this.getRecord(type, data.id);
    if (!record) {
     record = type.create();
     record.set("id", data.id, false);
     this.recordRecord(record);
    }
    record.beginPropertyChanges();
    _.each(data, function(value, prop) {
     if (prop in type.references) {
      var sideloadedType = type.getPropertyType(prop);
      if (value instanceof Array) {
       _.each(value, function(arrayEntry) {
        if (typeof arrayEntry === "object") {
         this._load(sideloadedType, arrayEntry, resolveQueue);
        }
       }, this);
      } else if (typeof value === "object") {
       this._load(sideloadedType, value, resolveQueue);
      }
     }
    }, this);
    _.each(data, function(value, prop) {
     var sideloadedType;
     if (prop === "deleted") {
      prop = "isDeleted";
     }
     if (prop === "properties") {
      _.each(value, function(value, key) {
       if (!this.hasChange(record, "properties." + key)) {
        record.setCustomProperty(key, value, false);
       } else {
        logging.info("ignore load data b/c of pending change to key " + key);
       }
      }, this);
     } else {
      if (this.hasChange(record, prop)) {
       return;
      }
      sideloadedType = type.getPropertyType(prop);
      if (prop in type.references) {
       resolveQueue.push(_.bind(function() {
        if (value instanceof Array) {
         record.set(prop, Ember.A(_.map(value, function(arrayEntry) {
          if (typeof arrayEntry === "object") {
           return this.getRecord(sideloadedType, arrayEntry.id);
          } else if (typeof arrayEntry === "number" && !isNaN(arrayEntry)) {
           return this.getRecord(sideloadedType, arrayEntry);
          } else {
           return null;
          }
         }, this)), false);
        } else if (typeof value === "object") {
         record.set(prop, this.getRecord(sideloadedType, value.id), false);
        } else if (typeof value === "number" && !isNaN(value)) {
         record.set(prop, this.getRecord(sideloadedType, value), false);
        }
       }, this));
      } else if (prop !== "id") {
       if (sideloadedType === Date) {
        value = new Date(value);
       }
       record.set(prop, value, false);
      }
     }
    }, this);
    record.set("isLoaded", true, false);
    record.set("isSaved", true, false);
    record.endPropertyChanges();
    record.trigger("didLoad");
    record.resolve(record);
    return record;
   }
  },
  find:function(type, id) {
   return Ember.typeOf(id) === "object" ? this.findQuery(type, id) :this.findById(type, id);
  },
  findById:function(type, id) {
   id = parseInt(id, 10);
   if (isNaN(id)) {
    throw new Error("id is NaN, cant findById");
   }
   var record = this.getRecord(type, id);
   if (record) {
    return record;
   } else {
    record = type.create();
    record.set("id", id, false);
    this.recordRecord(record);
    var url = Ember.String.fmt(type.getEndpoint() + "/%@/", [ id ]);
    this.getJSON(type, url, {}, function(data) {
     Ember.run(this, function() {
      this.load(type, data);
     });
    }.bind(this));
    return record;
   }
  },
  findOne:function(type, query, onLoad) {
   this.findQuery(type, query).onLoad(function(results) {
    onLoad(results.get("firstObject"));
   });
  },
  findMany:function(type, ids) {
   return Ember.RSVP.all(_.map(ids, _.bind(this.find, this, type)));
  },
  findQuery:function(type, query) {
   var modelArray = RecordArray.create({}), cached = null, onSuccess = function(data, status) {
    Ember.run(this, function() {
     if (!data.meta && data.id) {
      modelArray.set("content", Ember.A([ this.load(type, data) ]));
     } else {
      var records = this.load(type, data.objects);
      modelArray.set("content", Ember.A(records));
      modelArray.setProperties({
       total:data.meta.total,
       pages:data.meta.pages,
       page:data.meta.page,
       hasPrevious:!!data.meta.previous,
       hasNext:!!data.meta.next
      });
      if (data.meta.next) {
       modelArray.set("next", function() {
        var newQuery = {};
        _.extend(newQuery, query, {
         page:data.meta.page + 1
        });
        return this.find(type, newQuery);
       }.bind(this));
      }
      modelArray.set("loadPage", function(page) {
       if (_.isNaN(+page) || page <= 0) {
        return;
       }
       var newQuery = {};
       _.extend(newQuery, query, {
        page:+page
       });
       return this.find(type, newQuery);
      }.bind(this));
      if (data.meta.previous) {
       modelArray.set("previous", function() {
        var newQuery = {};
        _.extend(newQuery, query, {
         page:data.meta.page - 1
        });
        return this.find(type, newQuery);
       }.bind(this));
      }
     }
     modelArray.set("isLoaded", true);
     modelArray.trigger("didLoad");
     modelArray.resolve(modelArray);
    });
   }.bind(this), onError = function() {
    modelArray.set("isLoaded", true);
    modelArray.trigger("didLoad");
    modelArray.reject(modelArray);
   };
   if (query.query && query.page === 1) {
    cached = queryCache[query.query];
    if (cached) {
     delete queryCache[query.query];
     logging.info("loading query result for query " + query.query + " from cache");
     onSuccess(cached);
     return modelArray;
    }
   }
   this.getJSON(type, type.getEndpoint() + "/", query, onSuccess, onError);
   return modelArray;
  },
  filter:function(type, query, filter) {
   if (arguments.length === 3) {
    this.findQuery(type, query);
   } else if (arguments.length === 2) {
    filter = query;
   }
   return FilteredRecordArray.create({
    type:type,
    filterFunction:filter,
    content:Ember.A([])
   });
  },
  createRecord:function(type, p, isTransient) {
   return type.createRecord(p, isTransient);
  },
  deleteRecord:function(record) {
   return record.deleteRecord();
  },
  didCreate:function(record) {
   if (readOnly) {
    return;
   }
   var cid = this.getNextId();
   record.set("id", cid, false);
   this.recordRecord(record);
   this.get("changeList").push({
    op:"create",
    type:record.constructor.typeName,
    id:cid
   });
   this.notifyPropertyChange("changeList");
   this.scheduleCommit();
  },
  beforeUpdate:function(record, key, value) {
   if (readOnly) {
    return;
   }
   if (this.get("inTransaction") && !(record.get("id") in this.get("backup"))) {
    var data = record.get("data"), copy = _.clone(data);
    if ("properties" in copy) {
     copy.properties = _.cloneDeep(copy.properties);
    }
    this.get("backup")[record.get("id")] = {
     data:copy,
     record:record
    };
   }
  },
  didUpdate:function(record, key, value) {
   if (readOnly) {
    return;
   }
   if (value instanceof Ember.Object) {
    value = value.get("id");
   }
   if (value === undefined) {
    value = null;
   }
   this.set("changeList", _.reject(this.get("changeList"), function(item) {
    return "set" === item.op && record.constructor.typeName === item.type && record.get("id") === item.id && key === item.key;
   }));
   this.get("changeList").push({
    op:"set",
    type:record.constructor.typeName,
    id:record.get("id"),
    key:key,
    value:value
   });
   this.notifyPropertyChange("changeList");
   this.scheduleCommit();
  },
  didDelete:function(record) {
   if (readOnly) {
    return;
   }
   this.set("changeList", _.reject(this.get("changeList"), function(item) {
    return "delete" === item.op && record.constructor.typeName === item.type && record.get("id") === item.id;
   }));
   this.get("changeList").push({
    op:"delete",
    type:record.constructor.typeName,
    id:record.get("id")
   });
   this.notifyPropertyChange("changeList");
   this.notifyPropertyChange("records");
   this.scheduleCommit();
  },
  hasChange:function(record, key) {
   if (readOnly) {
    return false;
   }
   return _.find(this.get("changeList"), function(item) {
    return "set" === item.op && record.constructor.typeName === item.type && record.get("id") === item.id && key === item.key;
   });
  },
  scheduleCommit:function() {
   if (readOnly || this.get("inTransaction")) {
    return;
   }
   if (this.get("scheduledCommit")) {
    clearTimeout(this.get("scheduledCommit"));
   }
   this.set("scheduledCommit", setTimeout(this.commit.bind(this), this.get("autoSaveInterval")));
  },
  hasChanges:Ember.computed(function() {
   if (readOnly) {
    return false;
   }
   var hasChanges = this.get("changeList").length > 0;
   this.set("isDirty", hasChanges || this.get("isCommitting"));
   return hasChanges;
  }).property("changeList").cacheable(false),
  commit:function(onSuccess, flushTransaction, promise) {
   promise = promise || Ember.Deferred.create();
   if (readOnly) {
    logging.warn("in readOnly mode");
    promise.reject({
     status:"error",
     message:"DAO is readOnly",
     code:"read_only"
    });
    return promise;
   }
   if (this.get("inTransaction") && !flushTransaction) {
    promise.reject({
     status:"error",
     message:"DAO is in transaction",
     code:"in_transaction"
    });
    return promise;
   }
   if (!hapyak.auth().userId && _.isEmpty(hapyak.auth().partner)) {
    logging.warn("can not commit, not logged in");
    promise.reject({
     status:"error",
     message:"Not logged in",
     code:"not_logged_in"
    });
    return promise;
   }
   if (!this.get("isCommitting") && this.get("hasChanges")) {
    this.set("isCommitting", true);
    logging.info("committing " + this.get("changeList").length + " changes", this.get("changeList"));
    if (this.get("scheduledCommit")) {
     clearTimeout(this.get("scheduledCommit"));
     this.set("scheduledCommit", null);
    }
    var commitIndex = this.get("commitIndex");
    this.incrementProperty("commitIndex");
    var onCommit = function(committedIndex, isSuccess, result) {
     if (committedIndex >= commitIndex) {
      this.off("committed", onCommit);
      if (isSuccess) {
       promise.resolve();
       if (onSuccess) {
        onSuccess();
       }
      } else {
       promise.reject(result);
      }
     }
    }.bind(this);
    this.on("committed", onCommit);
    var changeList = this.get("changeList").slice(0);
    this.set("changeList", []);
    this.sendChanges(changeList, commitIndex);
    this.set("backup", {});
    this.set("inTransaction", false);
   } else {
    if (this.get("hasChanges")) {
     this.one("committed", this, function() {
      this.commit(onSuccess, promise);
     });
    } else {
     promise.resolve();
     if (onSuccess) {
      onSuccess();
     }
    }
   }
   return promise;
  },
  abort:function(callback, flushTransaction) {
   if (this.get("inTransaction") && !flushTransaction) {
    throw new Error("Can not abort, in transaction");
   }
   var revertedRecords = [];
   _.each(this.get("backup"), function(value) {
    var record = value["record"];
    var backupData = value["data"];
    logging.debug("rolling back data in record " + record.get("id"));
    record.set("data", backupData);
    revertedRecords.push(record);
   });
   this.set("backup", {});
   this.set("changeList", []);
   this.set("inTransaction", false);
   this.trigger("aborted", revertedRecords);
   callback();
  },
  sendChanges:function(changeList, commitIndex) {
   var model = this.get("model");
   this.postJSON("/api/batch/", changeList, function(result) {
    Ember.run(this, function() {
     this.set("status", "ok");
     this.set("commitStatus", "ok");
     this.set("commitAttempts", 1);
     _.each(result.changed, function(object) {
      var record, type = model[object.type];
      if (object.cid) {
       record = this.removeRecord(type, object.cid);
       if (record) {
        record.set("id", object.data.id);
        this.recordRecord(record);
       }
       _.each(this.get("changeList"), function(change) {
        if (change.id === object.cid) {
         change.id = object.data.id;
        }
        if (change.value === object.cid) {
         change.value = object.data.id;
        }
       });
      }
      record = this.load(type, object.data);
      if (record.get("isDeleted")) {
       record.trigger("didDelete");
      } else {
       record.trigger("didSave");
       if (!object.cid) {
        record.trigger("didUpdate");
       }
      }
     }, this);
     this.trigger("committed", commitIndex, true);
     this.set("isCommitting", false);
     this.commit();
    });
   }, function(error) {
    Ember.run(this, function() {
     if (error.status !== 200 && error.status !== 400 && error.status !== 403) {
      this.set("status", "connection-error");
      this.set("commitStatus", "requeue");
      var attempts = this.get("commitAttempts");
      if (attempts % 5 === 0) {
       logging.error("connection error to hapyak servers, will continue to requeue changes, attempt=" + attempts);
      }
      setTimeout(function() {
       this.incrementProperty("commitAttempts");
       this.sendChanges(changeList);
      }.bind(this), 2e3 * attempts);
     } else if (error.status === 400) {
      this.set("isCommitting", false);
      try {
       var errorJson = JSON.parse(error.responseText);
       logging.captureMessage("Illegal argument exception for dao save, " + errorJson.message);
       this.trigger("committed", commitIndex, false, errorJson);
      } catch (e) {
       logging.captureMessage("Illegal argument exception for dao save");
       this.trigger("committed", commitIndex, false);
      }
     }
    });
   });
  },
  getJSON:function(type, url, data, onSuccess, onError, attempts) {
   var jsonp = isJSONP, cdnEnabled = (cdnEnabledPrefixes.indexOf(url.split("?")[0]) > -1 || type && type.supportsCdnAccess) && cdnPrefix, fullUrl, partnerAuth;
   attempts = attempts || 1;
   data = data ? _.clone(data) :{};
   if (cdnEnabled) {
    fullUrl = cdnPrefix + url;
    if (cdnQueryString) {
     fullUrl += "?" + cdnQueryString;
    }
    data.cdn = true;
    jsonp = true;
   } else {
    fullUrl = module.config().api + url;
   }
   if (jsonp) {
    fullUrl += (fullUrl.indexOf("?") === -1 ? "?" :"&") + "callback=?";
    if (module.config().csrfToken) {
     data.csrf = module.config().csrfToken;
    }
    if (this.get("apiKey")) {
     data.key = this.get("apiKey");
    }
    partnerAuth = hapyak.auth().partner;
    if (!_.isEmpty(partnerAuth)) {
     _.each(AUTH_QUERY_PARAMS, function(variable, param) {
      if (partnerAuth[variable] && (!cdnEnabled || variable.indexOf("group") === 0)) {
       data[param] = partnerAuth[variable];
      }
     });
    }
   }
   var hash = this.setupAjaxRequest(fullUrl, "GET");
   hash.data = data;
   hash.success = onSuccess;
   if (cdnEnabled) {
    hash.jsonpCallback = "hap_" + md5($.param(data)) + "_";
    hash.cache = true;
   }
   hash.success = function(data) {
    this.set("status", "ok");
    if (onSuccess) {
     onSuccess(data);
    }
   };
   hash.error = function(error) {
    if (error.status !== 200 && error.status !== 400 && error.status !== 403 && error.status !== 404 && attempts < 10) {
     this.set("status", "connection-error");
     setTimeout(function() {
      this.incrementProperty("attempts");
      this.getJSON(type, url, data, onSuccess, onError, attempts + 1);
     }.bind(this), 2e3 * attempts);
    } else {
     if (onError) {
      onError(error);
     }
    }
   };
   return $.ajax(hash);
  },
  postJSON:function(url, data, onSuccess, onError) {
   var hash = this.setupAjaxRequest(url, "POST");
   if (data) {
    hash.data = JSON.stringify(data);
   }
   hash.success = onSuccess;
   hash.error = onError;
   return $.ajax(hash);
  },
  setupAjaxRequest:function(url, type) {
   var hash = {
    url:url,
    context:this
   }, that = this;
   type = type || "GET";
   if (url.indexOf("?callback=?") !== -1) {
    hash.dataType = "jsonp";
    hash.async = false;
   } else {
    hash.type = type;
    hash.contentType = "application/json; charset=utf-8";
    hash.dataType = "json";
    hash.beforeSend = function(xhr) {
     var auth = hapyak.auth();
     var partnerAuth = auth.partner;
     if (module.config().csrfToken) {
      xhr.setRequestHeader("X-Hapyak-CSRF-Token", module.config().csrfToken);
     }
     if (that.get("apiKey")) {
      xhr.setRequestHeader("X-Hapyak-API-Key", that.get("apiKey"));
     }
     if (!_.isEmpty(partnerAuth)) {
      _.each(AUTH_HEADERS, function(variable, header) {
       if (partnerAuth[variable]) {
        xhr.setRequestHeader(header, partnerAuth[variable]);
       }
      });
     } else if (auth.userId) {
      xhr.setRequestHeader("X-Hapyak-User", auth.userId);
     }
    };
    if (this.get("shutdown")) {
     hash.async = false;
    }
   }
   return hash;
  },
  isConnectionError:Ember.computed(function() {
   return this.get("status") === "connection-error";
  }).property("status"),
  isCommitStatusRequeue:Ember.computed(function() {
   return this.get("commitStatus") === "requeue";
  }).property("commitStatus")
 });
 var store = Store.create({});
 var RecordArray = Ember.ArrayProxy.extend(Ember.Evented, Ember.DeferredMixin, {
  isLoaded:false,
  onLoad:function(callback) {
   if (this.get("isLoaded")) {
    callback(this);
   } else {
    this.one("didLoad", this, function() {
     callback(this);
    });
   }
   return this;
  }
 });
 var FilteredRecordArray = RecordArray.extend({
  type:null,
  filterFunction:null,
  init:function() {
   this.updateContent();
   store.addObserver("records", this, "updateContent");
  },
  updateContent:function() {
   var matches = Ember.A([]);
   store.records.get(this.get("type")).forEach(function(key, value) {
    if (!value.get("isDeleted")) {
     if (this.get("filterFunction")) {
      if (this.get("filterFunction")(value)) {
       matches.pushObject(value);
      }
     } else {
      matches.pushObject(value);
     }
    }
   }, this);
   this.set("content", matches);
   this.set("isLoaded", true);
   this.trigger("didLoad");
   this.resolve(this);
  },
  willDestroy:function() {
   store.removeObserver("records", this, "updateContent");
  }
 });
 var ListOf = Ember.Object.extend({
  type:null
 });
 var DataRecord = Ember.Object.extend(Ember.Evented, Ember.DeferredMixin, {
  isLoaded:false,
  params:{},
  init:function() {
   if (this.get("endpoint")) {
    this.getJSON(this.get("endpoint"), this.get("params"));
   }
  },
  getJSON:function(endpoint, params) {
   var that = this;
   that.set("loading", true);
   store.getJSON(null, "/api" + endpoint, params, function(result) {
    that.load(result);
    that.set("loading", false);
    that.set("isLoaded", true);
    that.trigger("didLoad");
    that.resolve(that);
   });
  },
  onLoad:function(context, callback) {
   if (this.get("isLoaded")) {
    callback.apply(context);
   } else {
    this.one("didLoad", this, function() {
     callback.apply(context);
    });
   }
   return this;
  },
  load:function(data) {
   _.each(data, function(value, key) {
    if (key.indexOf(".") !== -1) {
     key = key.replace(".", "_");
    }
    if (value !== null) {
     if (value instanceof Array) {
      this.set(key, Ember.A(_.map(value, function(arrayEntry) {
       if (typeof arrayEntry === "object") {
        return DataRecord.create({}).load(arrayEntry);
       } else {
        return arrayEntry;
       }
      }, this)));
     } else if (typeof value === "object") {
      this.set(key, DataRecord.create({}).load(value));
     } else {
      this.set(key, value);
     }
    }
   }, this);
   return this;
  }
 });
 DataRecord.reopenClass({
  find:function(endpoint, params) {
   return DataRecord.create({
    endpoint:endpoint,
    params:params
   });
  }
 });
 return {
  store:store,
  RecordArray:RecordArray,
  ListOf:ListOf,
  DataRecord:DataRecord
 };
});

define("model", [ "module", "jquery.noconflict", "ember.noconflict", "dao", "logging", "lodash.noconflict", "ember.noconflict" ], function(module, $, Ember, dao, logging, _) {
 var Model = Ember.Object.extend(Ember.Evented, Ember.DeferredMixin, {
  data:null,
  isTransient:false,
  fireChange:true,
  init:function() {
   this.data = {
    isLoaded:false,
    isSaved:false,
    isDeleted:false
   };
  },
  shouldFireChange:function() {
   return !this.get("isTransient") && !this.get("isDeleted");
  },
  onLoad:function(callback) {
   if (this.get("isLoaded")) {
    callback(this);
   } else {
    this.one("didLoad", this, function() {
     callback(this);
    });
   }
   return this;
  },
  onSave:function(callback) {
   this.one("didSave", this, function() {
    callback(this);
   });
   return this;
  },
  onDelete:function(callback) {
   if (this.get("isDeleted")) {
    callback(this);
   } else {
    this.one("didDelete", this, function() {
     callback(this);
    });
   }
   return this;
  },
  unknownProperty:function(key) {
   return Ember.get(this.data, key);
  },
  setUnknownProperty:function(key, value) {
   if (this.get(key) !== value) {
    var fireChange = key !== "id" && this.fireChange && this.shouldFireChange();
    if (fireChange) {
     dao.store.beforeUpdate(this, key, value);
    }
    this.propertyWillChange(key);
    Ember.set(this.data, key, value);
    this.propertyDidChange(key);
    if (fireChange) {
     dao.store.didUpdate(this, key, value);
    }
   }
  },
  set:function(key, value, fireChange) {
   var existingValue = this.get(key), valueToCheck = value, oldFireChange = this.fireChange;
   if (_.isNumber(value) && _.isNumber(existingValue) && Math.abs(value - existingValue) < 1e-8) {
    return this;
   }
   if ((value === null || value === undefined) && (existingValue === null || existingValue === undefined)) {
    return this;
   }
   if (valueToCheck instanceof Ember.Object) {
    valueToCheck = valueToCheck.get("id");
   }
   if (existingValue instanceof Ember.Object) {
    existingValue = existingValue.get("id");
   }
   if (!_.isEqual(existingValue, valueToCheck)) {
    this.fireChange = fireChange !== false;
    try {
     this._super(key, value);
    } finally {
     this.fireChange = oldFireChange;
    }
   }
   return this;
  },
  setProperties:function(properties) {
   var key, value;
   if (typeof properties === "object") {
    for (key in properties) {
     if (properties.hasOwnProperty(key)) {
      value = properties[key];
      this.set(key, value);
     }
    }
   }
   return this;
  },
  setCustomProperty:function(name, value, fireChange) {
   var props = this.get("properties");
   if (!props) {
    this.set("properties", props = {}, false);
   }
   var existingValue = Ember.get(props, name);
   if (_.isNumber(value) && _.isNumber(existingValue) && Math.abs(value - existingValue) < 1e-8) {
    return this;
   }
   if ((value === null || value === undefined) && (existingValue === null || existingValue === undefined)) {
    return this;
   }
   if (!_.isEqual(existingValue, value)) {
    fireChange = fireChange !== false && this.shouldFireChange(fireChange);
    if (fireChange) {
     dao.store.beforeUpdate(this, "properties." + name, value);
    }
    Ember.set(props, name, value);
    if (fireChange) {
     dao.store.didUpdate(this, "properties." + name, value);
    }
   }
   return this;
  },
  getCustomProperty:function(name) {
   return this.get("properties." + name);
  },
  deleteRecord:function() {
   if (!this.get("isDeleted")) {
    var shouldFireChange = this.shouldFireChange();
    this.set("isDeleted", true, false);
    if (shouldFireChange) {
     dao.store.didDelete(this);
    }
   }
  },
  hasPermission:function(perm) {
   if (this.get("isDeleted")) {
    return false;
   }
   var permissions = this.get("permissions");
   if (permissions) {
    return permissions[perm] === true;
   } else if (!this.get("isSaved")) {
    return true;
   }
   return false;
  },
  permissions:Ember.computed(function() {
   return {
    owner:this.get("isOwner"),
    edit:this.get("hasEditPermission"),
    "delete":this.get("hasDeletePermission"),
    view:this.get("hasViewPermission")
   };
  }).property().cacheable(false),
  getOwner:function() {
   if (this.constructor.ownerField) {
    return this.get(this.constructor.ownerField);
   }
   return null;
  },
  isOwner:Ember.computed(function() {
   if (this.constructor.ownerField) {
    var owner = this.getOwner();
    if (owner) {
     return window.HapyakApp && owner && owner.get("id") === window.HapyakApp.get("currentUser.id");
    }
   }
   return false;
  }).property().cacheable(false),
  hasEditPermission:Ember.computed(function() {
   var user = window.HapyakApp && window.HapyakApp.get("currentUser"), group;
   if (user) {
    if (this.get("isOwner") || user.get("role") === "admin") {
     return true;
    }
    group = this.get("group");
    if (group && user.get("membership." + group) === "admin") {
     return true;
    }
   }
   return false;
  }).property().cacheable(false),
  hasDeletePermission:Ember.computed(function() {
   return this.get("hasEditPermission");
  }).property().cacheable(false),
  hasViewPermission:Ember.computed(function() {
   return this.constructor.ownerField ? this.get("hasEditPermission") :true;
  }).property().cacheable(false),
  trigger:function(name) {
   Ember.tryInvoke(this, name, [].slice.call(arguments, 1));
   this._super.apply(this, arguments);
  },
  isEqual:function(obj) {
   return this.constructor === obj.constructor && this.get("id") === obj.get("id");
  },
  didLoad:Ember.K,
  didSave:Ember.K,
  didCreate:Ember.K,
  didUpdate:Ember.K,
  didDelete:Ember.K
 });
 Model.reopenClass({
  ownerField:"user",
  fields:{
   created:Date,
   modified:Date
  },
  references:{},
  supportsCdnAccess:false,
  find:function(id) {
   return dao.store.find(this, id);
  },
  filter:function(query, filter) {
   return dao.store.filter(this, query, filter);
  },
  findOne:function(query, onLoad) {
   dao.store.findOne(this, query, onLoad);
  },
  createRecord:function(p, isTransient) {
   var record = this.create();
   record.set("isLoaded", true, false);
   if (isTransient === true) {
    record.set("isTransient", true, false);
   } else {
    dao.store.didCreate(record);
   }
   if (p) {
    _.each(p, function(value, key) {
     record.set(key, value);
    });
   }
   record.trigger("didCreate");
   record.resolve(record);
   return record;
  },
  getPropertyType:function(prop) {
   var type = this.references[prop];
   if (!type) {
    type = this.fields[prop];
   }
   if (type instanceof dao.ListOf) {
    type = type.get("type");
   }
   return type;
  },
  getEndpoint:function() {
   var name = Ember.String.decamelize(this.typeName).toLowerCase();
   return "/api/" + name + "s";
  },
  toString:function() {
   return "." + this.typeName;
  }
 });
 var model = {};
 model.User = Model.extend({
  full_name:Ember.computed(function() {
   var firstName = this.get("first_name");
   var lastName = this.get("last_name");
   if (firstName && lastName) {
    return firstName + " " + lastName;
   } else if (firstName) {
    return firstName;
   } else {
    return this.get("username");
   }
  }).property("first_name", "last_name", "username"),
  avatarImageUrl:Ember.computed(function() {
   return this.get("image");
  }).property("image"),
  permissions:Ember.computed(function() {
   var permissions = this._super();
   permissions.create_named_tracks = Ember.A([ "admin", "producer", "editor" ]).contains(this.get("role"));
   permissions.create_official_tracks = Ember.A([ "admin", "producer", "editor" ]).contains(this.get("role"));
   permissions.create_featured_videos = Ember.A([ "admin", "editor", "partner_admin", "partner_editor" ]).contains(this.get("role"));
   return permissions;
  }).property().cacheable(false),
  isOwner:Ember.computed(function() {
   return window.HapyakApp && window.HapyakApp.get("currentUser.id") === this.get("id");
  }).property().cacheable(false),
  hasViewPermission:Ember.computed(function() {
   return true;
  }).property().cacheable(false),
  hasDeletePermission:Ember.computed(function() {
   return false;
  }).property().cacheable(false),
  accountAssociations:Ember.computed(function() {
   var associations = Ember.Object.create({
    allConnected:false,
    isLoaded:false
   });
   dao.store.find(model.AccountAssociation, {
    username:this.get("username")
   }).onLoad(function(data) {
    var facebook = data.findProperty("service", "facebook"), google = data.findProperty("service", "google");
    associations.set("facebook", facebook);
    associations.set("google", google);
    if (facebook && google) {
     associations.set("allConnected", true);
    }
    associations.set("isLoaded", true);
   });
   return associations;
  }).property()
 });
 model.AccountAssociation = Model.extend({});
 model.Video = Model.extend({
  category:Ember.computed(function() {
   return model.VideoCategory.find(this.get("source_category"));
  }).property("content", "content.isLoaded"),
  hasEditPermission:Ember.computed(function() {
   if (this._super()) {
    return true;
   }
   var user = window.HapyakApp && window.HapyakApp.get("currentUser"), group;
   if (user) {
    group = this.get("group");
    if (group) {
     return user.get("membership." + group) === "editor";
    } else if (user.get("role") === "editor") {
     return true;
    }
   }
   return false;
  }).property().cacheable(false)
 });
 model.Track = Model.extend({
  init:function() {
   this._super();
   this.data.numLikes = 0;
  },
  didCreate:function() {
   this._super();
   this.onSave(function() {
    logging.tracking.playerAction("Track", "Create", {
     "Track ID":this.get("id")
    });
   }.bind(this));
  },
  didUpdate:function() {
   this._super();
   logging.tracking.playerAction("Track", "Update", {
    "Track ID":this.get("id")
   });
  },
  didDelete:function() {
   this._super();
   logging.tracking.playerAction("Track", "Delete", {
    "Track ID":this.get("id")
   });
  },
  official:Ember.computed(function() {
   return this.get("privacy") === "official";
  }).property("privacy"),
  permissions:Ember.computed(function() {
   var permissions = this._super();
   permissions.add_annotations = this.get("hasEditPermission");
   return permissions;
  }).property().cacheable(false),
  hasAddAnnotationsPermission:Ember.computed(function() {
   return this.get("hasEditPermission");
  }).property().cacheable(false),
  hasEditPermission:Ember.computed(function() {
   if (this._super()) {
    return true;
   }
   var user = window.HapyakApp && window.HapyakApp.get("currentUser"), group;
   if (user) {
    group = this.get("group");
    if (group) {
     return user.get("membership." + group) === "editor";
    } else if (user.get("role") === "editor") {
     return true;
    }
   }
   return false;
  }).property().cacheable(false),
  hasViewPermission:Ember.computed(function() {
   if (this._super()) {
    return true;
   }
   return this.get("privacy") !== "private";
  }).property().cacheable(false),
  copiedFromUser:Ember.computed(function() {
   var user = this.get("copied_from_user");
   if (user) {
    return model.User.find(user);
   }
  }).property("copied_from_user")
 });
 model.Comment = Model.extend({
  didCreate:function() {
   this._super();
   this.onSave(function() {
    logging.tracking.playerAction("Annotation", "Create", {
     "Annotation ID":this.get("id"),
     "Annotation Type":this.get("type")
    });
   }.bind(this));
  },
  isValid:function() {
   return this.hasContent();
  },
  hasContent:function() {
   if (this.get("type") === "pop") {
    return !Ember.isNone(this.get("properties.content")) && !Ember.isEmpty($.trim(this.get("properties.content")));
   } else if (this.get("type") === "drawing") {
    return !Ember.isNone(this.get("properties.drawing")) && !Ember.isEmpty($.trim(this.get("properties.drawing")));
   } else if (this.get("type") === "audio-note") {
    return !Ember.empty(this.get("properties.audio_src"));
   } else {
    return false;
   }
  },
  setDrawing:function(strokes) {
   this.setCustomProperty("drawing", strokes);
  },
  getDrawing:function() {
   return this.get("properties.drawing");
  },
  hasEditPermission:Ember.computed(function() {
   if (this._super()) {
    return true;
   }
   var user = window.HapyakApp && window.HapyakApp.get("currentUser"), group;
   if (user) {
    group = this.get("group");
    if (group) {
     return user.get("membership." + group) === "editor";
    } else if (user.get("role") === "editor") {
     return true;
    }
   }
   return false;
  }).property().cacheable(false),
  hasViewPermission:Ember.computed(function() {
   if (this._super()) {
    return true;
   }
   return this.get("privacy") !== "private";
  }).property().cacheable(false)
 });
 model.TrackRating = Model.extend({
  hasViewPermission:Ember.computed(function() {
   return true;
  }).property().cacheable(false)
 });
 model.TrackReaction = Model.extend({
  hasViewPermission:Ember.computed(function() {
   return true;
  }).property().cacheable(false)
 });
 model.Follow = Model.extend({});
 model.UserVideo = Model.extend({});
 model.FeaturedVideo = Model.extend({});
 model.Related = Model.extend({});
 model.ViewerSetup = Model.extend({});
 model.Config = Model.extend({});
 model.Group = Model.extend({});
 model.GroupMember = Model.extend({});
 model.Project = Model.extend({});
 model.Code = Model.extend({});
 model.AccountAssociation.reopenClass({
  typeName:"AccountAssociation"
 });
 model.User.reopenClass({
  typeName:"User",
  fields:{
   created:Date,
   modified:Date,
   last_import_start:Date,
   last_import_finish:Date
  }
 });
 model.Group.reopenClass({
  typeName:"Group",
  references:{
   parent:model.Group
  }
 });
 model.GroupMember.reopenClass({
  typeName:"GroupMember",
  references:{
   user:model.User,
   group:model.Group
  }
 });
 model.Video.reopenClass({
  typeName:"Video",
  references:{
   tracks:dao.ListOf.create({
    type:model.Track
   })
  }
 });
 model.Track.reopenClass({
  ownerField:"owner",
  typeName:"Track",
  fields:{
   created:Date,
   modified:Date,
   annotation_modified:Date
  },
  references:{
   owner:model.User,
   video:model.Video
  }
 });
 model.Comment.reopenClass({
  typeName:"Comment",
  references:{
   user:model.User,
   track:model.Track
  }
 });
 model.TrackRating.reopenClass({
  typeName:"TrackRating",
  references:{
   user:model.User,
   track:model.Track
  }
 });
 model.TrackReaction.reopenClass({
  typeName:"TrackReaction",
  references:{
   user:model.User,
   track:model.Track
  }
 });
 model.UserVideo.reopenClass({
  typeName:"UserVideo",
  references:{
   user:model.User,
   video:model.Video,
   tracks:dao.ListOf.create({
    type:model.Track
   })
  }
 });
 model.FeaturedVideo.reopenClass({
  typeName:"FeaturedVideo",
  references:{
   owner:model.User,
   video:model.Video,
   track:model.Track
  }
 });
 model.Follow.reopenClass({
  typeName:"Follow",
  references:{
   user:model.User,
   follow:model.User
  }
 });
 model.Related.reopenClass({
  typeName:"Related",
  references:{
   videos:dao.ListOf.create({
    type:model.Video
   }),
   tracks:dao.ListOf.create({
    type:model.Track
   })
  },
  getEndpoint:function() {
   return "/api/related";
  }
 });
 model.Project.reopenClass({
  typeName:"Project",
  references:{
   owner:model.User,
   video:model.Video,
   track:model.Track,
   group:model.Group
  }
 });
 model.Code.reopenClass({
  typeName:"Code"
 });
 model.ViewerSetup.reopenClass({
  supportsCdnAccess:true,
  typeName:"ViewerSetup",
  references:{
   project:model.Project,
   video:model.Video,
   track:model.Track,
   comments:dao.ListOf.create({
    type:model.Comment
   })
  },
  getEndpoint:function() {
   return "/api/viewer/setup";
  }
 });
 model.Config.reopenClass({
  typeName:"Config"
 });
 model.VideoCategory = Ember.Object.extend({
  id:null,
  label:null,
  hidden:false
 });
 model.VideoCategory.reopenClass({
  find:function(id) {
   return allCategories.findProperty("id", id);
  },
  findAll:function() {
   return allCategories;
  }
 });
 var allCategories = Ember.A([ model.VideoCategory.create({
  label:"All",
  id:"All"
 }), model.VideoCategory.create({
  label:"Animals",
  id:"Animals"
 }), model.VideoCategory.create({
  label:"Autos",
  id:"Autos",
  hidden:true
 }), model.VideoCategory.create({
  label:"Comedy",
  id:"Comedy"
 }), model.VideoCategory.create({
  label:"Education",
  id:"Education"
 }), model.VideoCategory.create({
  label:"Entertainment",
  id:"Entertainment"
 }), model.VideoCategory.create({
  label:"Film",
  id:"Film"
 }), model.VideoCategory.create({
  label:"Games",
  id:"Games"
 }), model.VideoCategory.create({
  label:"How To",
  id:"Howto"
 }), model.VideoCategory.create({
  label:"Music",
  id:"Music"
 }), model.VideoCategory.create({
  label:"News",
  id:"News"
 }), model.VideoCategory.create({
  label:"Nonprofit",
  id:"Nonprofit",
  hidden:true
 }), model.VideoCategory.create({
  label:"People",
  id:"People",
  hidden:true
 }), model.VideoCategory.create({
  label:"Shows",
  id:"Shows",
  hidden:true
 }), model.VideoCategory.create({
  label:"Sports",
  id:"Sports"
 }), model.VideoCategory.create({
  label:"Tech",
  id:"Tech"
 }), model.VideoCategory.create({
  label:"Trailers",
  id:"Trailers",
  hidden:true
 }), model.VideoCategory.create({
  label:"Travel",
  id:"Travel"
 }) ]);
 dao.store.set("model", model);
 return model;
});

define("utils.sanitizeparams", [ "lodash.noconflict" ], function(_) {
 var configParams = [ "apiKey", "createdTrack", "csrfToken", "element", "environment", "external", "groupId", "loadData", "logLevel", "messages", "nls", "onLoad", "player", "plugins", "queryCache", "rootUrl", "trackId", "projectId", "user", "userId", "username", "version", "videoId", "videoType", "videoUrl" ], viewerParams = [ "annotationSources", "autoplay", "captions", "controls", "controlStyle", "cuePoints", "height", "hideEndAnnotations", "minHeight", "minWidth", "muted", "playerParameters", "playerType", "playlistId", "playlistName", "remotes", "resetVariables", "time", "trackInfo", "variables", "videoTitle", "width" ].concat(configParams), embedParams = [ "aspectRatio", "autoEditDialog", "controlBarHeight", "disableInlineTextEdit", "edit", "embed", "enableAltControls", "hostWindow", "isTemplate", "nativeControls", "startInEditMode" ].concat(viewerParams);
 configParams = configParams.sort();
 viewerParams = viewerParams.sort();
 embedParams = embedParams.sort();
 return {
  config:function(o, e) {
   var p = _.pick(_.extend({}, o, e), configParams);
   return _.omit(p, function(value) {
    return value === undefined;
   });
  },
  viewer:function(o, e) {
   var p = _.pick(_.extend({}, o, e), viewerParams);
   return _.omit(p, function(value) {
    return value === undefined;
   });
  },
  embed:function(o, e) {
   var p = _.pick(_.extend({}, o, e), embedParams);
   return _.omit(p, function(value) {
    return value === undefined;
   });
  }
 };
});

define("utils.samedomain", [], function() {
 return {
  test:function(value) {
   if (hapyak.iframed) {
    return false;
   }
   if (typeof value !== "string") {
    return false;
   }
   var host = location.host.split("."), l = host.length;
   var domain, localDomain;
   if (l > 1) {
    localDomain = host[l - 2] + "." + host[l - 1];
   } else {
    localDomain = host[0];
   }
   if (!localDomain) {
    return false;
   }
   domain = /(?:https?:)?\/\/([^/]+)/i.exec(value);
   if (domain && domain[1]) {
    value = domain[1];
   }
   return value.indexOf(localDomain) !== -1;
  }
 };
});

define("utils.validatelink", [ "configuration", "logging" ], function(configuration, logging) {
 var linkBlacklist, linkWhitelist, firstTime = true;
 return function(link) {
  if (firstTime) {
   if (configuration.player) {
    if (configuration.player.linkBlacklist && configuration.player.linkBlacklist.length) {
     try {
      linkBlacklist = new RegExp(configuration.player.linkBlacklist.join("|"), "i");
     } catch (e) {
      logging.warn("Invalid regular expression: " + configuration.player.linkBlacklist);
     }
    }
    if (configuration.player.linkWhitelist && configuration.player.linkWhitelist.length) {
     try {
      linkWhitelist = new RegExp(configuration.player.linkWhitelist.join("|"), "i");
     } catch (e) {
      logging.warn("Invalid regular expression: " + configuration.player.linkWhitelist);
     }
    }
   }
   firstTime = false;
  }
  if (linkWhitelist && !linkWhitelist.test(link)) {
   return false;
  }
  if (linkBlacklist && linkBlacklist.test(link)) {
   return false;
  }
  return true;
 };
});

(function(root, factory) {
 if (typeof define === "function" && define.amd) {
  define("utils", [ "configuration", "module", "utils.samedomain", "utils.validatelink" ], factory);
 } else {
  root.hapyakUtils = factory(root);
 }
})(this, function(configuration, module, sameDomain, validateLink) {
 var moduleConfig = module.config(), playerConfig = configuration && configuration.player;
 var localLinks = playerConfig.localLinks || moduleConfig.localLinks || false;
 var addClass, hasClass, removeClass, supportsPlaceholder;
 function inputPlaceholder(input, color) {
  var default_color, placeholder;
  if (!input) {
   return null;
  }
  if (supportsPlaceholder === undefined) {
   supportsPlaceholder = "placeholder" in document.createElement(input.tagName);
  }
  if (input.placeholder && supportsPlaceholder) {
   return input;
  }
  color = color || "#AAA";
  default_color = input.style.color;
  placeholder = input.getAttribute("placeholder");
  if (input.value === "" || input.value === placeholder) {
   input.value = placeholder;
   input.style.color = color;
   input.setAttribute("data-placeholder-visible", "true");
  }
  input.addEventListener("focus", function() {
   input.style.color = default_color;
   if (input.getAttribute("data-placeholder-visible")) {
    input.setAttribute("data-placeholder-visible", "");
    if (input.value === placeholder) {
     input.value = "";
    }
   }
  }, false);
  input.addEventListener("blur", function() {
   if (input.value === "") {
    input.setAttribute("data-placeholder-visible", "true");
    input.value = placeholder;
    input.style.color = color;
   } else {
    input.style.color = default_color;
    input.setAttribute("data-placeholder-visible", "");
   }
  }, false);
  if (input.form) {
   input.form.addEventListener("submit", function() {
    if (input.getAttribute("data-placeholder-visible") && input.value === placeholder) {
     input.value = "";
    }
   }, false);
  }
  return input;
 }
 function microTemplate(container, obj, lookup) {
  var element, key, val, eventHandler;
  function replace(str, pre, capital) {
   return pre + "-" + capital.toLowerCase();
  }
  function makeEventListener(fn, element, obj) {
   return function(evt) {
    fn.call(element, evt, obj);
   };
  }
  if (!container) {
   container = document.createDocumentFragment();
  }
  if (!lookup) {
   lookup = {};
  }
  if (Array.isArray(obj)) {
   for (key = 0; key < obj.length; key++) {
    microTemplate(container, obj[key], lookup);
   }
   return lookup;
  }
  if (typeof obj === "object") {
   element = document.createElement(obj[""] || "div");
   for (key in obj) {
    if (obj.hasOwnProperty(key) && key && key !== "#" && key !== ">") {
     val = obj[key];
     if (key === ".") {
      key = "class";
     }
     if (typeof val === "function") {
      eventHandler = /^on([a-z]+)/i.exec(key);
      if (eventHandler) {
       element.addEventListener(eventHandler[1].toLowerCase(), makeEventListener(val, element, obj), false);
       continue;
      }
      val = val.call(element, obj);
     }
     if (typeof val === "string" || val.toString) {
      element.setAttribute(key, val);
     }
    }
   }
   if (obj["#"]) {
    if (!obj["."]) {
     element.className = "hapyak-" + obj["#"].replace(/([a-z])([A-Z])/g, replace);
    }
    lookup[obj["#"]] = element;
   }
   if (obj[">"]) {
    microTemplate(element, obj[">"], lookup);
   }
   container.appendChild(element);
   return lookup;
  }
  if (typeof obj === "string") {
   element = document.createElement("div");
   element.innerHTML = obj;
   while (element.childNodes.length) {
    container.appendChild(element.firstChild);
   }
   return lookup;
  }
 }
 if (document === undefined || !document.createElement("a").classList) {
  addClass = function(element, c) {
   if (!element) {
    return;
   }
   var curClasses = element.getAttribute("class") || "";
   curClasses = curClasses.split(" ");
   if (curClasses.indexOf(c) < 0) {
    curClasses.push(c);
   }
   element.setAttribute("class", curClasses.join(" "));
  };
  removeClass = function(element, c) {
   if (!element) {
    return;
   }
   var i, curClasses = element.getAttribute("class") || "";
   curClasses = curClasses.split(" ");
   i = curClasses.indexOf(c);
   if (i >= 0) {
    curClasses.splice(i, 1);
   }
   element.setAttribute("class", curClasses.join(" "));
  };
  hasClass = function(element, c) {
   if (!element) {
    return false;
   }
   var curClasses = element.getAttribute("class") || "";
   curClasses = curClasses.split(" ");
   return curClasses.indexOf(c) > -1;
  };
 } else {
  addClass = function(element, c) {
   if (!element) {
    return;
   }
   element.classList.add(c);
  };
  removeClass = function(element, c) {
   if (!element) {
    return;
   }
   element.classList.remove(c);
  };
  hasClass = function(element, c) {
   if (!element) {
    return false;
   }
   return element.classList.contains(c);
  };
 }
 return {
  binarySearchByKey:function(array, key, val) {
   var high = array && array.length - 1, low = 0, lowVal, highVal, midVal, mid;
   if (isNaN(high) || high < 0) {
    return -1;
   }
   lowVal = array[0][key];
   if (val < lowVal) {
    return -1;
   }
   if (lowVal === val) {
    return 0;
   }
   highVal = array[high][key];
   if (val >= highVal) {
    return high;
   }
   while (high > low) {
    mid = low + (high - low) / 2 >>> 0;
    midVal = array[mid][key];
    if (midVal > val) {
     high = mid - 1;
     highVal = array[high][key];
     if (highVal <= val) {
      return high;
     }
    } else {
     if (midVal === val || low === mid) {
      return mid;
     }
     low = mid;
    }
   }
   return low;
  },
  observeOneTime:function(object, field, waitForValue, callback) {
   var value, observer;
   if (!callback) {
    callback = waitForValue;
    waitForValue = null;
   }
   value = object.get(field);
   if (value && (!waitForValue || waitForValue(value))) {
    callback(object.get(field));
    return;
   }
   observer = function() {
    var val = object.get(field);
    if (val && (!waitForValue || waitForValue(val))) {
     object.removeObserver(field, observer);
     callback(val);
    }
   };
   object.addObserver(field, observer);
  },
  getPagerText:function(type, data, max) {
   var total = data.get("total"), end = data.get("page") * max, start = end - (max - 1), displayEnd = Math.min(end, total);
   if (start === 1 && displayEnd === 1) {
    return "One " + type + " found";
   }
   if (start === displayEnd) {
    return "Last of " + total + " " + type + "s found";
   }
   return start + " to " + displayEnd + " of " + total + " " + type + "s found";
  },
  instanceOfElement:function(element, proto) {
   var result;
   if (!element || typeof element !== "object" && typeof element !== "function") {
    return false;
   }
   if (!proto) {
    proto = "Element";
   } else if (typeof proto !== "string") {
    return element instanceof proto;
   }
   if (element instanceof window[proto]) {
    return true;
   }
   if (!element.ownerDocument || !element.ownerDocument.defaultView) {
    return false;
   }
   result = element instanceof element.ownerDocument.defaultView[proto];
   return result;
  },
  startsWith:String.prototype.startsWith || function(str) {
   return this.substring(0, str.length) === str;
  },
  listenForPostMessage:function(listener) {
   var addEventMethod = window.addEventListener ? "addEventListener" :"attachEvent", addEventFunction = window[addEventMethod], postMessage = addEventMethod === "addEventListener" ? "message" :"onmessage";
   addEventFunction(postMessage, listener);
  },
  removePostMessageListener:function(listener) {
   var removeEventMethod = window.removeEventListener ? "removeEventListener" :"detachEvent", removeEventFunction = window[removeEventMethod], postMessage = removeEventMethod === "removeEventListener" ? "message" :"onmessage";
   removeEventFunction(postMessage, listener);
  },
  measurePopText:function(trackEvent, baseWidth) {
   var canvas = document.createElement("canvas"), container = trackEvent.container, ctx = canvas.getContext("2d"), fontMod, hasLink, style, text, width = 0;
   style = window.getComputedStyle && window.getComputedStyle(container.firstChild || container);
   if (style) {
    ctx.font = (style.getPropertyValue("font-size") || "18px") + " " + (style.getPropertyValue("font-family") || "Open Sans");
    fontMod = style.getPropertyValue("font-weight");
    if (fontMod && fontMod !== "normal") {
     ctx.font = fontMod + " " + ctx.font;
    }
    fontMod = style.getPropertyValue("font-style");
    if (fontMod && fontMod !== "normal") {
     ctx.font = fontMod + " " + ctx.font;
    }
   } else {
    ctx.font = "18px Open Sans";
   }
   text = trackEvent.text || "";
   text = text.split("\n");
   hasLink = trackEvent.link || trackEvent.onClick && trackEvent.onClick.gotoLink;
   Popcorn.forEach(text, function(t) {
    width = Math.max(width, ctx.measureText(t).width + 2 + (hasLink ? 28 :0));
   });
   width += container.offsetWidth - container.firstChild.offsetWidth;
   width = Math.min(width, 450 * baseWidth / 800);
   return width;
  },
  regex:{
   escape:function(value) {
    return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
   },
   patterns:{
    subdomain:"(?:[a-z]\\.|[a-z][a-z0-9-]{0,61}[a-z0-9]\\.)*?"
   },
   cssRegex:/^[\-\w]+$/,
   linkRegex:/^[\t ]*(((?:https?:\/\/|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,6}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?]))|mailto:)/i,
   onClickVariables:/(?:,|;|^)\s*([a-z_\$]+[a-z_\$0-9]*)(?:(\+\+|\-\-)|\(([0-9]*)\)|(?:\s*=\s*(?:(true|false|undefined|null)|'((?:[^'\\]|\\.)*)'|"((?:[^"\\]|\\.)*)"|([-+]?[0-9]*\.?[0-9]+))))\s*/gi,
   validEmail:/^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
   validDomain:/((?:[a-z]\.|[a-z][a-z0-9-]{0,61}[a-z0-9]\.)*(?:[a-z]|[a-z][a-z0-9-]{0,61}[a-z0-9])(?:\.[a-z]{2,63}))/gi,
   validDomainFilter:/((?:\*\.|[a-z0-9]\.|[a-z0-9][a-z0-9-]{0,61}[a-z0-9]\.)*(?:[a-z0-9]|[a-z0-9][a-z0-9-]{0,61}[a-z0-9])(?:\.[a-z0-9]{2,63}))/gi,
   timeRegex:/^(?:([0-9]+):)?([0-9]+(?:\.[0-9]+)?)$/,
   trackRegex:/^\d+$/,
   templateVarsRegex:function() {
    return /\{\{([a-zA-Z_][a-zA-Z0-9_\.]*)(?:\|([^\}]*))?\}\}/g;
   }
  },
  getTrackTime:function(val) {
   if (!val || !Popcorn.isArray(val)) {
    return;
   }
   return {
    time:parseInt(val[2] || 0, 10) * 60 + parseFloat(val[3]),
    track:parseInt(val[1], 10)
   };
  },
  validateOnClick:function(linkElements) {
   var regex = this.regex, valid = true;
   function validateUrl() {
    var link = linkElements.linkInput.value;
    if (!link.length || regex.linkRegex.test(link)) {
     if (link && !validateLink(link)) {
      removeClass(linkElements.linkInput, "valid");
      return false;
     }
     addClass(linkElements.linkInput, "valid");
     return true;
    }
    removeClass(linkElements.linkInput, "valid");
    return false;
   }
   function validateTrack() {
    if (!linkElements.trackInput.value || regex.trackRegex.test(linkElements.trackInput.value)) {
     addClass(linkElements.trackInput, "valid");
     return true;
    }
    removeClass(linkElements.trackInput, "valid");
    return false;
   }
   function validateTime() {
    var element = hasClass(linkElements.timeInput, "hide") ? linkElements.timeInputSelect :linkElements.timeInput, parsedTime, isDefaultSelectOption = element.nodeName === "SELECT" && element.options[element.selectedIndex].value === "default", value = element.nodeName === "SELECT" ? element.options[element.selectedIndex].value :element.value;
    parsedTime = regex.timeRegex.exec(value);
    if (!value || isDefaultSelectOption || parsedTime && (parsedTime[1] === undefined || parseFloat(parsedTime[2]) < 60)) {
     addClass(element, "valid");
     return true;
    }
    removeClass(element, "valid");
    return false;
   }
   function validateCss() {
    if (!linkElements.cssInput.value || regex.cssRegex.test(linkElements.cssInput.value)) {
     addClass(linkElements.cssInput, "valid");
     return true;
    }
    removeClass(linkElements.cssInput, "valid");
    return false;
   }
   function validateVariable() {
    addClass(linkElements.varInput, "valid");
    return true;
   }
   if (linkElements.linkInput !== undefined) {
    valid = validateUrl();
   }
   if (linkElements.trackInput !== undefined) {
    valid = validateTrack() && valid;
   }
   if (linkElements.timeInput !== undefined) {
    valid = validateTime() && valid;
   }
   if (linkElements.cssInput !== undefined) {
    valid = validateCss() && valid;
   }
   if (linkElements.varInput !== undefined) {
    valid = validateVariable() && valid;
   }
   if (linkElements.timeInputSelect !== undefined) {
    valid = validateTime() && valid;
   }
   return valid;
  },
  navigateToUrl:function(url, target) {
   var iframe, newWindow;
   if (typeof url === "string" && url.length) {
    if (this.startsWith.call(url, "mailto:")) {
     iframe = document.createElement("iframe");
     iframe.width = 0;
     iframe.height = 0;
     document.body.appendChild(iframe);
     iframe.src = url;
     setTimeout(function() {
      document.body.removeChild(iframe);
     }, 0);
    } else {
     if (target) {
      newWindow = window.open(url, target);
     } else if (!localLinks || !sameDomain.test(url)) {
      newWindow = window.open(url, "_blank");
     } else {
      window.location.href = url;
     }
     if (newWindow) {
      newWindow.focus();
     }
    }
   }
   return false;
  },
  microTemplate:microTemplate,
  addClass:addClass,
  hasClass:hasClass,
  removeClass:removeClass,
  inputPlaceholder:inputPlaceholder
 };
});

define("player.wrappers", [ "utils" ], function(utils) {
 var regex = {
  dailymotion:/dailymotion\.com\/(embed\/)?video\/([a-z0-9]+)/i,
  dailymotioninternal:/dmcdn\.net([a-zA-Z0-9\/\-]+\.swf)/,
  brightcoveVideo:/bctid=([0-9]+)/,
  brightcovePlayer:/bcpid([0-9]+)/,
  vimeo1:/player.vimeo.com\/video\/\d+/,
  vimeo2:/vimeo.com\/\d+/,
  wistia:/https?:\/\/(.+)?(wistia\.com|wi\.st)\/(medias|embed)\/.*/,
  youtube:/^(?:http:\/\/www\.|http:\/\/|www\.|\.|^)(youtu)/,
  youtubeEmbed:/^https?:\/\/(?:www\.)?youtube\.com\/embed\/([A-Z0-9\-]+)($|\?.*)/i,
  vzaar:/^https?:\/\/(\w[\w_\-]*\.)*vzaar\.com\/videos\/(\d+)\/?[^\?]*(\?[^#]*)?/i,
  ustream:/^https?:\/\/(\w[\w_\-]*\.)*ustream\.tv\/embed\/recorded\/(\d+)/i
 }, vjsNames = [ "videojs", "vjs", "_V_", "VideoJS" ], detectors = {
  brightcove:function(src) {
   var bc = window.brightcove, tempElem;
   if (bc && bc.experiences && src && src.experience && bc.experiences[src.experience.id]) {
    return src;
   }
   if (!regex.brightcoveVideo.test(src) || !regex.brightcovePlayer.test(src)) {
    return false;
   }
   tempElem = document.createElement("a");
   tempElem.href = src;
   return tempElem.hostname === "link.brightcove.com";
  },
  dailymotion:function(src) {
   var DM = window.DM, player;
   if (DM && DM.Player && DM.Player._INSTANCES) {
    for (player in DM.Player._INSTANCES) {
     if (DM.Player._INSTANCES[player] === src) {
      return src;
     }
    }
   }
   return window.DailymotionPlayer && src instanceof window.DailymotionPlayer || window.DailymotionPlayerFlash && src instanceof window.DailymotionPlayerFlash || window.DailymotionPlayerHTML && src instanceof window.DailymotionPlayerHTML || regex.dailymotion.test(src);
  },
  dailymotioninternal:function(src) {
   var pgv = window.Pg_Video, data;
   if (pgv && pgv.videoPlayer && pgv.videoPlayer === src) {
    return "probably";
   }
   if (src && src.tagName === "OBJECT" && src.getAttribute) {
    data = src.getAttribute("data");
    if (data && regex.dailymotioninternal.test(data)) {
     return "probably";
    }
   }
   return src && src.tagName === "OBJECT" && src.playVideo && "maybe";
  },
  dailymotionv5:function(src, guess) {
   return guess === "dailymotionv5";
  },
  flowplayer:function(src) {
   var flowplayer = window.flowplayer;
   if (flowplayer && src && src.conf && src.video && src.video.url) {
    return src;
   }
   return false;
  },
  jplayer:function(src) {
   var jQuery;
   if (typeof src !== "string") {
    jQuery = window.$ || window.jQuery;
    if (!jQuery.jPlayer) {
     return false;
    }
    src = jQuery(src);
    if (src.data && src.data("jPlayer") && jQuery.jPlayer.prototype.instances[src.data("jPlayer").internal.instance]) {
     return src;
    }
   }
   return false;
  },
  jwplayer:function(src) {
   var jwplayer = window.jwplayer, item, i = 0;
   if (jwplayer) {
    item = jwplayer(i);
    while (item.config) {
     if (item === jwplayer(src.container)) {
      return item;
     }
     i++;
     item = jwplayer(i);
    }
   }
   return false;
  },
  mediaelement:function(src) {
   var MediaElement = window.MediaElement, mejs = window.mejs, player;
   if (MediaElement && mejs && mejs.players) {
    for (player in mejs.players) {
     if (mejs.players[player] === src) {
      return src;
     }
    }
   }
   return false;
  },
  skeleton:function(src) {
   return src;
  },
  ustream:function(src) {
   if (window.UstreamEmbed && src.host === "http://ustream.tv") {
    return src;
   }
   return regex.ustream.test(src) ? src :false;
  },
  videojs:function(src) {
   var vjs, name, i, byName, id, playerObject, player;
   if (!src) {
    return false;
   }
   for (i = 0; i < vjsNames.length; i++) {
    name = vjsNames[i];
    if (window[name] && typeof window[name].Player === "function") {
     vjs = window[name];
     if (src instanceof vjs.Player) {
      return src;
     }
     break;
    }
   }
   if (!vjs) {
    return;
   }
   byName = typeof src === "string";
   if (byName) {
    id = src;
   } else if (typeof src.id === "function") {
    id = src.id();
   } else {
    id = src.id;
   }
   playerObject = vjs.players;
   if (playerObject) {
    player = playerObject[id];
   }
   if (player && (byName || src === player)) {
    return player;
   }
   if (typeof src !== "object" || !(vjs.Player && src instanceof vjs.Player) || !playerObject) {
    return false;
   }
   for (id in playerObject) {
    if (playerObject.hasOwnProperty(id) && playerObject[id] === src) {
     return src;
    }
   }
   return false;
  },
  vimeo:function(src) {
   return regex.vimeo1.test(src) || regex.vimeo2.test(src) ? src :false;
  },
  vzaar:function(src) {
   if (window.vzPlayer && src instanceof window.vzPlayer) {
    return src;
   }
   return regex.vzaar.test(src) ? src :false;
  },
  wistia:function(src) {
   var Wistia = window.Wistia;
   if (Wistia && Wistia._data && Wistia._data.video && Wistia._data.video[src.uuid]) {
    return src;
   }
   if (typeof src !== "string") {
    return false;
   }
   return regex.wistia.test(src) ? src :false;
  },
  youtube:function(src) {
   if (utils.instanceOfElement(src, "HTMLIFrameElement") && src.src && regex.youtubeEmbed.test(src.src)) {
    return src;
   }
   if (!window.YT || !src || !window.YT.Player) {
    return false;
   }
   if (src instanceof window.YT.Player) {
    return src;
   }
   return false;
  }
 };
 function WrapperRegistry() {}
 WrapperRegistry.prototype.detect = function(src, guess) {
  var i, result;
  result = guess && detectors[guess] && detectors[guess](src, guess);
  if (result) {
   return guess;
  }
  for (i in detectors) {
   if (detectors.hasOwnProperty(i)) {
    result = detectors[i](src);
    if (result === true || result === "probably") {
     return i;
    }
   }
  }
  return false;
 };
 return new WrapperRegistry();
});

(function(global, document) {
 if (!document.addEventListener) {
  global.Popcorn = {
   isSupported:false
  };
  var methods = ("byId forEach extend effects error guid sizeOf isArray nop position disable enable destroy" + "addTrackEvent removeTrackEvent getTrackEvents getTrackEvent getLastTrackEventId " + "timeUpdate plugin removePlugin compose effect xhr getJSONP getScript").split(/\s+/);
  while (methods.length) {
   global.Popcorn[methods.shift()] = function() {};
  }
  return;
 }
 var AP = Array.prototype, OP = Object.prototype, forEach = AP.forEach, slice = AP.slice, hasOwn = OP.hasOwnProperty, toString = OP.toString, _Popcorn = global.Popcorn, readyStack = [], readyBound = false, readyFired = false, internal = {
  events:{
   hash:{},
   apis:{}
  }
 }, requestAnimFrame = function() {
  return global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame || global.msRequestAnimationFrame || function(callback, element) {
   global.setTimeout(callback, 16);
  };
 }(), getKeys = function(obj) {
  return Object.keys ? Object.keys(obj) :function(obj) {
   var item, list = [];
   for (item in obj) {
    if (hasOwn.call(obj, item)) {
     list.push(item);
    }
   }
   return list;
  }(obj);
 }, Abstract = {
  put:function(dictionary) {
   Object.getOwnPropertyNames(dictionary).forEach(function(key) {
    this[key] = dictionary[key];
   }, this);
  }
 }, Popcorn = function(entity, options) {
  return new Popcorn.p.init(entity, options || null);
 };
 Popcorn.version = "@VERSION";
 Popcorn.isSupported = true;
 Popcorn.instances = [];
 Popcorn.p = Popcorn.prototype = {
  init:function(entity, options) {
   var matches, nodeName, self = this;
   if (typeof entity === "function") {
    if (document.readyState === "complete") {
     entity(document, Popcorn);
     return;
    }
    readyStack.push(entity);
    if (!readyBound) {
     readyBound = true;
     var DOMContentLoaded = function() {
      readyFired = true;
      document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
      for (var i = 0, readyStackLength = readyStack.length; i < readyStackLength; i++) {
       readyStack[i].call(document, Popcorn);
      }
      readyStack = null;
     };
     document.addEventListener("DOMContentLoaded", DOMContentLoaded, false);
    }
    return;
   }
   if (typeof entity === "string") {
    try {
     matches = document.querySelector(entity);
    } catch (e) {
     throw new Error("Popcorn.js Error: Invalid media element selector: " + entity);
    }
   }
   this.media = matches || entity;
   nodeName = this.media.nodeName && this.media.nodeName.toLowerCase() || "video";
   this[nodeName] = this.media;
   this.options = options || {};
   this.id = this.options.id || Popcorn.guid(nodeName);
   if (Popcorn.byId(this.id)) {
    throw new Error("Popcorn.js Error: Cannot use duplicate ID (" + this.id + ")");
   }
   this.isDestroyed = false;
   this.data = {
    running:{
     cue:[]
    },
    timeUpdate:Popcorn.nop,
    disabled:{},
    events:{},
    hooks:{},
    history:[],
    state:{
     volume:this.media.volume
    },
    trackRefs:{},
    trackEvents:new TrackEvents()
   };
   Popcorn.instances.push(this);
   var isReady = function() {
    if (self.media.currentTime < 0) {
     self.media.currentTime = 0;
    }
    self.media.removeEventListener("loadedmetadata", isReady, false);
    var duration, videoDurationPlus, runningPlugins, runningPlugin, rpLength, rpNatives;
    duration = self.media.duration;
    videoDurationPlus = duration != duration ? Number.MAX_VALUE :duration + 1;
    Popcorn.addTrackEvent(self, {
     start:videoDurationPlus,
     end:videoDurationPlus
    });
    if (self.options.frameAnimation) {
     self.data.timeUpdate = function() {
      Popcorn.timeUpdate(self, {});
      Popcorn.forEach(Popcorn.manifest, function(key, val) {
       runningPlugins = self.data.running[val];
       if (runningPlugins) {
        rpLength = runningPlugins.length;
        for (var i = 0; i < rpLength; i++) {
         runningPlugin = runningPlugins[i];
         rpNatives = runningPlugin._natives;
         rpNatives && rpNatives.frame && rpNatives.frame.call(self, {}, runningPlugin, self.currentTime());
        }
       }
      });
      self.emit("timeupdate");
      !self.isDestroyed && requestAnimFrame(self.data.timeUpdate);
     };
     !self.isDestroyed && requestAnimFrame(self.data.timeUpdate);
    } else {
     self.data.timeUpdate = function(event) {
      Popcorn.timeUpdate(self, event);
     };
     if (!self.isDestroyed) {
      self.media.addEventListener("timeupdate", self.data.timeUpdate, false);
     }
    }
   };
   Object.defineProperty(this, "error", {
    get:function() {
     return self.media.error;
    }
   });
   if (self.media.readyState >= 1) {
    isReady();
   } else {
    self.media.addEventListener("loadedmetadata", isReady, false);
   }
   return this;
  }
 };
 Popcorn.p.init.prototype = Popcorn.p;
 Popcorn.byId = function(str) {
  var instances = Popcorn.instances, length = instances.length, i = 0;
  for (;i < length; i++) {
   if (instances[i].id === str) {
    return instances[i];
   }
  }
  return null;
 };
 Popcorn.forEach = function(obj, fn, context) {
  if (!obj || !fn) {
   return {};
  }
  context = context || this;
  var key, len;
  if (forEach && obj.forEach === forEach) {
   return obj.forEach(fn, context);
  }
  if (toString.call(obj) === "[object NodeList]") {
   for (key = 0, len = obj.length; key < len; key++) {
    fn.call(context, obj[key], key, obj);
   }
   return obj;
  }
  for (key in obj) {
   if (hasOwn.call(obj, key)) {
    fn.call(context, obj[key], key, obj);
   }
  }
  return obj;
 };
 Popcorn.extend = function(obj) {
  var dest = obj, src = slice.call(arguments, 1);
  Popcorn.forEach(src, function(copy) {
   for (var prop in copy) {
    dest[prop] = copy[prop];
   }
  });
  return dest;
 };
 Popcorn.extend(Popcorn, {
  noConflict:function(deep) {
   if (deep) {
    global.Popcorn = _Popcorn;
   }
   return Popcorn;
  },
  error:function(msg) {
   throw new Error(msg);
  },
  guid:function(prefix) {
   Popcorn.guid.counter++;
   return (prefix ? prefix :"") + (+new Date() + Popcorn.guid.counter);
  },
  sizeOf:function(obj) {
   var size = 0;
   for (var prop in obj) {
    size++;
   }
   return size;
  },
  isArray:Array.isArray || function(array) {
   return toString.call(array) === "[object Array]";
  },
  nop:function() {},
  position:function(elem) {
   var clientRect = elem.getBoundingClientRect(), bounds = {}, doc = elem.ownerDocument, docElem = document.documentElement, body = document.body, clientTop, clientLeft, scrollTop, scrollLeft, top, left;
   clientTop = docElem.clientTop || body.clientTop || 0;
   clientLeft = docElem.clientLeft || body.clientLeft || 0;
   scrollTop = global.pageYOffset && docElem.scrollTop || body.scrollTop;
   scrollLeft = global.pageXOffset && docElem.scrollLeft || body.scrollLeft;
   top = Math.ceil(clientRect.top + scrollTop - clientTop);
   left = Math.ceil(clientRect.left + scrollLeft - clientLeft);
   for (var p in clientRect) {
    bounds[p] = Math.round(clientRect[p]);
   }
   return Popcorn.extend({}, bounds, {
    top:top,
    left:left
   });
  },
  disable:function(instance, plugin) {
   if (instance.data.disabled[plugin]) {
    return;
   }
   instance.data.disabled[plugin] = true;
   if (plugin in Popcorn.registryByName && instance.data.running[plugin]) {
    for (var i = instance.data.running[plugin].length - 1, event; i >= 0; i--) {
     event = instance.data.running[plugin][i];
     event._natives.end.call(instance, null, event);
     instance.emit("trackend", Popcorn.extend({}, event, {
      plugin:event.type,
      type:"trackend",
      track:event
     }));
    }
   }
   return instance;
  },
  enable:function(instance, plugin) {
   if (!instance.data.disabled[plugin]) {
    return;
   }
   instance.data.disabled[plugin] = false;
   if (plugin in Popcorn.registryByName && instance.data.running[plugin]) {
    for (var i = instance.data.running[plugin].length - 1, event; i >= 0; i--) {
     event = instance.data.running[plugin][i];
     event._natives.start.call(instance, null, event);
     instance.emit("trackstart", Popcorn.extend({}, event, {
      plugin:event.type,
      type:"trackstart",
      track:event
     }));
    }
   }
   return instance;
  },
  destroy:function(instance) {
   var events = instance.data.events, trackEvents = instance.data.trackEvents, singleEvent, item, fn, plugin;
   for (item in events) {
    singleEvent = events[item];
    for (fn in singleEvent) {
     delete singleEvent[fn];
    }
    events[item] = null;
   }
   for (plugin in Popcorn.registryByName) {
    Popcorn.removePlugin(instance, plugin);
   }
   trackEvents.byStart.length = 0;
   trackEvents.byEnd.length = 0;
   if (!instance.isDestroyed) {
    instance.data.timeUpdate && instance.media.removeEventListener("timeupdate", instance.data.timeUpdate, false);
    instance.isDestroyed = true;
   }
   Popcorn.instances.splice(Popcorn.instances.indexOf(instance), 1);
  }
 });
 Popcorn.guid.counter = 1;
 Popcorn.extend(Popcorn.p, function() {
  var methods = "load play pause currentTime playbackRate volume duration preload playbackRate " + "autoplay loop controls muted buffered readyState seeking paused played seekable ended", ret = {};
  Popcorn.forEach(methods.split(/\s+/g), function(name) {
   ret[name] = function(arg) {
    var previous;
    if (typeof this.media[name] === "function") {
     if (arg != null && /play|pause/.test(name)) {
      this.media.currentTime = Popcorn.util.toSeconds(arg);
     }
     this.media[name]();
     return this;
    }
    if (arg != null) {
     previous = this.media[name];
     this.media[name] = arg;
     if (previous !== arg) {
      this.emit("attrchange", {
       attribute:name,
       previousValue:previous,
       currentValue:arg
      });
     }
     return this;
    }
    return this.media[name];
   };
  });
  return ret;
 }());
 Popcorn.forEach("enable disable".split(" "), function(method) {
  Popcorn.p[method] = function(plugin) {
   return Popcorn[method](this, plugin);
  };
 });
 Popcorn.extend(Popcorn.p, {
  roundTime:function() {
   return Math.round(this.media.currentTime);
  },
  exec:function(id, time, fn) {
   var length = arguments.length, trackEvent, sec;
   try {
    sec = Popcorn.util.toSeconds(id);
   } catch (e) {}
   if (typeof sec === "number") {
    id = sec;
   }
   if (typeof id === "number" && length === 2) {
    fn = time;
    time = id;
    id = Popcorn.guid("cue");
   } else {
    if (length === 1) {
     time = -1;
    } else {
     trackEvent = this.getTrackEvent(id);
     if (trackEvent) {
      if (typeof id === "string" && length === 2) {
       if (typeof time === "number") {
        fn = trackEvent._natives.start;
       }
       if (typeof time === "function") {
        fn = time;
        time = trackEvent.start;
       }
      }
     } else {
      if (length >= 2) {
       if (typeof time === "string") {
        try {
         sec = Popcorn.util.toSeconds(time);
        } catch (e) {}
        time = sec;
       }
       if (typeof time === "number") {
        fn = fn || Popcorn.nop();
       }
       if (typeof time === "function") {
        fn = time;
        time = -1;
       }
      }
     }
    }
   }
   Popcorn.addTrackEvent(this, {
    id:id,
    start:time,
    end:time + 1,
    _running:false,
    _natives:{
     start:fn || Popcorn.nop,
     end:Popcorn.nop,
     type:"cue"
    }
   });
   return this;
  },
  mute:function(toggle) {
   var event = toggle == null || toggle === true ? "muted" :"unmuted";
   if (event === "unmuted") {
    this.media.muted = false;
    this.media.volume = this.data.state.volume;
   }
   if (event === "muted") {
    this.data.state.volume = this.media.volume;
    this.media.muted = true;
   }
   this.emit(event);
   return this;
  },
  unmute:function(toggle) {
   return this.mute(toggle == null ? false :!toggle);
  },
  position:function() {
   return Popcorn.position(this.media);
  },
  toggle:function(plugin) {
   return Popcorn[this.data.disabled[plugin] ? "enable" :"disable"](this, plugin);
  },
  defaults:function(plugin, defaults) {
   if (Popcorn.isArray(plugin)) {
    Popcorn.forEach(plugin, function(obj) {
     for (var name in obj) {
      this.defaults(name, obj[name]);
     }
    }, this);
    return this;
   }
   if (!this.options.defaults) {
    this.options.defaults = {};
   }
   if (!this.options.defaults[plugin]) {
    this.options.defaults[plugin] = {};
   }
   Popcorn.extend(this.options.defaults[plugin], defaults);
   return this;
  }
 });
 Popcorn.Events = {
  UIEvents:"blur focus focusin focusout load resize scroll unload",
  MouseEvents:"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave click dblclick",
  Events:"loadstart progress suspend emptied stalled play pause error " + "loadedmetadata loadeddata waiting playing canplay canplaythrough " + "seeking seeked timeupdate ended ratechange durationchange volumechange"
 };
 Popcorn.Events.Natives = Popcorn.Events.UIEvents + " " + Popcorn.Events.MouseEvents + " " + Popcorn.Events.Events;
 internal.events.apiTypes = [ "UIEvents", "MouseEvents", "Events" ];
 (function(events, data) {
  var apis = internal.events.apiTypes, eventsList = events.Natives.split(/\s+/g), idx = 0, len = eventsList.length, prop;
  for (;idx < len; idx++) {
   data.hash[eventsList[idx]] = true;
  }
  apis.forEach(function(val, idx) {
   data.apis[val] = {};
   var apiEvents = events[val].split(/\s+/g), len = apiEvents.length, k = 0;
   for (;k < len; k++) {
    data.apis[val][apiEvents[k]] = true;
   }
  });
 })(Popcorn.Events, internal.events);
 Popcorn.events = {
  isNative:function(type) {
   return !!internal.events.hash[type];
  },
  getInterface:function(type) {
   if (!Popcorn.events.isNative(type)) {
    return false;
   }
   var eventApi = internal.events, apis = eventApi.apiTypes, apihash = eventApi.apis, idx = 0, len = apis.length, api, tmp;
   for (;idx < len; idx++) {
    tmp = apis[idx];
    if (apihash[tmp][type]) {
     api = tmp;
     break;
    }
   }
   return api;
  },
  all:Popcorn.Events.Natives.split(/\s+/g),
  fn:{
   trigger:function(type, data) {
    var eventInterface, evt, clonedEvents, events = this.data.events[type];
    if (events) {
     eventInterface = Popcorn.events.getInterface(type);
     if (eventInterface) {
      evt = document.createEvent(eventInterface);
      evt.initEvent(type, true, true, global, 1);
      this.media.dispatchEvent(evt);
      return this;
     }
     clonedEvents = events.slice();
     while (clonedEvents.length) {
      clonedEvents.shift().call(this, data);
     }
    }
    return this;
   },
   listen:function(type, fn) {
    var self = this, hasEvents = true, eventHook = Popcorn.events.hooks[type], origType = type, clonedEvents, tmp;
    if (typeof fn !== "function") {
     throw new Error("Popcorn.js Error: Listener is not a function");
    }
    if (!this.data.events[type]) {
     this.data.events[type] = [];
     hasEvents = false;
    }
    if (eventHook) {
     if (eventHook.add) {
      eventHook.add.call(this, {}, fn);
     }
     if (eventHook.bind) {
      type = eventHook.bind;
     }
     if (eventHook.handler) {
      tmp = fn;
      fn = function wrapper(event) {
       eventHook.handler.call(self, event, tmp);
      };
     }
     hasEvents = true;
     if (!this.data.events[type]) {
      this.data.events[type] = [];
      hasEvents = false;
     }
    }
    this.data.events[type].push(fn);
    if (!hasEvents && Popcorn.events.all.indexOf(type) > -1) {
     this.media.addEventListener(type, function(event) {
      if (self.data.events[type]) {
       clonedEvents = self.data.events[type].slice();
       while (clonedEvents.length) {
        clonedEvents.shift().call(self, event);
       }
      }
     }, false);
    }
    return this;
   },
   unlisten:function(type, fn) {
    var ind, events = this.data.events[type];
    if (!events) {
     return;
    }
    if (typeof fn === "string") {
     for (var i = 0; i < events.length; i++) {
      if (events[i].name === fn) {
       events.splice(i--, 1);
      }
     }
     return this;
    } else if (typeof fn === "function") {
     while (ind !== -1) {
      ind = events.indexOf(fn);
      if (ind !== -1) {
       events.splice(ind, 1);
      }
     }
     return this;
    }
    this.data.events[type] = null;
    return this;
   }
  },
  hooks:{
   canplayall:{
    bind:"canplaythrough",
    add:function(event, callback) {
     var state = false;
     if (this.media.readyState) {
      callback.call(this, event);
      state = true;
     }
     this.data.hooks.canplayall = {
      fired:state
     };
    },
    handler:function canplayall(event, callback) {
     if (!this.data.hooks.canplayall.fired) {
      callback.call(this, event);
      this.data.hooks.canplayall.fired = true;
     }
    }
   }
  }
 };
 Popcorn.forEach([ [ "trigger", "emit" ], [ "listen", "on" ], [ "unlisten", "off" ] ], function(key) {
  Popcorn.p[key[0]] = Popcorn.p[key[1]] = Popcorn.events.fn[key[0]];
 });
 function TrackEvent(track) {
  Abstract.put.call(this, track);
 }
 function TrackEvents() {
  this.byStart = [ {
   start:-1,
   end:-1
  } ];
  this.byEnd = [ {
   start:-1,
   end:-1
  } ];
  this.animating = [];
  this.startIndex = 0;
  this.endIndex = 0;
  this.previousUpdateTime = -1;
 }
 function addToArray(obj, track) {
  var byStart = obj.data.trackEvents.byStart, byEnd = obj.data.trackEvents.byEnd, startIndex, endIndex;
  if (track && track._id) {
   obj.data.history.push(track._id);
  }
  track.start = Popcorn.util.toSeconds(track.start, obj.options.framerate);
  track.end = Popcorn.util.toSeconds(track.end, obj.options.framerate);
  for (startIndex = byStart.length - 1; startIndex >= 0; startIndex--) {
   if (track.start >= byStart[startIndex].start) {
    byStart.splice(startIndex + 1, 0, track);
    break;
   }
  }
  for (endIndex = byEnd.length - 1; endIndex >= 0; endIndex--) {
   if (track.end > byEnd[endIndex].end) {
    byEnd.splice(endIndex + 1, 0, track);
    break;
   }
  }
  if (startIndex <= obj.data.trackEvents.startIndex && track.start <= obj.data.trackEvents.previousUpdateTime) {
   obj.data.trackEvents.startIndex++;
  }
  if (endIndex <= obj.data.trackEvents.endIndex && track.end < obj.data.trackEvents.previousUpdateTime) {
   obj.data.trackEvents.endIndex++;
  }
  if (track.end > obj.media.currentTime && track.start <= obj.media.currentTime) {
   track._running = true;
   obj.data.running[track._natives.type].push(track);
   if (!obj.data.disabled[track._natives.type]) {
    track._natives.start.call(obj, null, track);
    obj.emit("trackstart", Popcorn.extend({}, track, {
     plugin:track._natives.type,
     type:"trackstart",
     track:track
    }));
   }
  }
 }
 function removeFromArray(obj, removeId) {
  var start, end, animate, historyLen, length = obj.data.trackEvents.byStart.length, index = 0, indexWasAt = 0, byStart = [], byEnd = [], animating = [], history = [], track, runningPlugins;
  while (--length > -1) {
   start = obj.data.trackEvents.byStart[index];
   end = obj.data.trackEvents.byEnd[index];
   if (!start._id) {
    byStart.push(start);
    byEnd.push(end);
   }
   if (start._id) {
    if (start._id !== removeId) {
     byStart.push(start);
    }
    if (end._id !== removeId) {
     byEnd.push(end);
    }
    if (start._id === removeId) {
     indexWasAt = index;
     track = start;
    }
   }
   index++;
  }
  track = obj.getTrackEvent(removeId);
  if (track) {
   runningPlugins = obj.data.running[track._natives.type];
   index = runningPlugins.indexOf(track);
   if (index > -1) {
    runningPlugins.splice(index, 1);
   }
  }
  length = obj.data.trackEvents.animating.length;
  index = 0;
  if (length) {
   while (--length > -1) {
    animate = obj.data.trackEvents.animating[index];
    if (!animate._id) {
     animating.push(animate);
    }
    if (animate._id && animate._id !== removeId) {
     animating.push(animate);
    }
    index++;
   }
  }
  if (indexWasAt <= obj.data.trackEvents.startIndex) {
   obj.data.trackEvents.startIndex--;
  }
  if (indexWasAt <= obj.data.trackEvents.endIndex) {
   obj.data.trackEvents.endIndex--;
  }
  obj.data.trackEvents.byStart = byStart;
  obj.data.trackEvents.byEnd = byEnd;
  obj.data.trackEvents.animating = animating;
  historyLen = obj.data.history.length;
  for (var i = 0; i < historyLen; i++) {
   if (obj.data.history[i] !== removeId) {
    history.push(obj.data.history[i]);
   }
  }
  obj.data.history = history;
 }
 Popcorn.addTrackEvent = function(obj, track) {
  var trackEvent, isUpdate, eventType, id;
  track = new TrackEvent(track);
  id = track.id || track._id;
  if (id) {
   trackEvent = obj.getTrackEvent(id);
  }
  if (trackEvent) {
   isUpdate = true;
   track = Popcorn.extend({}, trackEvent, track);
   obj.removeTrackEvent(id);
  }
  if (track && track._natives && track._natives.type && (obj.options.defaults && obj.options.defaults[track._natives.type])) {
   track = Popcorn.extend({}, obj.options.defaults[track._natives.type], track);
  }
  if (track._natives) {
   track._id = track.id || track._id || Popcorn.guid(track._natives.type);
   if (track._natives._setup) {
    track._natives._setup.call(obj, track);
    obj.emit("tracksetup", Popcorn.extend({}, track, {
     plugin:track._natives.type,
     type:"tracksetup",
     track:track
    }));
   }
  }
  addToArray(obj, track);
  this.timeUpdate(obj, null, true);
  if (track._id) {
   Popcorn.addTrackEvent.ref(obj, track);
  }
  if (isUpdate) {
   if (track._natives.type === "cue") {
    eventType = "cuechange";
   } else {
    eventType = "trackchange";
   }
   obj.emit(eventType, {
    id:track.id,
    previousValue:{
     time:trackEvent.start,
     fn:trackEvent._natives.start
    },
    currentValue:{
     time:track.start,
     fn:track._natives.start
    },
    track:track
   });
  } else if (track._natives) {
   obj.emit("trackadded", Popcorn.extend({}, track, {
    plugin:track._natives.type,
    type:"trackadded",
    track:track
   }));
  }
 };
 Popcorn.addTrackEvent.ref = function(obj, track) {
  obj.data.trackRefs[track._id] = track;
  return obj;
 };
 Popcorn.removeTrackEvent = function(obj, removeId) {
  var track = obj.getTrackEvent(removeId);
  if (!track) {
   return;
  }
  if (track._natives._teardown) {
   track._natives._teardown.call(obj, track);
  }
  removeFromArray(obj, removeId);
  runningPlugins = obj.data.running[track._natives.type];
  index = runningPlugins.indexOf(track);
  if (index >= 0) {
   track._running = false;
   runningPlugins.splice(index, 1);
   if (!obj.data.disabled[track._natives.type]) {
    track._natives.end.call(obj, null, track);
    obj.emit("trackend", Popcorn.extend({}, track, {
     plugin:track.type,
     type:"trackend",
     track:track
    }));
   }
  }
 };
 Popcorn.addTrackEvent = function(obj, track) {
  var trackEvent, isUpdate, eventType, id;
  track = new TrackEvent(track);
  id = track.id || track._id;
  if (id) {
   trackEvent = obj.getTrackEvent(id);
  }
  if (trackEvent) {
   isUpdate = true;
   track = Popcorn.extend({}, trackEvent, track);
   obj.removeTrackEvent(id);
  }
  if (track && track._natives && track._natives.type && (obj.options.defaults && obj.options.defaults[track._natives.type])) {
   track = Popcorn.extend({}, obj.options.defaults[track._natives.type], track);
  }
  if (track._natives) {
   track._id = track.id || track._id || Popcorn.guid(track._natives.type);
   if (track._natives._setup) {
    track._natives._setup.call(obj, track);
    obj.emit("tracksetup", Popcorn.extend({}, track, {
     plugin:track._natives.type,
     type:"tracksetup",
     track:track
    }));
   }
  }
  addToArray(obj, track);
  this.timeUpdate(obj, null, true);
  if (track._id) {
   Popcorn.addTrackEvent.ref(obj, track);
  }
  if (isUpdate) {
   if (track._natives.type === "cue") {
    eventType = "cuechange";
   } else {
    eventType = "trackchange";
   }
   obj.emit(eventType, {
    id:track.id,
    previousValue:{
     time:trackEvent.start,
     fn:trackEvent._natives.start
    },
    currentValue:{
     time:track.start,
     fn:track._natives.start
    },
    track:track
   });
  } else if (track._natives) {
   obj.emit("trackadded", Popcorn.extend({}, track, {
    plugin:track._natives.type,
    type:"trackadded",
    track:track
   }));
  }
 };
 Popcorn.addTrackEvent.ref = function(obj, track) {
  obj.data.trackRefs[track._id] = track;
  return obj;
 };
 Popcorn.removeTrackEvent = function(obj, removeId) {
  var track = obj.getTrackEvent(removeId);
  if (!track) {
   return;
  }
  if (track._natives._teardown) {
   track._natives._teardown.call(obj, track);
  }
  removeFromArray(obj, removeId);
  Popcorn.removeTrackEvent.ref(obj, removeId);
  if (track._natives) {
   obj.emit("trackremoved", Popcorn.extend({}, track, {
    plugin:track._natives.type,
    type:"trackremoved"
   }));
  }
 };
 Popcorn.removeTrackEvent.ref = function(obj, removeId) {
  delete obj.data.trackRefs[removeId];
  return obj;
 };
 Popcorn.getTrackEvents = function(obj) {
  var trackevents = [], refs = obj.data.trackEvents.byStart, length = refs.length, idx = 0, ref;
  for (;idx < length; idx++) {
   ref = refs[idx];
   if (ref._id) {
    trackevents.push(ref);
   }
  }
  return trackevents;
 };
 Popcorn.getTrackEvents.ref = function(obj) {
  return obj.data.trackRefs;
 };
 Popcorn.getTrackEvent = function(obj, trackId) {
  return obj.data.trackRefs[trackId];
 };
 Popcorn.getTrackEvent.ref = function(obj, trackId) {
  return obj.data.trackRefs[trackId];
 };
 Popcorn.getLastTrackEventId = function(obj) {
  return obj.data.history[obj.data.history.length - 1];
 };
 Popcorn.timeUpdate = function(obj, event) {
  var currentTime = obj.media.currentTime, previousTime = obj.data.trackEvents.previousUpdateTime, tracks = obj.data.trackEvents, end = tracks.endIndex, start = tracks.startIndex, byStartLen = tracks.byStart.length, byEndLen = tracks.byEnd.length, registryByName = Popcorn.registryByName, trackstart = "trackstart", trackend = "trackend", byEnd, byStart, byAnimate, natives, type, runningPlugins;
  if (previousTime <= currentTime) {
   while (tracks.byEnd[end] && tracks.byEnd[end].end <= currentTime) {
    byEnd = tracks.byEnd[end];
    natives = byEnd._natives;
    type = natives && natives.type;
    if (!natives || (!!registryByName[type] || !!obj[type])) {
     if (byEnd._running === true) {
      byEnd._running = false;
      runningPlugins = obj.data.running[type];
      runningPlugins.splice(runningPlugins.indexOf(byEnd), 1);
      if (!obj.data.disabled[type]) {
       natives.end.call(obj, event, byEnd);
       obj.emit(trackend, Popcorn.extend({}, byEnd, {
        plugin:type,
        type:trackend,
        track:byEnd
       }));
      }
     }
     end++;
    } else {
     Popcorn.removeTrackEvent(obj, byEnd._id);
     return;
    }
   }
   while (tracks.byStart[start] && tracks.byStart[start].start <= currentTime) {
    byStart = tracks.byStart[start];
    natives = byStart._natives;
    type = natives && natives.type;
    if (!natives || (!!registryByName[type] || !!obj[type])) {
     if (byStart.end > currentTime && byStart._running === false) {
      byStart._running = true;
      obj.data.running[type].push(byStart);
      if (!obj.data.disabled[type]) {
       natives.start.call(obj, event, byStart);
       obj.emit(trackstart, Popcorn.extend({}, byStart, {
        plugin:type,
        type:trackstart,
        track:byStart
       }));
      }
     }
     start++;
    } else {
     Popcorn.removeTrackEvent(obj, byStart._id);
     return;
    }
   }
  } else if (previousTime > currentTime) {
   while (tracks.byStart[start] && tracks.byStart[start].start > currentTime) {
    byStart = tracks.byStart[start];
    natives = byStart._natives;
    type = natives && natives.type;
    if (!natives || (!!registryByName[type] || !!obj[type])) {
     if (byStart._running === true) {
      byStart._running = false;
      runningPlugins = obj.data.running[type];
      runningPlugins.splice(runningPlugins.indexOf(byStart), 1);
      if (!obj.data.disabled[type]) {
       natives.end.call(obj, event, byStart);
       obj.emit(trackend, Popcorn.extend({}, byStart, {
        plugin:type,
        type:trackend,
        track:byEnd
       }));
      }
     }
     start--;
    } else {
     Popcorn.removeTrackEvent(obj, byStart._id);
     return;
    }
   }
   while (tracks.byEnd[end] && tracks.byEnd[end].end > currentTime) {
    byEnd = tracks.byEnd[end];
    natives = byEnd._natives;
    type = natives && natives.type;
    if (!natives || (!!registryByName[type] || !!obj[type])) {
     if (byEnd.start <= currentTime && byEnd._running === false) {
      byEnd._running = true;
      obj.data.running[type].push(byEnd);
      if (!obj.data.disabled[type]) {
       natives.start.call(obj, event, byEnd);
       obj.emit(trackstart, Popcorn.extend({}, byEnd, {
        plugin:type,
        type:trackstart,
        track:byEnd
       }));
      }
     }
     end--;
    } else {
     Popcorn.removeTrackEvent(obj, byEnd._id);
     return;
    }
   }
  }
  tracks.endIndex = end;
  tracks.startIndex = start;
  tracks.previousUpdateTime = currentTime;
  tracks.byStart.length < byStartLen && tracks.startIndex--;
  tracks.byEnd.length < byEndLen && tracks.endIndex--;
 };
 Popcorn.extend(Popcorn.p, {
  getTrackEvents:function() {
   return Popcorn.getTrackEvents.call(null, this);
  },
  getTrackEvent:function(id) {
   return Popcorn.getTrackEvent.call(null, this, id);
  },
  getLastTrackEventId:function() {
   return Popcorn.getLastTrackEventId.call(null, this);
  },
  removeTrackEvent:function(id) {
   Popcorn.removeTrackEvent.call(null, this, id);
   return this;
  },
  removePlugin:function(name) {
   Popcorn.removePlugin.call(null, this, name);
   return this;
  },
  timeUpdate:function(event) {
   Popcorn.timeUpdate.call(null, this, event);
   return this;
  },
  destroy:function() {
   Popcorn.destroy.call(null, this);
   return this;
  }
 });
 Popcorn.manifest = {};
 Popcorn.registry = [];
 Popcorn.registryByName = {};
 Popcorn.plugin = function(name, definition, manifest) {
  if (Popcorn.protect.natives.indexOf(name.toLowerCase()) >= 0) {
   Popcorn.error("'" + name + "' is a protected function name");
   return;
  }
  var isfn = typeof definition === "function", blacklist = [ "start", "end", "type", "manifest" ], methods = [ "_setup", "_teardown", "start", "end", "frame" ], plugin = {}, setup;
  var combineFn = function(first, second) {
   first = first || Popcorn.nop;
   second = second || Popcorn.nop;
   return function() {
    first.apply(this, arguments);
    second.apply(this, arguments);
   };
  };
  Popcorn.manifest[name] = manifest = manifest || definition.manifest || {};
  methods.forEach(function(method) {
   definition[method] = safeTry(definition[method] || Popcorn.nop, name);
  });
  var pluginFn = function(setup, options) {
   if (!options) {
    return this;
   }
   if (options.ranges && Popcorn.isArray(options.ranges)) {
    Popcorn.forEach(options.ranges, function(range) {
     var opts = Popcorn.extend({}, options, range);
     delete opts.ranges;
     this[name](opts);
    }, this);
    return this;
   }
   var natives = options._natives = {}, compose = "", originalOpts, manifestOpts;
   Popcorn.extend(natives, setup);
   options._natives.type = name;
   options._running = false;
   natives.start = natives.start || natives["in"];
   natives.end = natives.end || natives["out"];
   if (options.once) {
    natives.end = combineFn(natives.end, function() {
     this.removeTrackEvent(options._id);
    });
   }
   natives._teardown = combineFn(function() {
    var args = slice.call(arguments), runningPlugins = this.data.running[natives.type];
    args.unshift(null);
    args[1]._running && runningPlugins.splice(runningPlugins.indexOf(options), 1) && natives.end.apply(this, args);
   }, natives._teardown);
   natives._teardown = combineFn(natives._teardown, function() {
    this.emit("trackteardown", Popcorn.extend({}, options, {
     plugin:name,
     type:"trackteardown"
    }));
   });
   options.compose = options.compose && options.compose.split(" ") || [];
   options.effect = options.effect && options.effect.split(" ") || [];
   options.compose = options.compose.concat(options.effect);
   options.compose.forEach(function(composeOption) {
    compose = Popcorn.compositions[composeOption] || {};
    methods.forEach(function(method) {
     natives[method] = combineFn(natives[method], compose[method]);
    });
   });
   options._natives.manifest = manifest;
   if (!("start" in options)) {
    options.start = options["in"] || 0;
   }
   if (!options.end && options.end !== 0) {
    options.end = options["out"] || Number.MAX_VALUE;
   }
   if (!hasOwn.call(options, "toString")) {
    options.toString = function() {
     var props = [ "start: " + options.start, "end: " + options.end, "id: " + (options.id || options._id) ];
     if (options.target != null) {
      props.push("target: " + options.target);
     }
     return name + " ( " + props.join(", ") + " )";
    };
   }
   if (!options.target) {
    manifestOpts = "options" in manifest && manifest.options;
    options.target = manifestOpts && "target" in manifestOpts && manifestOpts.target;
   }
   if (options._natives) {
    options._id = Popcorn.guid(options._natives.type);
   }
   Popcorn.addTrackEvent(this, options);
   Popcorn.forEach(setup, function(callback, type) {
    if (blacklist.indexOf(type) === -1) {
     this.on(type, callback);
    }
   }, this);
   return this;
  };
  Popcorn.p[name] = plugin[name] = function(id, options) {
   var length = arguments.length, trackEvent, defaults, mergedSetupOpts;
   if (id && !options) {
    options = id;
    id = null;
   } else {
    trackEvent = this.getTrackEvent(id);
    if (!trackEvent) {
     options.id = id;
    } else {
     if (trackEvent._natives._update) {
      if (options.hasOwnProperty("start")) {
       trackEvent.start = options.start;
      }
      if (options.hasOwnProperty("end")) {
       trackEvent.end = options.end;
      }
      trackEvent._natives._update.call(this, trackEvent, options);
      removeFromArray(this, trackEvent._id);
      addToArray(this, trackEvent);
      var eventType;
      if (trackEvent._natives.type === "cue") {
       eventType = "cuechange";
      } else {
       eventType = "trackchange";
      }
      this.emit(eventType, {
       id:trackEvent.id || trackEvent._id,
       previousValue:{
        time:trackEvent.start,
        fn:trackEvent._natives.start
       },
       currentValue:{
        time:trackEvent.start,
        fn:trackEvent._natives.start
       },
       track:trackEvent
      });
     } else {
      options = Popcorn.extend({}, trackEvent, options);
      Popcorn.addTrackEvent(this, options);
     }
     return this;
    }
   }
   this.data.running[name] = this.data.running[name] || [];
   defaults = this.options.defaults && this.options.defaults[name] || {};
   mergedSetupOpts = Popcorn.extend({}, defaults, options);
   return pluginFn.call(this, isfn ? definition.call(this, mergedSetupOpts) :definition, mergedSetupOpts);
  };
  if (manifest) {
   Popcorn.extend(definition, {
    manifest:manifest
   });
  }
  var entry = {
   fn:plugin[name],
   definition:definition,
   base:definition,
   parents:[],
   name:name
  };
  Popcorn.registry.push(Popcorn.extend(plugin, entry, {
   type:name
  }));
  Popcorn.registryByName[name] = entry;
  return plugin;
 };
 Popcorn.plugin.errors = [];
 function safeTry(fn, pluginName) {
  return function() {
   if (Popcorn.plugin.debug) {
    return fn.apply(this, arguments);
   }
   try {
    return fn.apply(this, arguments);
   } catch (ex) {
    Popcorn.plugin.errors.push({
     plugin:pluginName,
     thrown:ex,
     source:fn.toString()
    });
    this.emit("pluginerror", Popcorn.plugin.errors);
   }
  };
 }
 Popcorn.plugin.debug = Popcorn.version === "@" + "VERSION";
 Popcorn.removePlugin = function(obj, name) {
  if (!name) {
   name = obj;
   obj = Popcorn.p;
   if (Popcorn.protect.natives.indexOf(name.toLowerCase()) >= 0) {
    Popcorn.error("'" + name + "' is a protected function name");
    return;
   }
   var registryLen = Popcorn.registry.length, registryIdx;
   for (registryIdx = 0; registryIdx < registryLen; registryIdx++) {
    if (Popcorn.registry[registryIdx].name === name) {
     Popcorn.registry.splice(registryIdx, 1);
     delete Popcorn.registryByName[name];
     delete Popcorn.manifest[name];
     delete obj[name];
     return;
    }
   }
  }
  var byStart = obj.data.trackEvents.byStart, byEnd = obj.data.trackEvents.byEnd, animating = obj.data.trackEvents.animating, idx, sl;
  for (idx = 0, sl = byStart.length; idx < sl; idx++) {
   if (byStart[idx] && byStart[idx]._natives && byStart[idx]._natives.type === name) {
    byStart[idx]._natives._teardown && byStart[idx]._natives._teardown.call(obj, byStart[idx]);
    byStart.splice(idx, 1);
    idx--;
    sl--;
    if (obj.data.trackEvents.startIndex <= idx) {
     obj.data.trackEvents.startIndex--;
     obj.data.trackEvents.endIndex--;
    }
   }
   if (byEnd[idx] && byEnd[idx]._natives && byEnd[idx]._natives.type === name) {
    byEnd.splice(idx, 1);
   }
  }
  for (idx = 0, sl = animating.length; idx < sl; idx++) {
   if (animating[idx] && animating[idx]._natives && animating[idx]._natives.type === name) {
    animating.splice(idx, 1);
    idx--;
    sl--;
   }
  }
 };
 Popcorn.compositions = {};
 Popcorn.compose = function(name, definition, manifest) {
  Popcorn.manifest[name] = manifest = manifest || definition.manifest || {};
  Popcorn.compositions[name] = definition;
 };
 Popcorn.plugin.effect = Popcorn.effect = Popcorn.compose;
 var rnaiveExpr = /^(?:\.|#|\[)/;
 Popcorn.dom = {
  debug:false,
  find:function(selector, context) {
   var node = null;
   context = context || document;
   if (selector) {
    if (!rnaiveExpr.test(selector)) {
     node = document.getElementById(selector);
     if (node !== null) {
      return node;
     }
    }
    try {
     node = context.querySelector(selector);
    } catch (e) {
     if (Popcorn.dom.debug) {
      throw new Error(e);
     }
    }
   }
   return node;
  }
 };
 var rparams = /\?/, setup = {
  url:"",
  data:"",
  dataType:"",
  success:Popcorn.nop,
  type:"GET",
  async:true,
  xhr:function() {
   return new global.XMLHttpRequest();
  }
 };
 Popcorn.xhr = function(options) {
  options.dataType = options.dataType && options.dataType.toLowerCase() || null;
  if (options.dataType && (options.dataType === "jsonp" || options.dataType === "script")) {
   Popcorn.xhr.getJSONP(options.url, options.success, options.dataType === "script");
   return;
  }
  var settings = Popcorn.extend({}, setup, options);
  settings.ajax = settings.xhr();
  if (settings.ajax) {
   if (settings.type === "GET" && settings.data) {
    settings.url += (rparams.test(settings.url) ? "&" :"?") + settings.data;
    settings.data = null;
   }
   settings.ajax.open(settings.type, settings.url, settings.async);
   settings.ajax.send(settings.data || null);
   return Popcorn.xhr.httpData(settings);
  }
 };
 Popcorn.xhr.httpData = function(settings) {
  var data, json = null, parser, xml = null;
  settings.ajax.onreadystatechange = function() {
   if (settings.ajax.readyState === 4) {
    try {
     json = JSON.parse(settings.ajax.responseText);
    } catch (e) {}
    data = {
     xml:settings.ajax.responseXML,
     text:settings.ajax.responseText,
     json:json
    };
    if (!data.xml || !data.xml.documentElement) {
     data.xml = null;
     try {
      parser = new DOMParser();
      xml = parser.parseFromString(settings.ajax.responseText, "text/xml");
      if (!xml.getElementsByTagName("parsererror").length) {
       data.xml = xml;
      }
     } catch (e) {}
    }
    if (settings.dataType) {
     data = data[settings.dataType];
    }
    settings.success.call(settings.ajax, data);
   }
  };
  return data;
 };
 Popcorn.xhr.getJSONP = function(url, success, isScript) {
  var head = document.head || document.getElementsByTagName("head")[0] || document.documentElement, script = document.createElement("script"), isFired = false, params = [], rjsonp = /(=)\?(?=&|$)|\?\?/, replaceInUrl, prefix, paramStr, callback, callparam;
  if (!isScript) {
   callparam = url.match(/(callback=[^&]*)/);
   if (callparam !== null && callparam.length) {
    prefix = callparam[1].split("=")[1];
    if (prefix === "?") {
     prefix = "jsonp";
    }
    callback = Popcorn.guid(prefix);
    url = url.replace(/(callback=[^&]*)/, "callback=" + callback);
   } else {
    callback = Popcorn.guid("jsonp");
    if (rjsonp.test(url)) {
     url = url.replace(rjsonp, "$1" + callback);
    }
    params = url.split(/\?(.+)?/);
    url = params[0] + "?";
    if (params[1]) {
     url += params[1] + "&";
    }
    url += "callback=" + callback;
   }
   window[callback] = function(data) {
    success && success(data);
    isFired = true;
   };
  }
  script.addEventListener("load", function() {
   if (isScript) {
    success && success();
   }
   if (isFired) {
    delete window[callback];
   }
   head.removeChild(script);
  }, false);
  script.src = url;
  head.insertBefore(script, head.firstChild);
  return;
 };
 Popcorn.getJSONP = Popcorn.xhr.getJSONP;
 Popcorn.getScript = Popcorn.xhr.getScript = function(url, success) {
  return Popcorn.xhr.getJSONP(url, success, true);
 };
 Popcorn.util = {
  toSeconds:function(timeStr, framerate) {
   var validTimeFormat = /^([0-9]+:){0,2}[0-9]+([.;][0-9]+)?$/, errorMessage = "Invalid time format", digitPairs, lastIndex, lastPair, firstPair, frameInfo, frameTime;
   if (typeof timeStr === "number") {
    return timeStr;
   }
   if (typeof timeStr === "string" && !validTimeFormat.test(timeStr)) {
    Popcorn.error(errorMessage);
   }
   digitPairs = timeStr.split(":");
   lastIndex = digitPairs.length - 1;
   lastPair = digitPairs[lastIndex];
   if (lastPair.indexOf(";") > -1) {
    frameInfo = lastPair.split(";");
    frameTime = 0;
    if (framerate && typeof framerate === "number") {
     frameTime = parseFloat(frameInfo[1], 10) / framerate;
    }
    digitPairs[lastIndex] = parseInt(frameInfo[0], 10) + frameTime;
   }
   firstPair = digitPairs[0];
   return {
    1:parseFloat(firstPair, 10),
    2:parseInt(firstPair, 10) * 60 + parseFloat(digitPairs[1], 10),
    3:parseInt(firstPair, 10) * 3600 + parseInt(digitPairs[1], 10) * 60 + parseFloat(digitPairs[2], 10)
   }[digitPairs.length || 1];
  }
 };
 Popcorn.p.cue = Popcorn.p.exec;
 Popcorn.protect = {
  natives:getKeys(Popcorn.p).map(function(val) {
   return val.toLowerCase();
  })
 };
 Popcorn.forEach({
  listen:"on",
  unlisten:"off",
  trigger:"emit",
  exec:"cue"
 }, function(recommend, api) {
  var original = Popcorn.p[api];
  Popcorn.p[api] = function() {
   if (typeof console !== "undefined" && console.warn) {
    console.warn("Deprecated method '" + api + "', " + (recommend == null ? "do not use." :"use '" + recommend + "' instead."));
    Popcorn.p[api] = original;
   }
   return Popcorn.p[recommend].apply(this, [].slice.call(arguments));
  };
 });
 global.Popcorn = Popcorn;
})(window, window.document);

define("popcorn", function(global) {
 return function() {
  var ret, fn;
  return ret || global.Popcorn;
 };
}(this));

define("touch", [], function() {
 function Touch(element, down, move, up, options) {
  var started = 0, opts = options || {};
  function mouseMove(e) {
   var x, y;
   if (!isNaN(e.pageX)) {
    x = e.pageX;
    y = e.pageY;
   } else {
    x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
    y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
   }
   move(e || window.event, x, y);
  }
  function mouseUp(e) {
   started = 0;
   if (up) {
    up(e || window.event);
   }
   document.removeEventListener("mousemove", mouseMove, false);
   document.removeEventListener("mouseup", mouseUp, false);
  }
  function mouseDown(e) {
   var go = true, x, y;
   if (!opts.rightClick && (e.which === 3 || e.button === 2 || e.ctrlKey)) {
    return false;
   }
   if (e.button === 1 && !opts.middleClick) {
    return false;
   }
   started = 1;
   if (down) {
    if (!e) {
     e = window.event;
    }
    if (!isNaN(e.pageX)) {
     x = e.pageX;
     y = e.pageY;
    } else {
     x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
     y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }
    go = down(e || window.event, x, y);
    if ((go || go === undefined) && e.preventDefault) {
     e.preventDefault();
    } else {
     return;
    }
   }
   if (move) {
    document.addEventListener("mousemove", mouseMove, false);
   }
   document.addEventListener("mouseup", mouseUp, false);
  }
  function touchMove(e) {
   var touch = e.changedtouches && e.changedtouches.length && e.changedtouches[0] || e.touches && e.touches.length && e.touches[0] || e || window.event;
   move(touch, touch.pageX, touch.pageY);
   return false;
  }
  function touchEnd(e) {
   started = 0;
   if (up) {
    up(e && e.changedtouches ? e.changedtouches[0] :e);
   }
   document.removeEventListener("touchmove", touchMove, false);
   document.removeEventListener("touchend", touchEnd, false);
  }
  function touchStart(e) {
   var go, touch;
   started = 2;
   if (e.preventDefault) {
    e.preventDefault();
   }
   element.removeEventListener("mousedown", mouseDown, false);
   if (down) {
    touch = e.touches[0];
    go = down(touch || window.event, touch.pageX, touch.pageY);
    if ((go || go === undefined) && e.preventDefault) {
     e.preventDefault();
    } else {
     return;
    }
   }
   if (move) {
    document.addEventListener("touchmove", touchMove, false);
   }
   document.addEventListener("touchend", touchEnd, false);
  }
  element.addEventListener("mousedown", mouseDown, true);
  element.addEventListener("touchstart", touchStart, false);
  this.remove = function() {
   element.removeEventListener("mousedown", mouseDown, false);
   element.removeEventListener("touchstart", touchStart, false);
   if (started > 1) {
    touchEnd();
   } else if (started) {
    mouseUp();
   }
  };
  this.target = function() {
   return element;
  };
 }
 return Touch;
});

define("environment", [ "lodash", "logging" ], function(_, logging) {
 function nop() {
  logging.warn("This Environment scope has been destroyed. Don't use it anymore.");
 }
 function Environment(data, opts) {
  var scopeData = {
   children:{}
  }, mainScope, options = opts || {}, storage = options.storage || {}, loading = false, clearQueue = [];
  function Scope(scopeName, parent, data) {
   var state, dirty = true, i, j;
   function setChildValue(state, name, valueRef, clear) {
    var oldValueRef = state.values[name];
    if (!clear && oldValueRef && oldValueRef !== valueRef && oldValueRef.owner === state) {
     return;
    }
    if (valueRef) {
     state.values[name] = valueRef;
    } else if (state.values.hasOwnProperty(name)) {
     state.values[name] = undefined;
    }
    state.keys = null;
    _.each(state.children, function(child) {
     setChildValue(child, name, valueRef, clear);
    });
    _.each(state.observers, function(observers, key) {
     if (key === name || key.indexOf(name + ".") === 0) {
      _.each(_.clone(observers), function(observer) {
       observer(state.obj, name, valueRef && valueRef.value);
      });
     }
    });
    if (name && state.observers.hasOwnProperty("")) {
     _.each(_.clone(state.observers[""]), function(observer) {
      observer(state.obj, name, valueRef && valueRef.value);
     });
    }
   }
   state = {
    obj:this,
    parent:parent,
    children:{},
    values:{},
    observers:{},
    methods:{},
    frozen:false,
    name:scopeName,
    keys:null
   };
   parent.children[scopeName] = state;
   _.extend(state.values, parent.values);
   _.extend(state.methods, parent.methods);
   this.name = function() {
    return state.name;
   };
   this.set = function(name, value, temp) {
    var valueRef, path, child, nameComponents, propertyName;
    if (!name) {
     return;
    } else if (Object.prototype.toString.call(name) === "[object Array]") {
     path = name;
    } else {
     path = name.split("/");
    }
    if (path.length > 1) {
     path = path.slice(0);
     child = path.shift();
     this.scope(child).set(path, value);
     return;
    }
    if (state.frozen) {
     return this;
    }
    nameComponents = path[0].split(".");
    name = nameComponents[0];
    propertyName = nameComponents[1];
    valueRef = state.values[name];
    if (valueRef && valueRef.owner === state) {
     if (propertyName !== undefined) {
      if (typeof valueRef.value !== "object") {
       logging.error('Environment cannot set property "' + propertyName + '" on non-object "' + name + '"');
       return;
      }
      if (valueRef.value[propertyName] === value) {
       return;
      }
      valueRef.value[propertyName] = value;
     } else {
      if (valueRef.value === value) {
       return;
      }
      valueRef.value = value;
     }
     if (temp !== undefined) {
      valueRef.temp = !!temp;
     }
    } else {
     valueRef = {
      name:name,
      owner:state,
      value:value,
      temp:!!temp
     };
     if (propertyName !== undefined) {
      valueRef.value = {};
      valueRef.value[propertyName] = value;
     }
    }
    if (!valueRef.temp) {
     dirty = true;
    }
    setChildValue(state, name, valueRef);
    if (!loading && !temp && options.autosave) {
     if (Array.isArray(options.autosave)) {
      this.save.apply(this, options.autosave);
     } else {
      this.save(options.autosave);
     }
    }
    return this;
   };
   this.get = function(name) {
    var valueRef, path, child, nameComponents;
    if (!name) {
     return;
    } else if (Object.prototype.toString.call(name) === "[object Array]") {
     path = name;
    } else {
     path = name.split("/");
    }
    if (path.length > 1) {
     child = path.shift();
     if (!state.children[child]) {
      return;
     }
     return state.children[child].obj.get(path);
    }
    nameComponents = path[0].split(".");
    name = nameComponents.shift();
    valueRef = state.values[name];
    if (nameComponents.length && valueRef) {
     valueRef = valueRef.value;
     while (nameComponents.length && valueRef && typeof valueRef === "object") {
      name = nameComponents.shift();
      valueRef = valueRef[name];
     }
     return valueRef;
    }
    return valueRef && valueRef.value;
   };
   this.clear = function(name, blocksave) {
    var valueRef, nameComponents, propertyName;
    if (!name) {
     return;
    }
    nameComponents = name.split(".");
    name = nameComponents[0];
    propertyName = nameComponents[1];
    valueRef = state.values[name];
    if (valueRef && valueRef.owner === state) {
     if (propertyName !== undefined) {
      if (typeof valueRef.value === "object") {
       delete valueRef.value[propertyName];
      }
     }
     dirty = true;
     setChildValue(state, name, parent.values && parent.values[name], true);
    }
    if (options.autosave && !blocksave) {
     if (Array.isArray(options.autosave)) {
      this.save.apply(this, options.autosave);
     } else {
      this.save(options.autosave);
     }
    }
   };
   this.freeze = function() {
    state.frozen = true;
   };
   this.unfreeze = function() {
    state.frozen = false;
   };
   this.frozen = function() {
    return state.frozen;
   };
   this.observe = function(name, callback) {
    if (callback === undefined) {
     callback = name;
     name = "";
    } else if (!name) {
     name = "";
    }
    if (typeof callback !== "function") {
     throw new Error("Environment observe callback must a function.");
    }
    if (state.observers[name]) {
     if (state.observers[name].indexOf(callback) >= 0) {
      return this;
     }
    } else {
     state.observers[name] = [];
    }
    state.observers[name].push(callback);
    return this;
   };
   this.unobserve = function(name, callback) {
    var i;
    if (!state.observers[name]) {
     return;
    }
    i = state.observers[name].indexOf(callback);
    if (i >= 0) {
     state.observers[name].splice(i, 1);
    }
    return this;
   };
   this.notify = function(name) {
    var observers;
    if (state.observers.hasOwnProperty(name)) {
     observers = state.observers[name];
     for (j = 0; j < observers.length; j++) {
      observers[j](state.obj);
     }
    }
    return this;
   };
   this.register = function(name, method) {
    var methodRef;
    function setMethod(state, name, methodRef, clear) {
     var i, oldMethodRef;
     oldMethodRef = state.methods[name];
     if (!clear && oldMethodRef && oldMethodRef !== methodRef && oldMethodRef.owner === state) {
      return;
     }
     if (methodRef) {
      state.methods[name] = methodRef;
     } else {
      delete state.methods[name];
     }
     for (i in state.children) {
      if (state.children.hasOwnProperty(i)) {
       setMethod(state.children[i], name, methodRef, clear);
      }
     }
    }
    methodRef = state.methods[name];
    if (methodRef && methodRef.owner === state) {
     if (methodRef.method === method) {
      return;
     }
     methodRef.method = method;
    } else {
     methodRef = {
      name:name,
      owner:state,
      method:method
     };
    }
    setMethod(state, name, methodRef);
    return this;
   };
   this.execute = function(name) {
    var args = Array.prototype.slice.call(arguments, 0), methodRef;
    methodRef = state.methods[name];
    if (!methodRef) {
     return;
    }
    args[0] = this;
    return methodRef.method.apply(this, args);
   };
   this.scope = function(name, data, noCreate) {
    var scope, path, child, i;
    if (!name) {
     return;
    } else if (Object.prototype.toString.call(name) === "[object Array]") {
     path = name;
    } else {
     path = name.split("/");
    }
    if (path.length > 1) {
     path = path.slice(0);
     child = this.scope(path.shift());
     if (path.length) {
      return child.scope(path, data);
     }
    }
    name = path[0];
    scope = state.children[name];
    if (scope) {
     if (data) {
      for (i in data) {
       if (data.hasOwnProperty(i)) {
        scope.obj.set(i, data[i]);
       }
      }
     }
     return scope.obj;
    }
    if (noCreate) {
     return undefined;
    }
    scope = new Scope(name, state, data);
    return scope;
   };
   this.rename = function(name) {
    var oldName;
    if (state.name === name) {
     return;
    }
    oldName = state.name;
    state.name = name;
    parent.children[name] = state;
    delete parent.children[oldName];
    if (options.autosave) {
     if (Array.isArray(options.autosave)) {
      this.clear.apply(this, options.autosave);
     } else {
      this.clear(options.autosave);
     }
    } else {
     clearQueue.push({
      name:oldName,
      parent:parent
     });
    }
    return this;
   };
   this.destroy = function() {
    var i, list;
    dirty = true;
    for (i in state.children) {
     if (state.children.hasOwnProperty(i)) {
      state.children[i].obj.destroy();
      delete state.children[i];
     }
    }
    for (i in state.values) {
     if (state.values.hasOwnProperty(i)) {
      this.clear(i, true);
     }
    }
    for (i in state.observers) {
     if (state.observers.hasOwnProperty(i)) {
      list = state.observers[i];
      while (list.length) {
       this.unobserve(i, list[0]);
      }
     }
    }
    if (options.autosave) {
     if (Array.isArray(options.autosave)) {
      this.save.apply(this, options.autosave);
     } else {
      this.save(options.autosave);
     }
    } else {
     clearQueue.push({
      name:name,
      parent:parent
     });
    }
    for (i in this) {
     if (this.hasOwnProperty(i) && typeof this[i] === "function") {
      this[i] = nop;
     }
    }
    delete parent.children[state.name];
   };
   this.save = function() {
    var args = Array.prototype.slice.call(arguments, 0), key;
    if (!dirty) {
     return this;
    }
    if (storage.save) {
     args.unshift(state);
     storage.save.apply(this, args);
    }
    dirty = false;
    for (key in state.children) {
     if (state.children.hasOwnProperty(key)) {
      state.children[key].obj.save.apply(state.children[key].obj, arguments);
     }
    }
    if (!state.parent && storage.clear) {
     while (clearQueue.length) {
      if (Array.isArray(options.autosave)) {
       this.clear.apply(this, options.autosave);
      } else {
       this.clear(options.autosave);
      }
     }
    }
    return this;
   };
   this.load = function() {
    var data;
    function loadData(scope, data) {
     var i, child, val;
     for (i in data) {
      if (data.hasOwnProperty(i)) {
       val = data[i];
       if (val && typeof val === "object") {
        child = scope.scope(i);
        loadData(child, val);
       } else if (val !== undefined) {
        scope.set(i, val);
       }
      }
     }
    }
    if (!storage.load) {
     return;
    }
    loading = true;
    data = storage.load.apply(this, arguments);
    loadData(mainScope, data);
    dirty = false;
    loading = false;
    return this;
   };
   this.keys = function(index) {
    var i;
    if (!state.keys) {
     state.keys = [];
     for (i in state.values) {
      if (state.values.hasOwnProperty(i) && state.values[i] !== undefined) {
       state.keys.push(i);
      }
     }
    }
    if (index === undefined) {
     return state.keys.slice(0);
    }
    return state.keys[index];
   };
   this.children = function(index) {
    if (!state.scopeKeys) {
     state.scopeKeys = Object.keys(state.children);
    }
    if (index === undefined) {
     return state.scopeKeys.slice(0);
    }
    return state.scopeKeys[index];
   };
   Object.defineProperty(this.keys, "count", {
    get:function() {
     if (!state.keys) {
      state.keys = Object.keys(state.values);
     }
     return state.keys.length;
    }
   });
   Object.defineProperty(this.children, "count", {
    get:function() {
     if (!state.scopeKeys) {
      state.scopeKeys = Object.keys(state.children);
     }
     return state.scopeKeys.length;
    }
   });
   if (data) {
    for (i in data) {
     if (data.hasOwnProperty(i)) {
      this.set(i, data[i]);
     }
    }
   }
  }
  mainScope = new Scope("", scopeData, data);
  this.name = function() {
   return "";
  };
  this.set = function(name, value, temp) {
   mainScope.set(name, value, temp);
   return this;
  };
  this.get = function(name) {
   return mainScope.get(name);
  };
  this.clear = function(name, blocksave) {
   mainScope.clear(name, blocksave);
  };
  this.scope = function(name, data, noCreate) {
   return mainScope.scope(name, data, noCreate);
  };
  this.freeze = function() {
   return mainScope.freeze();
  };
  this.unfreeze = function() {
   return mainScope.unfreeze();
  };
  this.frozen = function() {
   mainScope.frozen();
  };
  this.observe = function(name, callback) {
   return mainScope.observe(name, callback);
  };
  this.unobserve = function(name, callback) {
   return mainScope.unobserve(name, callback);
  };
  this.notify = function(name) {
   return mainScope.notify(name);
  };
  this.register = function(name, method) {
   return mainScope.register(name, method);
  };
  this.execute = function() {
   return mainScope.execute.apply(mainScope, arguments);
  };
  this.rename = function() {
   logging.warn("Cannot rename top-level Environment scope.");
  };
  this.destroy = function() {
   mainScope.destroy();
  };
  this.save = function() {
   return mainScope.save.apply(mainScope, arguments);
  };
  this.load = function() {
   return mainScope.load.apply(mainScope, arguments);
  };
  this.keys = function(index) {
   return mainScope.keys(index);
  };
  this.children = function(index) {
   return mainScope.children(index);
  };
  Object.defineProperty(this.keys, "count", {
   get:function() {
    return mainScope.keys.count;
   }
  });
  if (options.migrate && options.storage) {
   options.storage.migrate.call(this, typeof options.migrate === "string" ? options.migrate :options.autosave);
  }
 }
 Environment.localStorage = {
  move:function(from, to) {
   var i, key, val, newKey, keys = [];
   try {
    for (i = 0; i < localStorage.length; i++) {
     key = localStorage.key(i);
     if (from.test(key)) {
      keys.push(key);
     }
    }
    for (i = 0; i < keys.length; i++) {
     key = keys[i];
     val = localStorage.getItem(keys[i]);
     newKey = key.replace(from, to);
     if (!localStorage.hasOwnProperty(newKey)) {
      localStorage.setItem(newKey, val);
      localStorage.removeItem(key);
     }
    }
   } catch (e) {
    return;
   }
  },
  migrate:function(name) {
   var version = 0, prefix = name + ".", len = prefix.length, i, keys = [], key, json, r;
   try {
    version = parseFloat(localStorage.getItem((name || "localStorage") + "-version"));
   } catch (e) {
    return;
   }
   if (version) {
    return;
   }
   for (i = 0; i < localStorage.length; i++) {
    key = localStorage.key(i);
    if (key.length > len && key.substr(0, len) === prefix) {
     keys.push(key);
    }
   }
   r = /\./g;
   for (i = 0; i < keys.length; i++) {
    key = keys[i];
    try {
     json = localStorage.getItem(key);
     localStorage.setItem(key.replace(r, "/"), json);
     localStorage.removeItem(key);
    } catch (e) {}
   }
   try {
    localStorage.setItem((name || "localStorage") + "-version", 1);
   } catch (e) {}
  },
  clear:function(state, name) {
   var parent, path, key;
   parent = state;
   while (parent && parent.name) {
    path.unshift(parent.name);
    parent = parent.parent;
   }
   path.unshift(name);
   key = path.join("/");
   try {
    localStorage.removeItem(key);
   } catch (err) {}
  },
  save:function(state, name) {
   var valueRef, key, data = {}, parent, path = [], empty = true;
   for (key in state.values) {
    if (state.values.hasOwnProperty(key)) {
     valueRef = state.values[key];
     if (valueRef && !valueRef.temp && valueRef.owner === state && valueRef.value !== undefined) {
      try {
       if (typeof valueRef.value === "object") {
        JSON.stringify(valueRef.value);
       }
       data[key] = valueRef.value;
       empty = false;
      } catch (e) {}
     }
    }
   }
   parent = state;
   while (parent && parent.name) {
    path.unshift(parent.name);
    parent = parent.parent;
   }
   path.unshift(name);
   key = path.join("/");
   try {
    if (empty) {
     localStorage.removeItem(key);
    } else {
     localStorage.setItem(key, JSON.stringify(data));
     localStorage.setItem((name || "localStorage") + "-version", 1);
    }
   } catch (err) {}
  },
  load:function(name, path, delimiter) {
   var me = this, prefix = name + (delimiter || "/"), len = prefix.length, i, key;
   function loadKey(key, scope) {
    var json, obj, i;
    try {
     json = localStorage.getItem(key);
    } catch (localStorageError) {
     return;
    }
    if (json && json !== "{}") {
     try {
      obj = JSON.parse(json);
      if (scope) {
       me.scope(scope, obj);
      } else {
       for (i in obj) {
        if (obj.hasOwnProperty(i)) {
         me.set(i, obj[i]);
        }
       }
      }
     } catch (jsonError) {}
    }
   }
   if (!delimiter) {
    delimiter = "/";
   }
   if (path !== undefined) {
    loadKey(name + (path ? delimiter + path :""), path);
    return;
   }
   loadKey(name, "");
   for (i = 0; i < localStorage.length; i++) {
    key = localStorage.key(i);
    if (key.length > len && key.substr(0, len) === prefix) {
     loadKey(key, key.substr(len));
    }
   }
  }
 };
 window.addEventListener("storage", function(evt) {}, false);
 return Environment;
});

(function(window, Popcorn, undefined) {
 var logging = window.console || {
  log:function() {},
  error:function() {},
  warn:function() {}
 };
 Popcorn.p.setData = function(id, name, value, temp) {
  var scope, trackScope = this.options.environment;
  if (!trackScope) {
   logging.warn("No environment loaded for Popcorn.data");
   return;
  }
  if (value === undefined || typeof name !== "string") {
   value = name;
   name = id;
   id = undefined;
  }
  scope = this.options.getScope && this.options.getScope(id) || trackScope;
  scope.set(name, value, temp);
  return this;
 };
 Popcorn.p.clearData = function(id, name) {
  var scope, trackScope = this.options.environment;
  if (!trackScope) {
   logging.warn("No environment loaded for Popcorn.data");
   return;
  }
  if (typeof name !== "string") {
   name = id;
   id = undefined;
  }
  scope = this.options.getScope && this.options.getScope(id) || trackScope;
  scope.clear(name);
  return this;
 };
 Popcorn.p.resetData = function(id) {
  var scope, i, trackScope = this.options.environment;
  function clearScope(scope) {
   var i, keys;
   keys = scope.keys();
   for (i = 0; i < keys.length; i++) {
    scope.clear(keys[i]);
   }
  }
  if (!trackScope) {
   logging.warn("No environment loaded for Popcorn.data");
   return;
  }
  scope = this.options.getScope && this.options.getScope(id) || trackScope;
  clearScope(scope);
  for (i = scope.children.count - 1; i >= 0; i--) {
   clearScope(scope.scope(scope.children(i)));
  }
  return this;
 };
 Popcorn.p.getData = function(id, name) {
  var scope, trackScope = this.options.environment;
  if (!trackScope) {
   logging.warn("No environment loaded for Popcorn.data");
   return;
  }
  if (name === undefined || typeof name !== "string") {
   name = id;
   id = undefined;
  }
  scope = this.options.getScope && this.options.getScope(id) || trackScope;
  return scope.get(name);
 };
 Popcorn.p.watchData = function(id, name, fn) {
  var scope, trackScope = this.options.environment;
  if (!trackScope) {
   logging.warn("No environment loaded for Popcorn.data");
   return;
  }
  if (fn === undefined || typeof name !== "string") {
   name = id;
   id = undefined;
  }
  scope = this.options.getScope && this.options.getScope(id) || trackScope;
  scope.observe(name, fn);
  return this;
 };
 Popcorn.p.unwatchData = function(id, name, fn) {
  var scope, trackScope = this.options.environment;
  if (!trackScope) {
   logging.warn("No environment loaded for Popcorn.data");
   return;
  }
  if (fn === undefined || typeof name !== "string") {
   name = id;
   id = undefined;
  }
  scope = this.options.getScope && this.options.getScope(id) || trackScope;
  scope.unobserve(name, fn);
  return this;
 };
 Popcorn.p.notifyData = function(id, name) {
  var scope, trackScope = this.options.environment;
  if (!trackScope) {
   logging.warn("No environment loaded for Popcorn.data");
   return;
  }
  if (name === undefined || typeof name !== "string") {
   name = id;
   id = undefined;
  }
  scope = this.options.getScope && this.options.getScope(id) || trackScope;
  scope.notify(name);
  return this;
 };
 Popcorn.p.dataMethod = function(id) {
  var scope, args, trackScope = this.options.environment;
  if (!trackScope) {
   logging.warn("No environment loaded for Popcorn.data");
   return;
  }
  scope = this.options.getScope && this.options.getScope(id) || trackScope;
  args = Array.prototype.slice.call(arguments, 1);
  return scope.execute.apply(scope, args);
 };
 Popcorn.p.dataKeys = function(id) {
  var scope, trackScope = this.options.environment;
  if (!trackScope) {
   logging.warn("No environment loaded for Popcorn.data");
   return;
  }
  scope = this.options.getScope && this.options.getScope(id) || trackScope;
  return scope.keys();
 };
})(this, this.Popcorn);

define("popcorn.data", [ "popcorn" ], function(global) {
 return function() {
  var ret, fn;
  return ret || global.Popcorn.data;
 };
}(this));

(function(root, factory) {
 if (typeof exports === "object") {
  module.exports = factory(require("popcorn"));
 } else if (typeof define === "function" && define.amd) {
  define("popcorn.filter", [ "popcorn" ], factory);
 } else {
  factory(root.Popcorn);
 }
})(this, function(Popcorn, undefined) {
 var popcornPlugins = {}, popcornInstances = {}, namedFilters = {}, routes = {
  "":[],
  "*":[]
 }, popcornPlugin = Popcorn.plugin, getTrackEvent = Popcorn.getTrackEvent, getTrackEvents = Popcorn.getTrackEvents, removeTrackEvent = Popcorn.removeTrackEvent, trigger = Popcorn.events.fn.trigger, trappedEvents = {
  trackadded:true,
  tracksetup:true,
  trackstart:true,
  trackend:true,
  trackremoved:true,
  trackchange:true,
  trackteardown:true
 }, propertyNameBlacklist = /^(_(natives|id|running)|id|target|effect|compose|toString)$/;
 function cleanOutNode(node, popcorn) {
  var i, popcornInstance;
  Popcorn.forEach(node.children, function(child, i) {
   child.destroyed = true;
   cleanOutNode(child, popcorn);
   delete node.children[i];
  });
  if (node.popcornId) {
   removeTrackEvent(popcorn, node.popcornId);
   i = node.actualTrackEvents.indexOf(node.popcornId);
   if (i >= 0) {
    node.actualTrackEvents.splice(i, 1);
   }
   popcornInstance = popcornInstances[popcorn.id];
   delete popcornInstance.trackEventsByChildId[node.popcornId];
  }
  if (node.teardown) {
   node.teardown.call(popcorn, node);
  }
  if (node.routeObj) {
   delete node.routeObj.nodes[node.uid];
  }
 }
 function combine(first, second) {
  if (!first) {
   return second;
  }
  if (!second) {
   return first;
  }
  return function() {
   first.apply(this, arguments);
   second.apply(this, arguments);
  };
 }
 function executeFilter(popcorn, route, id, options) {
  var popcornInstance, routesList, child, track, newEvent = false, previousValues;
  function makeNextCallback(routesList, i, parent, useVirtualEventId) {
   return function(branchId, opts, newRoute) {
    var pluginFn, nextRoute, child, trackEvent, key, defaults, teardownFn, node;
    if (typeof branchId === "object") {
     newRoute = opts;
     opts = branchId;
     branchId = "";
    }
    if (!newRoute) {
     newRoute = parent.route;
    }
    useVirtualEventId = useVirtualEventId && newRoute === route && (!parent.virtualEventId || branchId === "");
    child = parent.children[branchId];
    if (child) {
     if (child.destroyed) {
      return null;
     }
     if (!i) {
      child.updatingFromPopcorn = true;
     }
     if (!opts) {
      cleanOutNode(child, popcorn);
      delete parent.children[branchId];
      node = popcornInstance && popcornInstance.children[child.virtualEventId];
      if (node && !node.updatingFromPopcorn) {
       trigger.call(popcorn, "trackchange", Popcorn.extend({}, {
        id:node.id,
        type:"trackchange",
        track:node.fakeTrackEvent,
        previousValue:node.options,
        currentValue:node.options
       }));
      }
      return null;
     }
     for (key in opts) {
      if (opts.hasOwnProperty(key) && !propertyNameBlacklist.test(key)) {
       child.options[key] = opts[key];
      }
     }
    } else {
     if (!opts) {
      return null;
     }
     child = {
      id:typeof branchId === "string" ? branchId :Popcorn.guid(newRoute),
      uid:Popcorn.guid(newRoute) + "-" + i,
      popcornId:null,
      options:opts || parent.options,
      teardown:null,
      route:newRoute,
      routeObj:null,
      children:{},
      destroyed:false,
      actualTrackEvents:parent.actualTrackEvents || [],
      virtualEventId:parent.virtualEventId,
      fakeTrackEvent:parent.fakeTrackEvent,
      updatingFromPopcorn:!i
     };
     if (!child.virtualEventId) {
      child.virtualEventId = child.id;
      defaults = popcorn.options.defaults && popcorn.options.defaults[route] || {};
      child.options = Popcorn.extend({}, defaults, opts || parent.options || options);
     }
     if (!child.options.start && child.options.start !== 0) {
      child.options.start = parent.options ? parent.options.start :options.start;
      if (child.options.start === undefined) {
       delete child.options.start;
      }
     }
     if (!child.options.end && child.options.end !== 0) {
      child.options.end = parent.options ? parent.options.end :options.end;
      if (child.options.end === undefined) {
       delete child.options.end;
      }
     }
     parent.children[child.id] = child;
    }
    if (newRoute !== parent.route) {
     child.route = newRoute;
     if (routes[child.route]) {
      routesList = routes[""].concat(routes[child.route], routes["*"]);
     } else {
      routesList = routes[""].concat(routes["*"]);
     }
     i = Math.min(i, routes[""].length);
    }
    if (!child.fakeTrackEvent && (routesList.length || !useVirtualEventId)) {
     child.fakeTrackEvent = {
      _id:child.virtualEventId,
      id:child.virtualEventId,
      _natives:{
       plugin:route,
       type:route,
       start:Popcorn.nop,
       end:Popcorn.nop,
       _teardown:Popcorn.nop,
       mainfest:{}
      },
      _running:false,
      effect:[],
      compose:[]
     };
     Popcorn.extend(child.fakeTrackEvent, child.options);
    }
    if (i < routesList.length) {
     nextRoute = routesList[i];
     child.routeObj = nextRoute;
     if (nextRoute) {
      nextRoute.nodes[child.uid] = child;
     }
     useVirtualEventId = false;
     teardownFn = nextRoute.fn.call(popcorn, child.route, child.options, makeNextCallback(routesList, i + 1, child, useVirtualEventId), child);
     child.teardown = combine(teardownFn, child.routeObj && child.routeObj.teardown);
     return child;
    }
    pluginFn = popcornPlugins[child.route];
    if (!pluginFn) {
     return child;
    }
    if (child.popcornId) {
     child.options.id = child.popcornId;
     child.options._id = child.popcornId;
     if (!child.trackEvent || !child.trackEvent._natives || !child.trackEvent._natives._update) {
      removeTrackEvent(popcorn, child.popcornId);
      pluginFn.call(popcorn, child.popcornId, child.options);
     } else {
      pluginFn.call(popcorn, child.popcornId, child.options);
     }
    } else {
     child.popcornId = useVirtualEventId ? child.virtualEventId :Popcorn.guid(child.route);
     child.options.id = child.popcornId;
     child.options._id = child.popcornId;
     child.actualTrackEvents.push(child.popcornId);
     popcornInstance.trackEventsByChildId[child.popcornId] = popcornInstance.children[child.virtualEventId];
     pluginFn.call(popcorn, child.popcornId, child.options);
    }
    trackEvent = getTrackEvent(popcorn, child.popcornId);
    child.trackEvent = trackEvent;
    if (!child.fakeTrackEvent) {
     child.fakeTrackEvent = trackEvent;
    } else if (useVirtualEventId || !child.fakeTrackEvent.container) {
     child.fakeTrackEvent.container = trackEvent && trackEvent.container;
    }
    node = popcornInstance && popcornInstance.children[child.virtualEventId];
    if (node && !node.updatingFromPopcorn) {
     trigger.call(popcorn, "trackchange", Popcorn.extend({}, {
      id:node.id,
      type:"trackchange",
      track:node.fakeTrackEvent,
      previousValue:node.options,
      currentValue:node.options
     }));
    }
    return child;
   };
  }
  if (id && !options) {
   options = id;
   id = options.id || options._id || null;
  } else if (!options) {
   return;
  }
  popcornInstance = popcornInstances[popcorn.id];
  if (!popcornInstance) {
   popcornInstance = popcornInstances[popcorn.id] = {
    popcorn:popcorn,
    contextOptions:popcorn.options.context || {},
    history:[],
    children:{},
    trackEventsByChildId:{}
   };
   newEvent = true;
  } else if (!id || !popcornInstance.children[id]) {
   newEvent = true;
  }
  if (newEvent) {
   if (id) {
    options._id = id;
   }
  } else {
   previousValues = Popcorn.extend({}, popcornInstance.children[id].options);
  }
  child = makeNextCallback(routesList, 0, popcornInstance, true)(id || false, options, route);
  if (!child) {
   return;
  }
  track = popcorn.getTrackEvent(child.id);
  child.updatingFromPopcorn = false;
  if (newEvent) {
   popcornInstance.history.push(child.id);
   trigger.call(popcorn, "tracksetup", Popcorn.extend({}, track, {
    plugin:route,
    type:"tracksetup",
    track:track
   }));
   trigger.call(popcorn, "trackadded", Popcorn.extend({}, track, {
    plugin:route,
    type:"trackadded",
    track:track
   }));
  } else {
   trigger.call(popcorn, "trackchange", Popcorn.extend({}, {
    id:child.id,
    type:"trackchange",
    track:track,
    previousValue:previousValues,
    currentValue:popcornInstance.children[child.id].options
   }));
  }
 }
 Popcorn.filterRoutes = {};
 Popcorn.filter = function(name, route, fn, beginning, teardown) {
  var routed = [], routeObjects, filterReference = {};
  if (typeof route === "function") {
   teardown = beginning;
   beginning = fn;
   fn = route;
   route = name;
   name = null;
  } else if (name) {
   if (namedFilters) {
    Popcorn.removeFilter(name);
   }
   routeObjects = [];
   namedFilters[name] = routeObjects;
  }
  if (Popcorn.isArray(route)) {
   if (route.length > 1 && route.indexOf("*") >= 0) {
    route = [ "*" ];
   }
  } else {
   route = [ route ];
  }
  Popcorn.forEach(route, function(r) {
   var obj;
   if (beginning && r === "*") {
    r = "";
   }
   if (routed.indexOf(r) >= 0) {
    return;
   }
   if (!routes[r]) {
    routes[r] = [];
   }
   obj = {
    name:name,
    route:r,
    fn:fn,
    nodes:{},
    teardown:teardown
   };
   if (routeObjects) {
    routeObjects.push(obj);
   }
   if (beginning) {
    routes[r].unshift(obj);
   } else {
    routes[r].push(obj);
   }
   Popcorn.filterRoutes[r] = true;
   if (!Popcorn.p[r]) {
    Popcorn.p[r] = function(id, options) {
     executeFilter(this, r, id, options);
    };
   }
  });
 };
 Popcorn.removeFilter = function(name) {
  var affectedRoutes = [];
 };
 Popcorn.plugin = function(name, definition, manifest) {
  popcornPlugin(name, definition, manifest);
  popcornPlugins[name] = Popcorn.p[name];
  Popcorn.p[name] = function(id, options) {
   executeFilter(this, name, id, options);
   return this;
  };
 };
 Popcorn.plugin.effect = Popcorn.effect = Popcorn.compose;
 Popcorn.getLastTrackEventId = function(obj) {
  var popcornInstance;
  popcornInstance = popcornInstances[obj.id];
  if (popcornInstance && popcornInstance.history.length) {
   return popcornInstance.history[popcornInstance.history.length - 1];
  }
 };
 Popcorn.getTrackEvent = function(obj, id) {
  var popcornInstance, node;
  popcornInstance = popcornInstances[obj.id];
  node = popcornInstance && popcornInstance.children[id];
  if (!node) {
   return getTrackEvent(obj, id);
  }
  return node.fakeTrackEvent;
 };
 Popcorn.getTrackEvent.ref = getTrackEvent.ref;
 Popcorn.getTrackEvents = function(obj) {
  var trackEvents = [], popcornInstance = popcornInstances[obj.id], listAllEvents = obj.options.context && obj.options.context.listAllEvents, i, events, evt;
  if (popcornInstance && popcornInstance.children) {
   Popcorn.forEach(popcornInstance.children, function(child, id) {
    trackEvents.push(Popcorn.getTrackEvent(obj, id));
   });
  }
  events = obj.data.trackEvents.byStart;
  for (i = 0; i < events.length; i++) {
   evt = events[i];
   if (evt._id && (listAllEvents || evt._natives && evt._natives.type === "cue") && (!popcornInstance || !popcornInstance.children || !popcornInstance.children[evt._id])) {
    trackEvents.push(evt);
   }
  }
  trackEvents.sort(function(a, b) {
   if (a.start === b.start) {
    return a.end - b.end;
   }
   return a.start - b.start;
  });
  return trackEvents;
 };
 Popcorn.getTrackEvents.ref = getTrackEvents.ref;
 Popcorn.removeTrackEvent = function(obj, removeId) {
  var popcornInstance = popcornInstances[obj.id], popcorn, node, i, track, plugin, data;
  node = popcornInstance && popcornInstance.children[removeId];
  if (node) {
   popcorn = popcornInstance.popcorn;
   track = popcorn.getTrackEvent(node.id);
   plugin = node.route;
   cleanOutNode(node, popcornInstance.popcorn);
   delete popcornInstance.children[removeId];
   i = popcornInstance.history.indexOf(removeId);
   if (i >= 0) {
    popcornInstance.history.splice(i, 1);
   }
   data = Popcorn.extend({}, track, {
    plugin:plugin,
    type:"trackteardown",
    track:track
   });
   trigger.call(popcorn, "trackteardown", data);
   data = Popcorn.extend({}, track, {
    plugin:plugin,
    type:"trackremoved",
    track:track
   });
   trigger.call(popcorn, "trackremoved", data);
  } else {
   track = obj.data.trackRefs[removeId];
   if (track) {
    removeTrackEvent(obj, removeId);
   }
  }
 };
 Popcorn.removeTrackEvent.ref = removeTrackEvent.ref;
 Popcorn.events.fn.trigger = function(type, data) {
  var popcornInstance, popcorn, virtualEvent, track, timedEvent = false, i;
  if (!trappedEvents[type] || !popcornInstances[this.id]) {
   return trigger.call(this, type, data);
  }
  popcornInstance = popcornInstances[this.id];
  virtualEvent = popcornInstance.children[data.id] || popcornInstance.trackEventsByChildId[data.id];
  if (type === "trackstart" || type === "trackend" || type === "trackremoved" || type === "trackteardown") {
   if (virtualEvent) {
    popcorn = popcornInstance.popcorn;
    if (type === "trackstart") {
     if (virtualEvent.fakeTrackEvent) {
      virtualEvent.fakeTrackEvent._running = true;
     }
     if (!virtualEvent.started) {
      virtualEvent.started = true;
      timedEvent = true;
     }
    } else {
     if (virtualEvent.fakeTrackEvent) {
      virtualEvent.fakeTrackEvent._running = false;
     }
     if (virtualEvent.started) {
      timedEvent = true;
      virtualEvent.started = false;
      for (i = 0; i < virtualEvent.actualTrackEvents.length; i++) {
       track = getTrackEvent(popcorn, virtualEvent.actualTrackEvents[i]);
       if (track && track._running) {
        timedEvent = false;
        virtualEvent.started = true;
        break;
       }
      }
     }
    }
   }
   if (timedEvent) {
    track = popcorn.getTrackEvent(virtualEvent.id) || data.track || data;
    if (type === "trackstart" && getTrackEvent(popcorn, virtualEvent.id) !== track) {
     if (virtualEvent.fakeTrackEvent) {
      virtualEvent.fakeTrackEvent.container = data.track.container;
     }
    }
    trigger.call(popcorn, type === "trackstart" ? type :"trackend", Popcorn.extend({}, track, {
     plugin:virtualEvent.route,
     type:type,
     track:track
    }));
    return;
   }
  }
  if (popcornInstance.contextOptions.allTriggers || !virtualEvent) {
   return trigger.call(this, type, data);
  }
  return this;
 };
 Popcorn.p.emit = Popcorn.events.fn.trigger;
 Popcorn.p.trigger = Popcorn.events.fn.trigger;
 Popcorn.forEach(Popcorn.registryByName, function(plugin, name) {
  popcornPlugins[name] = Popcorn.p[name];
  Popcorn.p[name] = function(id, options) {
   executeFilter(this, name, id, options);
   return this;
  };
 });
});

(function(root, factory) {
 if (typeof exports === "object") {
  var Popcorn = require("popcorn");
  require("popcorn.filter");
  module.exports = factory(Popcorn);
 } else if (typeof define === "function" && define.amd) {
  define("popcorn.classes", [ "popcorn", "popcorn.filter" ], factory);
 } else {
  factory(root.Popcorn);
 }
})(this, function(Popcorn, popcornfilter, undefined) {
 var originalClasses = {};
 Popcorn.filter("classes", "", function(name, options, next, node) {
  var container, nodeData, originals, classes, addClass = Popcorn.basePlugin.addClass, removeClass = Popcorn.basePlugin.removeClass;
  next(options);
  container = node.fakeTrackEvent.container;
  if (container && container.parentNode && options.hasOwnProperty("customClasses")) {
   nodeData = originalClasses[node.uid];
   if (nodeData) {
    if (nodeData.customClasses === options.customClasses) {
     return;
    }
    originals = nodeData.originals;
    Popcorn.forEach(nodeData.customClasses.split(" "), function(c) {
     if (originals.indexOf(c) < 0) {
      removeClass(container, c);
     }
    });
    originals = container.className.split(" ");
    nodeData.customClasses = options.customClasses;
   } else {
    originals = container.className.split(" ");
    originalClasses[node.uid] = {
     customClasses:options.customClasses,
     originals:originals
    };
   }
   classes = options.customClasses.split(" ");
   classes = originals.concat(classes);
   Popcorn.forEach(classes, function(c) {
    addClass(container, c);
   });
  }
 }, false, function(node) {
  delete originalClasses[node.uid];
 });
});

(function(root, factory) {
 if (typeof exports === "object") {
  var Popcorn = require("popcorn");
  require("popcorn.filter");
  module.exports = factory(Popcorn);
 } else if (typeof define === "function" && define.amd) {
  define("popcorn.datafilter", [ "popcorn", "popcorn.filter" ], factory);
 } else {
  factory(root.Popcorn);
 }
})(this, function(Popcorn, undefined) {
 var nodes = {}, trackEvents = {};
 Popcorn.dataFilter = function(dataFields, name, route, fn, beginning, teardown) {
  var newFilterFn, fields, hash, i, k;
  if (!Popcorn.isArray(dataFields)) {
   fields = [ dataFields ];
  } else if (dataFields.length === 1) {
   fields = [ dataFields[0] ];
  } else {
   hash = {};
   fields = [];
   for (i = 0; i < dataFields.length; i++) {
    k = dataFields[i];
    if (!hash.hasOwnProperty(k)) {
     hash[k] = true;
     fields.push(k);
    }
   }
  }
  newFilterFn = function(name, options, next, node) {
   var popcorn = this, nodeRef, trackEventRef, newNext, dfTeardown;
   if (!popcorn.getData) {
    fn(name, options, next, node);
    return;
   }
   nodeRef = nodes[node.uid];
   if (!nodeRef) {
    nodeRef = nodes[node.uid] = {
     uid:node.uid,
     node:node,
     fields:{},
     dataFilters:{},
     dirty:true,
     name:name,
     options:options,
     next:false,
     wrapper:function(name, options, next, node) {
      var i, args;
      if (nodeRef.dirty) {
       nodeRef.dirty = false;
       args = [ name, options, next, node ];
       for (i = 0; i < fields.length; i++) {
        args.push(popcorn.getData(node.virtualEventId, fields[i]));
       }
       return fn.apply(popcorn, args);
      }
     }
    };
   } else {
    nodeRef.dirty = true;
   }
   Popcorn.forEach(fields, function(field) {
    trackEventRef = trackEvents[field + "/" + node.virtualEventId];
    if (!trackEventRef) {
     trackEventRef = trackEvents[field + "/" + node.virtualEventId] = {
      field:field,
      id:node.virtualEventId,
      nodes:[ nodeRef ],
      observer:function() {
       var i, nodeRef;
       for (i = 0; i < trackEventRef.nodes.length; i++) {
        trackEventRef.nodes[i].dirty = true;
       }
       for (i = 0; i < trackEventRef.nodes.length; i++) {
        nodeRef = trackEventRef.nodes[i];
        nodeRef.wrapper(nodeRef.name, nodeRef.options, nodeRef.next, nodeRef.node);
       }
      }
     };
     popcorn.watchData(node.virtualEventId, field, trackEventRef.observer);
     nodeRef.dataFilters[field] = trackEventRef;
    } else if (trackEventRef.nodes.indexOf(nodeRef) < 0) {
     trackEventRef.nodes.push(nodeRef);
     nodeRef.dataFilters[field] = trackEventRef;
    }
   });
   newNext = nodeRef.next;
   if (!newNext) {
    newNext = nodeRef.next = function(branchId, opts, newRoute) {
     nodeRef.dirty = false;
     next(branchId, opts, newRoute);
    };
   }
   nodeRef.name = name;
   nodeRef.options = options;
   dfTeardown = nodeRef.wrapper(name, options, newNext, node);
   return function(node) {
    var ref = nodes[node.uid];
    if (!ref) {
     return;
    }
    Popcorn.forEach(ref.dataFilters, function(trackEventRef) {
     var i;
     if (!trackEventRef) {
      return;
     }
     i = trackEventRef.nodes.indexOf(nodeRef);
     if (i >= 0) {
      trackEventRef.nodes.splice(i, 1);
     }
     if (!trackEventRef.nodes.length) {
      popcorn.unwatchData(node.virtualEventId, trackEventRef.field, trackEventRef.observer);
      delete trackEvents[trackEventRef.field + "/" + trackEventRef.id];
     }
    });
    delete nodes[node.uid];
    nodeRef.deleted = false;
    if (dfTeardown) {
     dfTeardown(node);
    }
   };
  };
  Popcorn.filter(name, route, newFilterFn, beginning, teardown);
 };
 return Popcorn.dataFilter;
});

define("player.playereval", [ "popcorn", "lodash.noconflict", "logging" ], function(Popcorn, _, logging) {
 function TemplateEvaluator(plugin, options) {
  var templateVars = [];
  this.watchTemplateVars = function(text, onChange) {
   if (plugin.getData) {
    Popcorn.forEach(templateVars, function(name) {
     plugin.unwatchData(options.dataId || options.id, name, onChange);
    });
    if (text) {
     templateVars = plugin.dataMethod(options.dataId || options.id, "templateVars", text) || text;
     Popcorn.forEach(templateVars, function(name) {
      plugin.watchData(options.dataId || options.id, name, onChange);
     });
    }
   }
  };
  this.evaluate = function(text, encode) {
   if (text && plugin.dataMethod && !plugin.getData(options.dataId || options.id, "hapyak-editing")) {
    text = plugin.dataMethod(options.dataId || options.id, "render", text, encode) || text;
   }
   return text;
  };
 }
 return {
  TemplateEvaluator:TemplateEvaluator,
  playereval:function playereval(popcorn, expression) {
   var nop = function() {}, scope = {}, resetVariables = function() {
    popcorn.resetData();
   }, resetCondition = function(id) {
    popcorn.setData(null, "event-" + id + "/condition", false);
   }, resetQuiz = function(id) {
    var keys, key;
    keys = popcorn.dataKeys();
    key = "quiz_" + id + "_";
    _.each(keys, function(k) {
     if (k.substr(0, key.length) === key) {
      popcorn.clearData(k);
     }
    });
    popcorn.setData(null, "event-" + id + "/condition", false);
   };
   var playlistInstance = {
    back:nop,
    isFirst:nop,
    isLast:nop,
    first:nop,
    last:nop,
    next:nop,
    pause:nop,
    play:nop,
    previous:nop,
    viewer:nop,
    volume:nop
   };
   var playerType, playlistId;
   if (typeof hapyak.playlist === "object" && typeof hapyak.playlist.get === "function") {
    playerType = popcorn.getData("playerType");
    playlistId = popcorn.getData("playlistId");
    logging.dev("[playereval] Look up playlist", playerType, playlistId);
    if (playerType && playlistId) {
     playlistInstance = hapyak.playlist.get(playerType + "_" + playlistId) || playlistInstance;
    }
   } else if (expression.indexOf("playlist") !== -1) {
    logging.dev("[playereval] HapYak Playlist API not available: " + expression);
   }
   expression = expression.replace(/([\w_\$]+\s?=\s?['"]?[\w_\$]+['"]?)/g, "scope.$1").replace(/([\w_\$]+)\+\+/g, 'scope.$1 = player.getData("$1") + 1');
   new Function("window", "self", "top", "document", "_", "scope", "player", "playlist", "resetVariables", "resetCondition", "resetQuiz", " " + expression)(undefined, undefined, undefined, undefined, undefined, scope, popcorn.options.hapyakPlayer, playlistInstance, resetVariables, resetCondition, resetQuiz);
   _.each(scope, function(val, key) {
    popcorn.setData(key, val);
   });
  }
 };
});

define("popcorn.onclick", [ "module", "popcorn", "utils", "utils.samedomain", "utils.validatelink", "logging", "configuration", "popcorn.datafilter", "popcorn.data", "player.playereval" ], function(module, Popcorn, utils, sameDomain, validateLink, logging, configuration, datafilter, popcorndata, playereval, undefined) {
 var moduleConfig = module.config(), playerConfig = configuration && configuration.player;
 var dynamicAnnotations = configuration.provisioning.dynamicAnnotations, filterClass = "hapyak-filter-onclick", localLinks = playerConfig.localLinks || moduleConfig.localLinks || false, onclickData = {};
 var addClass, loadTrackTime, popcorn, removeClass, video;
 function setFilterData(uid, key, value) {
  if (typeof value !== "undefined" && value !== null) {
   if (!onclickData[uid]) {
    onclickData[uid] = {};
   }
   onclickData[uid][key] = value;
  } else {
   unsetFilterData(uid, key);
  }
  return value;
 }
 function getFilterData(uid, key) {
  if (onclickData[uid]) {
   if (typeof key !== "undefined") {
    return onclickData[uid][key];
   }
   return onclickData[uid];
  }
 }
 function unsetFilterData(uid, key) {
  if (onclickData[uid]) {
   if (typeof key !== "undefined") {
    delete onclickData[uid][key];
    return;
   }
   delete onclickData[uid];
  }
 }
 function getOnClick(options, key) {
  if (!options || !options.hasOwnProperty("onClick") || !options.onClick) {
   return;
  }
  var value = options.onClick[key];
  if (typeof value !== "undefined") {
   return value;
  }
 }
 function onMouseOver(evt) {
  addClass(evt.target.parentNode, "hapyak-link-focused");
 }
 function onMouseOut(evt) {
  removeClass(evt.target.parentNode, "hapyak-link-focused");
 }
 Popcorn.dataFilter([ "hapyak-editing" ], "onclick", [ "image", "pop", "hotlink" ], function(name, options, next, node, hapyakEditing) {
  var isUpdate = false, isActive = false, linkHandler = getFilterData(node.uid, "linkHandler"), trackHandler = getFilterData(node.uid, "trackHandler"), cssHandler = getFilterData(node.uid, "cssHandler"), varHandler = getFilterData(node.uid, "varHandler"), loopbackHandler = getFilterData(node.uid, "loopbackHandler"), trackingHandler = getFilterData(node.uid, "trackingHandler"), templateEvaluator = new playereval.TemplateEvaluator(this, options), isEditing, target, link, linkTarget, track, trackTime, cssClass, expression, loopback, pause;
  addClass = Popcorn.basePlugin.addClass;
  removeClass = Popcorn.basePlugin.removeClass;
  popcorn = this;
  video = popcorn.media;
  loadTrackTime = this.options.loadTrackTime;
  isEditing = hapyakEditing || false;
  if (node.actualTrackEvents.length) {
   isUpdate = true;
  }
  next(options);
  if (typeof node.fakeTrackEvent.container === "object") {
   target = node.fakeTrackEvent.container;
   if (!trackingHandler) {
    trackingHandler = setFilterData(node.uid, "trackingHandler", function(uid) {
     return function(event) {
      var link = getFilterData(uid, "link"), props, trackTime = utils.getTrackTime(getFilterData(uid, "trackTime")), variables = getOnClick(options, "setVariables");
      if (event && !(event.target instanceof HTMLAnchorElement) && event.preventDefault) {
       event.preventDefault();
      }
      if (logging && node.options.annotationId) {
       props = {
        Remaining:popcorn.duration() - popcorn.currentTime(),
        Rollup:[]
       };
       if (link) {
        link = templateEvaluator.evaluate(link, true);
        props.Target = link;
        props.Rollup.push("link");
       }
       if (trackTime) {
        props.Rollup.push("navigation");
        if (+trackTime.time >= 0) {
         props["Target Time"] = trackTime.time;
        }
        if (+trackTime.track >= 0) {
         props["Target Track"] = trackTime.track;
        }
       }
       if (variables) {
        props["Target Expression"] = variables;
       }
       if (node.options.text) {
        props.Text = node.options.text;
       }
       logging.tracking.annotationActionById(node.options.annotationId, name, link ? "External Click" :"Click", props);
      }
     };
    }(node.uid));
    target.addEventListener("click", trackingHandler, false);
   }
   if (linkHandler) {
    target.removeEventListener("click", linkHandler);
   }
   link = setFilterData(node.uid, "link", getOnClick(options, "gotoLink") || options.link);
   pause = setFilterData(node.uid, "pause", getOnClick(options, "pause"));
   if (link && !validateLink(link)) {
    link = null;
   }
   if (link) {
    link = templateEvaluator.evaluate(link, true);
    target.setAttribute("title", link);
    addClass(target, "hapyak-linked");
    if (target.nodeName.toLowerCase() === "a") {
     target.setAttribute("href", link);
     linkTarget = setFilterData(node.uid, "linkTarget", getOnClick(options, "gotoLinkTarget") || options.target);
     if (linkTarget) {
      target.setAttribute("target", linkTarget);
     } else if (!localLinks || !sameDomain.test(link)) {
      target.setAttribute("target", "_new");
     }
    }
    isActive = true;
    linkHandler = setFilterData(node.uid, "linkHandler", function(uid) {
     var link = getFilterData(uid, "link"), pause = getFilterData(uid, "pause");
     return function(event) {
      event.preventDefault();
      link = templateEvaluator.evaluate(link, true);
      if (!isEditing && link) {
       popcorn.emit("clearactivepauses");
       if (pause) {
        popcorn.pause();
       }
       utils.navigateToUrl(link, linkTarget);
      }
     };
    }(node.uid));
    target.addEventListener("click", linkHandler);
    target.addEventListener("mouseover", onMouseOver, true);
    target.addEventListener("mouseout", onMouseOut, true);
   } else {
    removeClass(target, "hapyak-linked");
    target.removeAttribute("title");
    target.removeEventListener("mouseover", onMouseOver, true);
    target.removeEventListener("mouseout", onMouseOut, true);
   }
   if (trackHandler) {
    target.removeEventListener("click", trackHandler);
   }
   track = setFilterData(node.uid, "track", getOnClick(options, "gotoTrack"));
   if (loadTrackTime && track) {
    trackTime = setFilterData(node.uid, "trackTime", /^([0-9]+)?(?:#(?:([0-9]+):)?([0-9]+(?:\.[0-9]+)?))?$/.exec(track));
    if (trackTime) {
     isActive = true;
     trackHandler = setFilterData(node.uid, "trackHandler", function(uid) {
      var trackTime = utils.getTrackTime(getFilterData(uid, "trackTime"));
      return function(event) {
       event.preventDefault();
       if (!isEditing && trackTime) {
        loadTrackTime(trackTime.track, trackTime.time);
       }
      };
     }(node.uid));
     target.addEventListener("click", trackHandler);
    }
   } else {
    unsetFilterData(node.uid, "trackTime");
   }
   if (cssHandler) {
    target.removeEventListener("click", cssHandler);
   }
   cssClass = setFilterData(node.uid, "cssClass", getOnClick(options, "addClasses"));
   if (cssClass) {
    isActive = true;
    cssHandler = setFilterData(node.uid, "cssHandler", function(uid) {
     var cssClass = getFilterData(uid, "cssClass");
     return function(event) {
      event.preventDefault();
      if (!isEditing) {
       addClass(target, cssClass);
      }
     };
    }(node.uid));
    target.addEventListener("click", cssHandler);
   }
   if (varHandler) {
    target.removeEventListener("click", varHandler);
   }
   expression = setFilterData(node.uid, "expression", getOnClick(options, "setVariables"));
   if (expression && dynamicAnnotations) {
    isActive = true;
    varHandler = setFilterData(node.uid, "varHandler", function(uid) {
     return function(event) {
      event.preventDefault();
      if (!isEditing) {
       var expression = getFilterData(uid, "expression");
       playereval.playereval(popcorn, expression);
      }
     };
    }(node.uid));
    target.addEventListener("click", varHandler);
   }
  }
  loopback = setFilterData(node.uid, "loopback", getOnClick(options, "loopback"));
  if (loopback === "loop") {
   if (!loopbackHandler) {
    loopbackHandler = setFilterData(node.uid, "loopbackHandler", function() {
     var continueVideo = false;
     return {
      trackEnd:function(trackEvent) {
       var currentTime;
       if (trackEvent.id === node.fakeTrackEvent._id && !continueVideo) {
        currentTime = popcorn.currentTime();
        if (Math.abs(currentTime - trackEvent.end) < 1) {
         popcorn.currentTime(trackEvent.start);
        }
       }
       continueVideo = false;
      },
      click:function() {
       continueVideo = true;
      }
     };
    }());
    target.addEventListener("click", loopbackHandler.click);
    popcorn.on("trackend", loopbackHandler.trackEnd);
   }
  } else {
   if (loopbackHandler) {
    popcorn.off("trackend", loopbackHandler.trackEnd);
    target.removeEventListener("click", loopbackHandler.click);
    unsetFilterData(node.uid, "loopbackHandler");
   }
  }
  if (isActive) {
   addClass(target, filterClass);
  } else {
   removeClass(target, filterClass);
  }
 }, false, function(node) {
  var uid = node.uid, data = getFilterData(uid), target = node.fakeTrackEvent.container;
  if (target && data) {
   if (data.trackingHandler) {
    target.removeEventListener("click", data.trackingHandler, false);
   }
   if (data.linkHandler) {
    target.removeEventListener("click", data.linkHandler);
    target.removeEventListener("mouseover", onMouseOver, true);
    target.removeEventListener("mouseout", onMouseOut, true);
   }
   if (data.trackHandler) {
    target.removeEventListener("click", data.trackHandler);
   }
   if (data.cssHandler) {
    target.removeEventListener("click", data.cssHandler);
   }
   if (data.varHandler) {
    target.removeEventListener("click", data.varHandler);
   }
   if (data.loopbackHandler) {
    popcorn.off("trackend", data.loopbackHandler.trackEnd);
    target.removeEventListener("click", data.loopbackHandler.click);
   }
   removeClass(target, filterClass);
   removeClass(target, "hapyak-linked");
   if (data.cssClass) {
    removeClass(target, data.cssClass);
   }
   unsetFilterData(uid);
  }
 });
 return true;
});

(function(root, factory) {
 if (typeof exports === "object") {
  var Popcorn = require("popcorn");
  require("popcorn.datafilter");
  module.exports = factory(Popcorn);
 } else if (typeof define === "function" && define.amd) {
  define("popcorn.precondition", [ "popcorn", "popcorn.datafilter" ], factory);
 } else {
  factory(root.Popcorn);
 }
})(this, function(Popcorn, datafilter, undefined) {
 var nodeFields = {}, varNameRegex = /\b[a-z_$][a-z_$0-9]*\b/gim, reservedWords = /^(break|case|catch|const|continue|debugger|default|delete|do|else|false|finally|for|function|if|in|instanceof|new|return|switch|this|throw|try|typeof|var|void|while|with|class|enum|export|extends|import|super|implements|interface|let|package|private|protected|public|static|yield|Infinity|Intl|JSON|Math|NaN|undefined|null|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|isNaN|parseFloat|parseInt|true|uneval|Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|SyntaxError|TypeError|URIError|Intl|ArrayBuffer|DataView|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|ParallelArray)$/;
 function makeFunction(args, fnString) {
  var a = args.slice(0);
  a.push(fnString);
  return Function.apply(null, a);
 }
 Popcorn.dataFilter([ "editMode", "condition" ], "precondition", "", function(name, options, next, node, editMode, condition) {
  var key, nodeRef, popcorn = this, expr, match, fields = {}, oldFields = {}, foundVar = false, expressionChanged = true;
  if (!editMode && options.precondition === true && condition) {
   next(null);
   return;
  }
  expr = typeof options.precondition === "string" ? options.precondition :"";
  nodeRef = nodeFields[node.uid];
  if (nodeRef) {
   expressionChanged = nodeRef.expr !== expr;
   if (expressionChanged) {
    nodeRef.expr = expr;
    oldFields = nodeRef.fields;
    nodeRef.fields = fields;
   }
  } else if (!expr) {
   next(options);
   return;
  }
  if (expressionChanged) {
   match = varNameRegex.exec(expr);
   while (match) {
    key = match[0];
    if (!reservedWords.test(key)) {
     fields[key] = true;
     foundVar = true;
    }
    match = varNameRegex.exec(expr);
   }
   for (key in oldFields) {
    if (oldFields.hasOwnProperty(key) && !fields.hasOwnProperty(key)) {
     popcorn.unwatchData(node.virtualEventId, key, nodeRef.observer);
    }
   }
  }
  if (!expr) {
   next(options);
   return;
  }
  if (!nodeRef) {
   nodeRef = nodeFields[node.uid] = {
    expr:expr,
    fields:fields,
    params:null,
    evalFn:null,
    observer:function() {
     var paramValues = [], key, success = true, i;
     for (i = 0; i < nodeRef.params.length; i++) {
      key = nodeRef.params[i];
      paramValues.push(popcorn.getData(node.virtualEventId, key));
     }
     try {
      success = nodeRef.evalFn.apply(null, paramValues);
     } catch (e) {
      success = true;
     }
     if (success) {
      next(options);
     } else {
      next(null);
     }
    }
   };
  }
  if (expressionChanged) {
   try {
    nodeRef.params = Object.keys(fields);
    nodeRef.evalFn = makeFunction(nodeRef.params, "return !!(" + expr + ")");
   } catch (e) {
    nodeRef.evalFn = function() {
     return true;
    };
   }
   for (key in fields) {
    if (fields.hasOwnProperty(key) && !oldFields.hasOwnProperty(key)) {
     popcorn.watchData(node.virtualEventId, key, nodeRef.observer);
    }
   }
   nodeRef.params = Object.keys(fields);
  }
  if (editMode) {
   next(options);
   return;
  }
  nodeRef.observer();
 }, true, function(node) {
  var nodeRef = nodeFields[node.uid], popcorn = this, key;
  if (!nodeRef) {
   return;
  }
  for (key in nodeRef.fields) {
   if (nodeRef.fields.hasOwnProperty(key)) {
    popcorn.unwatchData(node.virtualEventId, key, nodeRef.observer);
   }
  }
  delete nodeFields[node.uid];
 });
});

(function(root, factory) {
 if (typeof exports === "object") {
  var Popcorn = require("popcorn");
  require("popcorn.filter");
  module.exports = factory(Popcorn);
 } else if (typeof define === "function" && define.amd) {
  define("popcorn.transitions", [ "popcorn", "popcorn.filter" ], factory);
 } else {
  factory(root.Popcorn);
 }
})(this, function(Popcorn, popcornfilter, undefined) {
 var supportedPlugins = [ "pop", "image" ];
 Popcorn.filter("transitions", supportedPlugins, function(name, options, next, node) {
  var container, addClass = Popcorn.basePlugin.addClass, removeClass = Popcorn.basePlugin.removeClass;
  options.transitionClass = options.transition || options.transitionClass || "hapyak-transition-none";
  delete options.transition;
  next(options);
  container = node.fakeTrackEvent.container;
  if (supportedPlugins.indexOf(node.fakeTrackEvent._natives.type) > -1 && node.actualTrackEvents.indexOf(node.options.id) > -1 && container && container.parentNode) {
   Popcorn.forEach([ "hapyak-transition-none", "hapyak-transition-fade", "hapyak-transition-pop", "hapyak-transition-slide-up" ], function(transition) {
    removeClass(container, transition);
   });
   addClass(container, options.transitionClass);
  }
 }, false);
});

(function(window, Popcorn, undefined) {
 var document = window.document, pluginFn, incompatible = {}, fallbacks = {}, nullFallback, addEventListener, media;
 pluginFn = Popcorn.plugin;
 nullFallback = {
  start:function() {},
  end:function() {}
 };
 function getFallback(popcorn, name, options) {
  var fallback = popcorn.data.fallbacks && (popcorn.data.fallbacks[name] || popcorn.data.fallbacks[""]) || fallbacks[name] || fallbacks[""] || nullFallback;
  if (typeof fallback === "function") {
   fallback = fallback.call(popcorn, options);
  }
  return fallback;
 }
 Popcorn.plugin = function(name, definition, manifest) {
  var newDefinition, testFn;
  testFn = manifest && manifest.incompatible || definition.incompatible;
  if (typeof testFn === "function") {
   incompatible[name] = testFn();
   if (!incompatible[name]) {
    newDefinition = definition;
    pluginFn(name, newDefinition, manifest);
    return;
   }
   newDefinition = function(options) {
    return getFallback(this, name, options);
   };
  } else if (typeof definition !== "function") {
   newDefinition = definition;
  } else {
   newDefinition = function(options) {
    var def = definition.call(this, options), incomp;
    incomp = incompatible[name];
    if (incomp === undefined && typeof def.incompatible === "function") {
     incomp = def.incompatible.call(this, options);
     incompatible[name] = incomp;
     if (incomp && def._teardown) {
      def._teardown.call(this, options);
     }
    }
    if (!incomp) {
     return def;
    }
    return getFallback(this, name, options);
   };
  }
  pluginFn(name, newDefinition, manifest);
 };
 Popcorn.incompatible = function(hook) {
  var elem;
  if (hook) {
   return incompatible[hook] || false;
  }
  if (addEventListener === undefined) {
   addEventListener = !document.addEventListener;
  }
  if (addEventListener) {
   return "Obsolete browser: No support for addEventListener";
  }
  if (media === undefined) {
   media = false;
   if (!Popcorn._MediaElementProto) {
    elem = document.createElement("video");
    if (!elem || !elem.canPlayType) {
     media = true;
    }
   }
  }
  if (media) {
   return "Obsolete browser: No support for HTML5 video";
  }
  return false;
 };
 Popcorn.prototype.incompatible = function(hook) {
  var failure, obj, i, events, evt, t, count = 0;
  failure = Popcorn.incompatible(hook);
  if (failure) {
   return failure;
  }
  obj = {};
  events = this.data.trackEvents.byStart;
  for (i = 0; i < events.length && count < Popcorn.registry.length; i++) {
   evt = events[i];
   t = evt._natives && evt._natives.type;
   if (t && obj[t] === undefined) {
    obj[t] = Popcorn.incompatible(t);
    count++;
   }
  }
  return !!count && obj;
 };
 Popcorn.fallback = function(hook, definition) {
  if (typeof hook === "object" || typeof hook === "function") {
   definition = hook;
   hook = "";
  }
  fallbacks[hook] = definition;
 };
 Popcorn.prototype.fallback = function(hook, definition) {
  if (!this.data.fallbacks) {
   this.data.fallbacks = {
    "":nullFallback
   };
  }
  if (typeof hook === "object" || typeof hook === "function") {
   definition = hook;
   hook = "";
  }
  this.data.fallbacks[hook] = definition;
 };
})(this, this.Popcorn);

define("popcorn.compatible", function() {});

(function(window, Popcorn) {
 var document = window.document, console = window.console, popcornInstances = {}, BasePopcorn, PopcornBasePlugin, PopcornBaseEvent, allTargets = [], timing, numRegex = /[\-+]?[0-9]*\.?[0-9]+/g, styleHyphenRegex = /\-([a-z])/g, stylePrefixRegex = /^\-\*\-([a-z\-]+)/, browserPrefixes = [ "", "-moz-", "-webkit-", "-o-", "-ms-" ], colorRegex = /#(([0-9a-fA-F]{3,8}))/g, rgbaRegex = /(rgba?)\(\s*([0-9]*\.?[0-9]+)\s*,\s*([0-9]*\.?[0-9]+)\s*,\s*([0-9]*\.?[0-9]+)\s*(,([0-9]*\.?[0-9]+))?\)/gi, timingRegex = /^([A-Za-z\-]+)(\((([\-+]?[0-9]*\.?[0-9]+)(,\s*([\-+]?[0-9]*\.?[0-9]+))*)\))?$/, updatePropertyBlacklist = /^(_(natives|id|running)|id|target|effect|compose|toString|container)$/;
 if (!console) {
  console = {
   log:function() {}
  };
 }
 function logError(err) {
  if (err) {
   console.log(err.stack || err.stacktrace || err.message || err);
  }
 }
 BasePopcorn = function(popcorn) {
  var base, activePauses = [], resume, me = this, hasPlayed = false;
  function updatePausedState() {
   var i, pause, now = Date.now();
   for (i = 0; i < activePauses.length; i++) {
    pause = activePauses[i];
    if (pause.expires <= now && pause.duration > 0) {
     me.pauseOff(pause);
     i--;
    } else if (pause.callback) {
     pause.callback((now - pause.started) / 1e3);
    }
   }
   if (activePauses.length) {
    setTimeout(updatePausedState, 16);
   }
  }
  function clearPause() {
   hasPlayed = true;
   while (activePauses.length) {
    me.pauseOff(activePauses[0]);
   }
  }
  if (window === this || !(this instanceof BasePopcorn)) {
   base = BasePopcorn.find(popcorn);
   if (!base) {
    base = new BasePopcorn(popcorn);
   }
   return base;
  }
  this.popcorn = popcorn;
  this.id = Popcorn.guid();
  popcornInstances[this.id] = this;
  this.pauseOn = function(pause) {
   var now = Date.now();
   activePauses.push(pause);
   pause.started = now;
   pause.expires = now + pause.duration * 1e3;
   if (activePauses.length === 1) {
    resume = !hasPlayed ? true :!popcorn.paused();
    popcorn.pause();
    updatePausedState();
   }
  };
  this.pauseOff = function(pause) {
   var i;
   if (!activePauses.length) {
    return;
   }
   i = activePauses.indexOf(pause);
   if (i >= 0) {
    activePauses.splice(i, 1);
   }
   if (!activePauses.length && resume) {
    popcorn.play();
   }
  };
  this.pauseCancel = function(pauses) {
   if (pauses) {
    Popcorn.forEach(pauses, function(p) {
     var i = activePauses.indexOf(p);
     if (i >= 0) {
      activePauses.splice(i, 1);
     }
     i = pauses.indexOf(p);
     if (i >= 0) {
      pauses.splice(i, 1);
     }
    });
    return;
   }
   while (pauses.length) {
    activePauses.pop();
    pauses.pop();
   }
  };
  popcorn.on("clearactivepauses", clearPause);
  popcorn.on("play", clearPause);
 };
 BasePopcorn.find = function(instance) {
  var id, bp;
  for (id in popcornInstances) {
   if (popcornInstances.hasOwnProperty(id)) {
    bp = popcornInstances[id];
    if (bp && bp.popcorn === instance) {
     return bp;
    }
   }
  }
 };
 BasePopcorn.plugins = {};
 BasePopcorn.register = function(pluginName, basePlugin) {
  BasePopcorn.plugins[pluginName] = basePlugin;
 };
 PopcornBasePlugin = function(pluginName, plugin, manifest) {
  var definition, me = this;
  this.name = pluginName;
  this.pluginFn = plugin;
  this.events = {};
  definition = function(options) {
   var popcorn = this, event = new PopcornBaseEvent(popcorn, me, options);
   return event.definition();
  };
  Popcorn.forEach(plugin, function(val, key) {
   definition[key] = val;
  });
  Popcorn.forEach(plugin, function(val, key) {
   definition[key] = val;
  });
  Popcorn.plugin(pluginName, definition, manifest);
  BasePopcorn.register(pluginName, this);
 };
 PopcornBaseEvent = function(popcorn, basePlugin, options) {
  var current = false, started = false, setupFn, updateFn, startFn, frameFn, endFn, teardownFn, me = this, instanceId, allEvents, allEventsByTarget, basePopcorn = BasePopcorn(popcorn), animatedProperties = {}, pauses = [], pauseTime = 0, setStyles = [], animations = [], definition, i;
  function runCallbackFunction(fn, time) {
   if (fn && typeof fn === "string") {
    fn = window[fn];
   }
   if (fn && typeof fn === "function") {
    try {
     fn.call(me, options, time);
    } catch (e) {
     logError(e);
    }
   }
  }
  function updateAnimations(fraction) {
   function findPreviousKeyframe(keyframes, t) {
    var i;
    if (!keyframes.length) {
     return;
    }
    if (keyframes[0].t > t) {
     return -1;
    }
    for (i = 1; i < keyframes.length; i++) {
     if (keyframes[i].t >= t) {
      return i - 1;
     }
    }
    return i - 1;
   }
   function join(vals, str) {
    var i, out = [];
    for (i = 0; i < vals.length; i++) {
     out.push(str[i]);
     out.push(vals[i]);
    }
    out.push(str[i]);
    return out.join("");
   }
   function rgbaRound(match, rgba, r, g, b, x, a) {
    var params = [ r, g, b ], i;
    for (i = 0; i < 3; i++) {
     params[i] = Math.round(parseFloat(params[i]));
    }
    if (x) {
     params.push(a);
    }
    return rgba + "(" + params.join(",") + ")";
   }
   var i, j, f, prop, val, from, to, delta, current, timingFn;
   for (i in animatedProperties) {
    if (animatedProperties.hasOwnProperty(i)) {
     prop = animatedProperties[i];
     from = findPreviousKeyframe(prop.keyframes, fraction);
     to = prop.keyframes[from + 1];
     from = prop.keyframes[from];
     if (!from) {
      from = to;
     }
     if (!to || from === to) {
      val = prop.str ? join(from.val, prop.str) :from.val[0];
     } else {
      delta = to.t - from.t;
      timingFn = from.timing || prop.timing;
      f = timingFn((fraction - from.t) / delta);
      from = from.val;
      to = to.val;
      current = [];
      for (j = 0; j < from.length; j++) {
       current.push(from[j] + (to[j] - from[j]) * f);
      }
      if (prop.str) {
       val = join(current, prop.str);
       val = val.replace(rgbaRegex, rgbaRound);
      } else {
       val = current[0];
      }
     }
     me.options[i] = val;
     if (prop.callback) {
      prop.callback.call(me, val);
     }
    }
   }
  }
  function insertContainer() {
   var i, evt, nextElement = null;
   if (allEventsByTarget) {
    for (i = allEventsByTarget.length - 1; i >= 0; i--) {
     evt = allEventsByTarget[i];
     if (evt === me || evt.options.start < me.options.start || evt.options.start === me.options.start && evt.options.end < me.options.end) {
      break;
     }
     if (evt.container && evt.container.parentNode === me.target) {
      nextElement = evt.container;
     }
    }
   }
   me.target.insertBefore(me.container, nextElement);
  }
  function insertInPlace(target) {
   var evt, i, t;
   if (allEvents) {
    i = allEvents.indexOf(me);
    if (i >= 0) {
     allEvents.splice(i, 1);
    }
   } else {
    allEvents = basePlugin.events[instanceId];
   }
   for (i = allEvents.length - 1; i >= 0; i--) {
    evt = allEvents[i].options;
    if (evt.start <= options.start || evt.start === options.start && evt.end <= options.end) {
     break;
    }
   }
   allEvents.splice(i + 1, 0, me);
   me.allEvents = allEvents;
   if (target !== undefined) {
    if (!(target instanceof window.Element)) {
     target = null;
    }
    if (allEventsByTarget) {
     i = allEventsByTarget.indexOf(me);
     if (i >= 0) {
      allEventsByTarget.splice(i);
     }
    }
    if (!target) {
     delete me.target;
     return;
    }
    if (target !== me.target) {
     me.target = target;
     for (i = 0; i < allTargets.length; i++) {
      t = allTargets[i];
      if (t.target === me.target) {
       allEventsByTarget = t.events;
       break;
      }
     }
     if (!allEventsByTarget) {
      allEventsByTarget = [ me ];
      allTargets.push({
       target:me.target,
       events:allEventsByTarget
      });
      return;
     }
    }
   }
   if (!allEventsByTarget) {
    return;
   }
   for (i = allEventsByTarget.length - 1; i >= 0; i--) {
    evt = allEventsByTarget[i].options;
    if (evt.start < options.start || evt.start === options.start && evt.end <= options.end) {
     break;
    }
   }
   allEventsByTarget.splice(i + 1, 0, me);
  }
  this.popcorn = popcorn;
  this.pluginName = basePlugin.name;
  if (typeof options.start === "string") {
   options.start = Popcorn.util.toSeconds(options.start, popcorn.options.framerate);
  }
  if (!options.start && options.start !== 0) {
   options.start = options["in"] || 0;
  }
  if (typeof options.end === "string") {
   options.end = Popcorn.util.toSeconds(options.end, popcorn.options.framerate);
  }
  if (!options.end && options.end !== 0) {
   options.end = options.out || popcorn.duration() || Number.MAX_VALUE;
  }
  this.options = {};
  for (i in options) {
   if (options.hasOwnProperty(i)) {
    this.options[i] = options[i];
   }
  }
  instanceId = basePopcorn.id;
  if (!basePlugin.events[instanceId]) {
   basePlugin.events[instanceId] = [];
  }
  insertInPlace(typeof options.target === "string" ? document.getElementById(options.target) :options.target);
  this.definition = function() {
   return definition;
  };
  this.makeContainer = function(tag, insert) {
   if (insert === undefined) {
    insert = true;
   }
   if (!tag) {
    tag = "div";
   }
   this.container = document.createElement(tag);
   this.addClass(this.container, "popcorn-" + this.pluginName);
   if (insert && this.target) {
    insertContainer();
   }
   return this.container;
  };
  this.animate = function(name, opts) {
   var callback, animated = false, i, styles = {}, animation;
   function animateOption(name, callback) {
    function fixColors(str) {
     function makeRGBA(hex) {
      var nums, n, i;
      n = hex.length;
      if (n === 4 || n === 5) {
       nums = hex.match(/[0-9A-Fa-f]/g);
       for (i = 0; i < nums.length; i++) {
        nums[i] = parseInt(nums[i] + nums[i], 16);
       }
      } else if (n === 7 || n === 9) {
       nums = hex.match(/[0-9A-Fa-f]{2}/g);
       for (i = 0; i < nums.length; i++) {
        nums[i] = parseInt(nums[i], 16);
       }
      }
      if (nums.length > 3) {
       nums[3] /= 255;
       return "rgba(" + nums.join(",") + ")";
      }
      return "rgb(" + nums.join(",") + ")";
     }
     if (typeof str !== "string") {
      return str;
     }
     return str.replace(colorRegex, makeRGBA, "g");
    }
    function kfSort(a, b) {
     return a.t - b.t;
    }
    function makeTimingFunction(fn) {
     var parsed, args = [], i, x;
     if (!fn) {
      return timing.linear();
     }
     if (typeof fn === "function") {
      return fn;
     }
     parsed = timingRegex.exec(fn);
     if (!parsed) {
      return timing.linear();
     }
     fn = timing[parsed[1]];
     if (!fn) {
      return timing.linear();
     }
     if (parsed[3]) {
      args = parsed[3].split(",");
     }
     for (i = 0; i < args.length; i++) {
      args[i] = parseFloat(args[i]);
     }
     x = fn.apply(null, args);
     if (typeof x === "function") {
      return x;
     }
     return fn;
    }
    var prop, opt, i, j, val, vals, str, count = 1, timingFn, keyframe, keyframes = [];
    if (!name || !options[name]) {
     return false;
    }
    opt = options[name];
    if (typeof opt !== "object") {
     me.options[name] = opt;
     return false;
    }
    prop = {
     name:name,
     keyframes:keyframes,
     timing:makeTimingFunction(opt.timing)
    };
    for (i in opt) {
     if (opt.hasOwnProperty(i)) {
      val = opt[i];
      if (i === "from" && opt[0] === undefined) {
       i = 0;
      } else if (i === "to" && opt[1] === undefined) {
       i = 1;
      } else {
       i = parseFloat(i);
      }
      if (typeof val === "object") {
       timingFn = val[1] || val.timing;
       val = val[0] === undefined ? val.val :val[0];
       if (timingFn === opt.timing) {
        timingFn = prop.timingFn;
       } else {
        timingFn = makeTimingFunction(timingFn);
       }
      } else {
       timingFn = false;
      }
      if (typeof val === "string") {
       val = fixColors(val);
       vals = val.match(numRegex);
      } else if (typeof val === "number") {
       vals = [ val ];
      }
      if (vals && !isNaN(i)) {
       if (!str && typeof val === "string") {
        str = val.split(numRegex);
        count = vals.length;
        if (str.length < count) {
         str.push("");
        }
       }
       if (vals.length === count) {
        for (j = 0; j < vals.length; j++) {
         vals[j] = parseFloat(vals[j], 10);
        }
        keyframe = {
         t:i,
         val:vals
        };
        if (timingFn && timingFn !== prop.timing) {
         keyframe.timing = timingFn;
        }
        keyframes.push(keyframe);
       }
      }
     }
    }
    if (!keyframes.length) {
     me.options[name] = opt;
     return false;
    }
    if (keyframes.length === 1) {
     me.options[name] = keyframes[0].val;
     return false;
    }
    prop.str = str;
    keyframes.sort(kfSort);
    if (typeof callback === "function") {
     prop.callback = callback;
    }
    animatedProperties[name] = prop;
    animation.props.push(name);
    return true;
   }
   function animateStyle(name, element) {
    function isStyle(element, name) {
     function replaceStyleHyphen(str, letter) {
      return letter.toUpperCase();
     }
     var style, lower;
     if (name === "src" || name === "toString" || typeof element.style[name] === "function") {
      return false;
     }
     if (element.style.hasOwnProperty(name)) {
      return name;
     }
     if (window.getComputedStyle) {
      style = window.getComputedStyle(element);
      if (!style) {
       style = window.getComputedStyle(document.body);
       if (!style) {
        return false;
       }
      }
      lower = name.toLowerCase();
      if (style.hasOwnProperty(name) || style[name] !== undefined || style.getPropertyValue(name)) {
       return name.replace(styleHyphenRegex, replaceStyleHyphen) || false;
      }
      if (style.hasOwnProperty(lower) || style[lower] !== undefined || style.getPropertyValue(lower)) {
       return lower;
      }
     }
    }
    var callback, animated = false, backup, jsName, prefixed, prefixedName, i;
    prefixed = stylePrefixRegex.exec(name);
    if (prefixed) {
     prefixed = prefixed[1];
     for (i = 0; i < browserPrefixes.length && !jsName; i++) {
      prefixedName = browserPrefixes[i] + prefixed;
      jsName = isStyle(element, prefixedName);
      if (styles[jsName] || jsName && prefixedName !== name && options[prefixedName]) {
       return false;
      }
     }
    } else {
     jsName = isStyle(element, name);
    }
    if (!jsName) {
     return false;
    }
    if (name === "top" || name === "left" || name === "right" || name === "bottom") {
     element.style.position = "absolute";
    }
    callback = function(val) {
     element.style[jsName] = val;
    };
    styles[jsName] = true;
    backup = {
     e:element,
     name:jsName
    };
    animated = animateOption(name, callback);
    if (!animated) {
     backup.val = options[name];
    }
    setStyles.push(backup);
    return animated;
   }
   if (!name) {
    if (this.container) {
     name = this.container;
    }
   }
   name = name || "";
   for (i = animations.length - 1; i >= 0; i--) {
    animation = animations[i];
    if (animation.name === name) {
     while (animation.props.length) {
      delete animatedProperties[animation.props.pop()];
     }
     animations.splice(i, 1);
     break;
    }
   }
   animation = {
    name:name,
    opts:opts,
    props:[]
   };
   animations.push(animation);
   if (name instanceof window.HTMLElement) {
    for (i in options) {
     if (options.hasOwnProperty(i)) {
      animated = animateStyle(i, name) || animated;
     }
    }
    return animated;
   }
   if (opts instanceof window.HTMLElement) {
    return animateStyle(name, opts);
   }
   if (typeof opts === "function") {
    callback = opts;
   } else if (typeof opts === "object") {
    callback = opts;
   }
   return animateOption(name, callback);
  };
  this.pause = function(pause, callback) {
   var i, p, next, total = me.options.end - me.options.start;
   function sort(a, b) {
    return a.at - b.at;
   }
   while (pauses.length) {
    basePopcorn.pauseOff(pauses.shift());
   }
   if (!total || total < .01) {
    return;
   }
   if (typeof pause === "function") {
    callback = pause;
    pause = 0;
   } else if (typeof callback !== "function") {
    callback = null;
   }
   if (!Popcorn.isArray(pause)) {
    if (typeof pause === "object") {
     pause = [ pause ];
    } else {
     pause = parseFloat(pause);
     if (isNaN(pause)) {
      return;
     }
     pause = [ {
      at:0,
      duration:pause
     } ];
    }
   }
   for (i = 0; i < pause.length; i++) {
    p = pause[i];
    if (typeof p === "object") {
     p = {
      at:p.at || 0,
      duration:p.duration || 2,
      callback:callback
     };
    } else {
     p = parseFloat(p);
     if (!isNaN(p)) {
      p = {
       at:p,
       duration:2,
       callback:callback
      };
     }
    }
    pauses.push(p);
   }
   pauses.sort(sort);
   for (i = pauses.length - 1; i >= 0; i--) {
    p = pauses[i];
    if (next) {
     if (Math.abs(next.at - p.at) < .05) {
      p = next;
      pauses.splice(i, 1);
     } else if (p.range > 0) {
      p.range = Math.min(p.range, (next.at - p.at) / 2);
     } else {
      p.range = Math.min((next.at - p.at) / 2, .25);
     }
    } else {
     if (p.range > 0) {
      p.range = Math.min(p.range, (total - p.at) / 2);
     } else {
      p.range = Math.min(.25, (total - p.at) / 2);
     }
    }
    next = p;
   }
  };
  this.cancelPause = function(all) {
   basePopcorn.pauseCancel(all ? false :pauses);
  };
  definition = basePlugin.pluginFn.call(popcorn, options, this);
  if (!definition) {
   definition = {};
  }
  setupFn = definition._setup;
  definition._setup = function(options) {
   if (typeof setupFn === "function") {
    setupFn.call(me, options);
   }
   runCallbackFunction(options.onSetup);
  };
  startFn = definition.start;
  definition.start = function(event, options) {
   var i, s;
   if (!started) {
    for (i = 0; i < setStyles.length; i++) {
     s = setStyles[i];
     s.backup = s.e.style[s.name];
     s.e.style[s.name] = s.val;
    }
   }
   current = true;
   started = true;
   updateAnimations.call(me, 0);
   if (typeof startFn === "function") {
    startFn.call(me, event, options);
   }
   runCallbackFunction(options.onStart);
   pauseTime = 0;
   definition.frame(event, options, popcorn.currentTime());
  };
  frameFn = definition.frame;
  definition.frame = function(event, options, time) {
   var i, p, start, end;
   if (started) {
    updateAnimations.call(me, (time - me.options.start) / (me.options.end - me.options.start));
    pauseTime = Math.max(time, pauseTime);
    for (i = 0; i < pauses.length; i++) {
     p = pauses[i];
     start = options.start + p.at;
     if (start > pauseTime) {
      break;
     }
     end = start + p.range;
     if (pauseTime < end) {
      basePopcorn.pauseOn(p);
      pauseTime = end;
     }
    }
    if (typeof frameFn === "function") {
     frameFn.call(me, event, options, time);
    }
    runCallbackFunction(options.onFrame, time);
   }
  };
  updateFn = definition._update;
  if (updateFn) {
   definition._update = function(trackEvent, changes) {
    var i, j, s, target, reSort = false, animationList = [];
    if (changes.start === undefined) {
     changes.start = options.start;
    } else {
     changes.start = Popcorn.util.toSeconds(changes.start, popcorn.options.framerate);
    }
    if (changes.end === undefined) {
     changes.end = options.end;
    } else {
     changes.end = Popcorn.util.toSeconds(changes.end, popcorn.options.framerate);
    }
    if (changes.start !== options.start || changes.end !== options.end) {
     reSort = true;
     options.start = changes.start;
     options.end = changes.end;
     me.options.start = options.start;
     me.options.end = options.end;
    }
    if (changes.hasOwnProperty("target")) {
     target = changes.target;
     if (target && typeof target === "string") {
      target = document.getElementById(target);
     }
     if (target !== me.target) {
      reSort = true;
     }
    }
    if (reSort) {
     insertInPlace(target);
     if (me.container) {
      insertContainer();
     }
    }
    if (typeof updateFn === "function") {
     updateFn.call(me, options, changes);
    }
    for (j in changes) {
     if (changes.hasOwnProperty(j) && !updatePropertyBlacklist.test(j)) {
      me.options[j] = changes[j];
      options[j] = changes[j];
      trackEvent[j] = changes[j];
     }
    }
    while (setStyles.length) {
     s = setStyles.shift();
     s.e.style[s.name] = s.backup || "";
    }
    for (i = 0; i < animations.length; i++) {
     animationList.push(animations[i]);
    }
    for (i = 0; i < animations.length; i++) {
     me.animate(animations[i].name, animations[i].opts);
    }
    if (trackEvent._running) {
     for (i = 0; i < setStyles.length; i++) {
      s = setStyles[i];
      s.backup = s.e.style[s.name];
      s.e.style[s.name] = s.val;
     }
    }
    runCallbackFunction(trackEvent.onUpdate);
   };
  }
  endFn = definition.end;
  definition.end = function(event, options) {
   if (started) {
    var i, s;
    updateAnimations.call(me, 1);
    for (i = 0; i < pauses; i++) {
     basePopcorn.pauseOff(pauses[i]);
    }
    runCallbackFunction(options.onEnd);
    if (typeof endFn === "function") {
     endFn.call(me, event, options);
    }
    for (i = 0; i < setStyles.length; i++) {
     s = setStyles[i];
     s.e.style[s.name] = s.backup;
    }
    started = false;
   }
   current = false;
  };
  teardownFn = definition._teardown;
  definition._teardown = function(options) {
   var parent, i;
   runCallbackFunction(options.onTeardown);
   if (typeof teardownFn === "function") {
    teardownFn.call(me, options);
   }
   if (me.container) {
    parent = me.container.parentNode;
    if (parent) {
     parent.removeChild(me.container);
    }
    delete me.container;
   }
   i = allEvents.indexOf(me);
   if (i >= 0) {
    allEvents.splice(i, 1);
   }
  };
 };
 PopcornBaseEvent.prototype.toArray = function(data, delimiters) {
  var out;
  if (data === undefined) {
   return [];
  }
  if (Object.prototype.toString.call(data) === "[object Array]") {
   return data;
  }
  try {
   out = JSON.parse(data);
   if (Object.prototype.toString.call(out) !== "[object Array]") {
    out = [ out ];
   }
  } catch (e) {
   out = data;
  }
  if (delimiters && typeof out === "string") {
   try {
    out = out.split(delimiters);
   } catch (er) {}
  }
  if (out !== undefined && out !== null && Object.prototype.toString.call(out) !== "[object Array]") {
   return [ out ];
  }
  return out;
 };
 PopcornBaseEvent.prototype.toObject = function(data) {
  if (typeof data === "object") {
   return data;
  }
  try {
   return JSON.parse(data);
  } catch (e) {
   return data;
  }
 };
 if (document !== undefined && !document.createElement("a").classList) {
  PopcornBaseEvent.prototype.hasClass = function(element, classes) {
   var curClasses, i;
   if (!classes || !element || !element.getAttribute) {
    return;
   }
   curClasses = element.getAttribute("class") || "";
   curClasses = curClasses.split(/[\s\t\r\n ]+/);
   for (i = 0; i < curClasses.length; i++) {
    if (curClasses[i] === classes) {
     return true;
    }
   }
   return false;
  };
  PopcornBaseEvent.prototype.addClass = function(element, classes) {
   var curClasses, i;
   if (!classes || !element || !element.getAttribute) {
    return;
   }
   classes = PopcornBaseEvent.prototype.toArray(classes, /[\s\t\r\n ]+/);
   curClasses = element.getAttribute("class") || "";
   curClasses = curClasses.split(/[\s\t\r\n ]+/);
   for (i = 0; i < classes.length; i++) {
    if (curClasses.indexOf(classes[i]) < 0) {
     curClasses.push(classes[i]);
    }
   }
   element.setAttribute("class", curClasses.join(" "));
  };
  PopcornBaseEvent.prototype.removeClass = function(element, classes) {
   var curClasses, i, index;
   if (!classes || !element || !element.getAttribute) {
    return;
   }
   classes = PopcornBaseEvent.prototype.toArray(classes, /[\s\t\r\n ]+/);
   curClasses = element.getAttribute("class") || "";
   curClasses = curClasses.split(/[\s\t\r\n ]+/);
   for (i = 0; i < classes.length; i++) {
    index = curClasses.indexOf(classes[i]);
    if (index >= 0) {
     curClasses.splice(index, 1);
    }
   }
   element.setAttribute("class", curClasses.join(" "));
  };
 } else {
  PopcornBaseEvent.prototype.hasClass = function(element, classes) {
   var i;
   if (!element || !element.classList) {
    return;
   }
   for (i = 0; i < element.classList.length; i++) {
    if (element.classList[i] === classes) {
     return true;
    }
   }
   return false;
  };
  PopcornBaseEvent.prototype.addClass = function(element, classes) {
   var c, i;
   if (!element || !element.classList) {
    return;
   }
   c = PopcornBaseEvent.prototype.toArray(classes, /[\s\t\r\n ]+/);
   for (i = 0; i < c.length; i++) {
    try {
     element.classList.add(c[i]);
    } catch (e) {}
   }
  };
  PopcornBaseEvent.prototype.removeClass = function(element, classes) {
   var c, i;
   if (!element || !element.classList) {
    return;
   }
   c = PopcornBaseEvent.prototype.toArray(classes, /[\s\t\r\n ]+/);
   for (i = 0; i < c.length; i++) {
    try {
     element.classList.remove(c[i]);
    } catch (e) {}
   }
  };
 }
 PopcornBaseEvent.prototype.nop = function() {};
 Popcorn.basePlugin = function(name, plugin, manifest) {
  var bp = new PopcornBasePlugin(name, plugin, manifest);
 };
 Popcorn.basePlugin.toArray = PopcornBaseEvent.prototype.toArray;
 Popcorn.basePlugin.toObject = PopcornBaseEvent.prototype.toObject;
 Popcorn.basePlugin.addClass = PopcornBaseEvent.prototype.addClass;
 Popcorn.basePlugin.removeClass = PopcornBaseEvent.prototype.removeClass;
 timing = {
  "step-start":function(n) {
   function f(t) {
    return Math.floor(t * n) / n;
   }
   if (n < 1) {
    return timing.linear();
   }
   return f;
  },
  "step-end":function(n) {
   function f(t) {
    return Math.ceil(t * n) / n;
   }
   if (n < 1) {
    return timing.linear();
   }
   return f;
  },
  linear:function() {
   function f(t) {
    return t;
   }
   return f;
  },
  "cubic-bezier":function(p1, p2, p3, p4) {
   var cx, bx, ax, cy, by, ay;
   function bezierX(t) {
    return t * (cx + t * (bx + t * ax));
   }
   function bezierY(t) {
    return t * (cy + t * (by + t * ay));
   }
   function bezierXDeriv(t) {
    return cx + t * (2 * bx + 3 * ax + t);
   }
   function findX(t) {
    var x = t, i = 0, z;
    while (i < 10) {
     z = bezierX(x) - t;
     if (Math.abs(z) < 1e-4) {
      break;
     }
     x = x - z / bezierXDeriv(x);
     i++;
    }
    return x;
   }
   if (isNaN(p1)) {
    p1 = .25;
   }
   if (isNaN(p2)) {
    p2 = .1;
   }
   if (isNaN(p3)) {
    p3 = .25;
   }
   if (isNaN(p4)) {
    p4 = 1;
   }
   p2 = Math.min(Math.max(p2, 0), 1);
   p4 = Math.min(Math.max(p4, 0), 1);
   cx = 3 * p1;
   bx = 3 * (p3 - p1) - cx;
   ax = 1 - cx - bx;
   cy = 3 * p2;
   by = 3 * (p4 - p2) - cy;
   ay = 1 - cy - by;
   return function(t) {
    return bezierY(findX(t));
   };
  },
  ease:function() {
   return timing["cubic-bezier"](.25, .1, .25, 1);
  },
  "ease-in":function() {
   return timing["cubic-bezier"](.42, 0, 1, 1);
  },
  "ease-in-out":function() {
   return timing["cubic-bezier"](.42, 0, .58, 1);
  },
  "ease-out":function() {
   return timing["cubic-bezier"](0, 0, .58, 1);
  },
  "ease-in-power":function(power) {
   function f(t) {
    return Math.pow(t, power);
   }
   if (isNaN(power) || power < 0) {
    return timing.linear();
   }
   return f;
  },
  "ease-in-out-power":function(power) {
   function f(t) {
    if (t < .5) {
     return .5 * Math.pow(t * 2, power);
    }
    return -.5 * (Math.pow(Math.abs(t * 2 - 2), power) - 2);
   }
   if (isNaN(power) || power < 0) {
    return timing.linear();
   }
   return f;
  },
  "ease-out-power":function(power) {
   function f(t) {
    return 1 - Math.pow(Math.abs(t - 1), power);
   }
   if (isNaN(power) || power < 0) {
    return timing.linear();
   }
   return f;
  },
  "ease-in-quad":function() {
   return timing["ease-in-power"](2);
  },
  "ease-in-out-quad":function() {
   return timing["ease-in-out-power"](2);
  },
  "ease-out-quad":function() {
   return timing["ease-out-power"](2);
  },
  "ease-in-cubic":function() {
   return timing["ease-in-power"](3);
  },
  "ease-in-out-cubic":function() {
   return timing["ease-in-out-power"](3);
  },
  "ease-out-cubic":function() {
   return timing["ease-out-power"](3);
  },
  "ease-in-quart":function() {
   return timing["ease-in-power"](4);
  },
  "ease-in-out-quart":function() {
   return timing["ease-in-out-power"](4);
  },
  "ease-out-quart":function() {
   return timing["ease-out-power"](4);
  },
  "ease-in-quint":function() {
   return timing["ease-in-power"](5);
  },
  "ease-in-out-quint":function() {
   return timing["ease-in-out-power"](5);
  },
  "ease-out-quint":function() {
   return timing["ease-out-power"](5);
  },
  "ease-in-sine":function() {
   function f(t) {
    return -Math.cos(t * Math.PI / 2) + 1;
   }
   return f;
  },
  "ease-in-out-sine":function() {
   function f(t) {
    return -.5 * (Math.cos(Math.PI * t) - 1);
   }
   return f;
  },
  "ease-out-sine":function() {
   function f(t) {
    return Math.sin(t * Math.PI / 2);
   }
   return f;
  },
  "ease-in-exp":function() {
   function f(t) {
    return !t ? 0 :Math.pow(2, 10 * (t - 1));
   }
   return f;
  },
  "ease-in-out-exp":function() {
   function f(t) {
    if (!t) {
     return 0;
    }
    if (t === 1) {
     return 1;
    }
    if (t < .5) {
     return .5 * Math.pow(2, 10 * (t * 2 - 1));
    }
    return .5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2);
   }
   return f;
  },
  "ease-out-exp":function() {
   function f(t) {
    return t === 1 ? 1 :-Math.pow(2, -10 * t) + 1;
   }
   return f;
  },
  "ease-in-circ":function() {
   function f(t) {
    return 1 - Math.sqrt(1 - t * t);
   }
   return f;
  },
  "ease-out-circ":function() {
   function f(t) {
    return Math.sqrt(1 - Math.pow(t - 1, 2));
   }
   return f;
  },
  "ease-in-out-circ":function() {
   function f(t) {
    if (t < .5) {
     return -.5 * (Math.sqrt(1 - Math.pow(t * 2, 2)) - 1);
    }
    return .5 * (Math.sqrt(1 - Math.pow(t * 2 - 2, 2)) + 1);
   }
   return f;
  },
  bounce:function(gravity, bounce) {
   var bounces, i, b, diff;
   if (!gravity || gravity <= 0) {
    gravity = 9.8 * 4;
   }
   if (isNaN(bounce) || bounce < 0) {
    bounce = .5625;
   }
   bounces = [ {
    t0:0,
    h:1,
    t:Math.sqrt(2 / gravity),
    x0:0
   } ];
   b = bounces[0];
   for (i = 1, diff = 1; i < 15 && diff > .005; i++) {
    b = {
     t0:b.t,
     h:b.h * bounce,
     t:b.t + 2 * Math.sqrt(2 * bounce * b.h / gravity)
    };
    diff = b.t - b.t0;
    b.x0 = (b.t + b.t0) / 2;
    bounces.push(b);
   }
   return function(t) {
    var i, b, x;
    for (i = 0; i < bounces.length; i++) {
     b = bounces[i];
     if (t < b.t) {
      break;
     }
    }
    if (t > b.t) {
     return 1;
    }
    x = t - b.x0;
    return .5 * gravity * x * x - b.h + 1;
   };
  }
 };
 timing.step = timing["step-start"];
 Popcorn.basePlugin.timing = timing;
})(window, window.Popcorn);

define("popcorn.base", [ "popcorn", "popcorn.compatible" ], function(global) {
 return function() {
  var ret, fn;
  return ret || global.Popcorn.basePlugin;
 };
}(this));

define("popcorn.pop", [ "module", "popcorn", "configuration", "player.playereval", "utils", "utils.samedomain", "popcorn.base" ], function(module, Popcorn, configuration, playereval, utils, sameDomain) {
 var moduleConfig = module.config(), playerConfig = configuration && configuration.player;
 var linkRegex = /(\b((?:https?:\/\/|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?])))|(([0-9]+):([0-9]{2}(\.[0-9]+)?))/gi, protocolRegex = /^https?:\/\//i;
 var events = [], fonts = {}, isHovering = false, localLinks = playerConfig.localLinks || moduleConfig.localLinks || false, MAX_AUDIO_TIME = 2, soundIndex = 0, sounds = {}, webFontRequested = false, webFontPromises = [];
 function requireFont(provider, font, callback) {
  function loadFont() {
   var p, f, loadObj, dummy;
   p = fonts[provider];
   if (!p) {
    p = fonts[provider] = {};
   }
   f = p[font];
   if (!f) {
    f = p[font] = {
     loaded:false,
     queue:[ callback ]
    };
    dummy = document.createElement("span");
    dummy.style.position = "absolute";
    dummy.style.visibility = "hidden";
    dummy.style.fontFamily = font;
    dummy.appendChild(document.createTextNode("loading font " + font + "..."));
    document.body.appendChild(dummy);
    loadObj = {
     fontactive:function() {
      var fn, queue = f.queue;
      f.loaded = true;
      if (dummy && dummy.parentNode) {
       dummy.parentNode.removeChild(dummy);
      }
      dummy = null;
      while (queue.length) {
       fn = queue.shift();
       fn();
      }
     }
    };
    loadObj[provider] = {
     families:[ font + (provider === "google" ? "::latin" :"") ]
    };
    window.WebFont.load(loadObj);
   } else if (f.loaded) {
    callback();
   } else {
    f.queue.push(callback);
   }
  }
  function checkWebFontLoaded() {
   var fn;
   if (window.WebFont) {
    while (webFontPromises.length) {
     fn = webFontPromises.shift();
     fn();
    }
    return;
   }
   setTimeout(checkWebFontLoaded, 20);
  }
  var script;
  if (window.WebFont) {
   loadFont();
   return;
  }
  webFontPromises.push(loadFont);
  if (webFontRequested) {
   return;
  }
  webFontRequested = true;
  script = document.createElement("script");
  script.src = ("https:" === document.location.protocol ? "https" :"http") + "://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js";
  script.async = true;
  document.head.appendChild(script);
  setTimeout(checkWebFontLoaded, 0);
 }
 function drawThought(canvas, lineWidth, isLink, bgColor) {
  var annotation = canvas.parentNode.parentNode, ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!bgColor) {
   ctx.strokeStyle = isLink && isHovering ? "#1892BF" :"#000000";
  } else {
   annotation.style.borderColor = bgColor;
  }
  ctx.save();
  ctx.translate(2, 10);
  ctx.beginPath();
  ctx.moveTo(13.5, 7);
  ctx.bezierCurveTo(13.5, 10.6, 10.6, 13.5, 7, 13.5);
  ctx.bezierCurveTo(3.4, 13.5, .5, 10.6, .5, 7);
  ctx.bezierCurveTo(.5, 3.4, 3.4, .5, 7, .5);
  ctx.bezierCurveTo(10.6, .5, 13.5, 3.4, 13.5, 7);
  ctx.closePath();
  ctx.fillStyle = bgColor || window.getComputedStyle(annotation).backgroundColor;
  ctx.fill();
  if (!bgColor) {
   ctx.lineWidth = lineWidth;
   ctx.stroke();
  }
  ctx.beginPath();
  ctx.moveTo(17.5, 23.8);
  ctx.bezierCurveTo(17.5, 26.1, 15.6, 28, 13.2, 28);
  ctx.bezierCurveTo(10.9, 28, 9, 26.1, 9, 23.8);
  ctx.bezierCurveTo(9, 21.4, 10.9, 19.5, 13.2, 19.5);
  ctx.bezierCurveTo(15.6, 19.5, 17.5, 21.4, 17.5, 23.8);
  ctx.closePath();
  ctx.fill();
  if (!bgColor) {
   ctx.lineWidth = lineWidth;
   ctx.stroke();
  }
  ctx.beginPath();
  ctx.moveTo(27.5, 31.8);
  ctx.bezierCurveTo(27.5, 33.5, 26, 35, 24.2, 35);
  ctx.bezierCurveTo(22.5, 35, 21, 33.5, 21, 31.8);
  ctx.bezierCurveTo(21, 30, 22.5, 28.5, 24.2, 28.5);
  ctx.bezierCurveTo(26, 28.5, 27.5, 30, 27.5, 31.8);
  ctx.closePath();
  ctx.fill();
  if (!bgColor) {
   ctx.lineWidth = lineWidth;
   ctx.stroke();
  }
  ctx.restore();
 }
 function drawSpeech(canvas, lineWidth, isLink, bgColor) {
  var annotation = canvas.parentNode.parentNode, ctx = canvas.getContext("2d");
  if (!bgColor) {
   ctx.strokeStyle = isLink && isHovering ? "#1892BF" :"#000000";
  } else {
   annotation.style.borderColor = bgColor;
   canvas.style.borderTopColor = bgColor;
  }
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.bezierCurveTo(0, 0, 10.8, 26.3, 35, 41.9);
  ctx.bezierCurveTo(35, 41.9, 19.2, 26.3, 23.4, 0);
  ctx.fillStyle = bgColor || window.getComputedStyle(annotation).backgroundColor;
  ctx.fill();
  if (!bgColor) {
   ctx.lineWidth = lineWidth;
   ctx.stroke();
  }
  ctx.restore();
 }
 Popcorn.basePlugin("pop", function(options, base) {
  var popcorn = this, video, target, container, relative, textContainer, audio, canvas, pause, baseWidth, loaded = false, destroyed = false, shortenUrls, validateLink, templateEvaluator = new playereval.TemplateEvaluator(this, options), modes = {
   thought:{
    drawFn:drawThought,
    className:"popcorn-pop-thought"
   },
   speech:{
    drawFn:drawSpeech,
    className:"popcorn-pop-speech"
   },
   outline:{
    className:"popcorn-pop-outline"
   },
   black:{
    className:"hapyak-theme-black"
   },
   white:{
    className:"hapyak-theme-white"
   },
   pop:{
    className:"hapyak-theme-pop"
   }
  };
  function onMouseOver() {
   isHovering = true;
   beforeDraw(modes[options.mode].drawFn, base.hasClass(container, "hapyak-linked"));
  }
  function onMouseOut() {
   isHovering = false;
   beforeDraw(modes[options.mode].drawFn, base.hasClass(container, "hapyak-linked"));
  }
  function setLinkState() {
   if (base.hasClass(container, "hapyak-linked") && [ "speech", "thought" ].indexOf(options.mode) > -1) {
    container.addEventListener("mouseover", onMouseOver, true);
    container.addEventListener("mouseout", onMouseOut, true);
   } else {
    container.removeEventListener("mouseover", onMouseOver, true);
    container.removeEventListener("mouseout", onMouseOut, true);
   }
  }
  function beforeDraw(drawFunc, isLink) {
   if (drawFunc) {
    if (!canvas) {
     canvas = document.createElement("canvas");
     canvas.width = 40;
     canvas.height = 60;
     relative.appendChild(canvas);
    }
    if (options.arrow && options.arrow.indexOf("right") >= 0) {
     base.addClass(canvas.parentNode, "right");
    } else {
     base.removeClass(canvas.parentNode, "right");
    }
    if (options.arrow && options.arrow.indexOf("top") >= 0) {
     base.addClass(canvas.parentNode, "top");
    } else {
     base.removeClass(canvas.parentNode, "top");
    }
    if (options.flipTail) {
     base.addClass(canvas.parentNode, "flip");
    } else {
     base.removeClass(canvas.parentNode, "flip");
    }
    drawFunc(canvas, 2, isLink, options.backgroundColor);
   } else if (canvas) {
    if (canvas.parentNode) {
     canvas.parentNode.removeChild(canvas);
    }
    canvas = null;
   }
  }
  function selectAudio(src) {
   var i, j, event, diff, eligibleAudio, audio;
   function resetAudio() {
    audio.currentTime = 0;
    audio.pause();
   }
   if (!sounds[src]) {
    audio = document.createElement("audio");
    audio.src = src;
    audio.id = "popcorn-pop-sound-" + soundIndex;
    soundIndex++;
    audio.preload = true;
    audio.style.display = "none";
    audio.addEventListener("ended", resetAudio, false);
    document.body.appendChild(audio);
    sounds[src] = [ audio ];
    return audio;
   }
   audio = sounds[src][0];
   if (audio.duration) {
    diff = Math.min(audio.duration, MAX_AUDIO_TIME);
   } else {
    diff = MAX_AUDIO_TIME;
   }
   eligibleAudio = sounds[src].slice(0);
   for (i = 0; i < events.length; i++) {
    event = events[i];
    if (event.sound === options.sound && event.start <= options.start + diff && event.start + diff >= options.start) {
     j = eligibleAudio.indexOf(event.audio);
     if (j >= 0) {
      eligibleAudio.splice(j, 1);
     }
    }
   }
   if (eligibleAudio.length) {
    audio = eligibleAudio[0];
   } else {
    audio = sounds[src][0].cloneNode(true);
    audio.id = "popcorn-pop-sound-" + soundIndex;
    soundIndex++;
    audio.removeEventListener("ended", resetAudio, false);
    audio.addEventListener("ended", resetAudio, false);
    document.body.appendChild(audio);
    sounds[src].push(audio);
   }
   return audio;
  }
  function makeTimeLinkCallback(time) {
   return function(event) {
    event.preventDefault();
    if (time >= 0 && time < popcorn.duration()) {
     popcorn.currentTime(time);
    }
   };
  }
  function pauseMedia() {
   popcorn.media.pause();
  }
  function setText() {
   var i, j, s, text, link, url, urlString;
   text = templateEvaluator.evaluate(options.text);
   text = text.split(/[\n\r]/);
   textContainer.innerHTML = "";
   for (i = 0; i < text.length; i++) {
    if (i) {
     textContainer.appendChild(document.createElement("br"));
    }
    s = text[i];
    j = 0;
    linkRegex.lastIndex = 0;
    url = linkRegex.exec(s);
    while (url) {
     textContainer.appendChild(document.createTextNode(s.substr(j, url.index - j)));
     if (url[1]) {
      if (!protocolRegex.test(url[1])) {
       url[1] = "http://" + url[1];
      }
      if (!validateLink || validateLink(url[1])) {
       link = document.createElement("a");
       link.className = "popcorn-pop-link";
       if (!localLinks || !sameDomain.test(url[1])) {
        link.setAttribute("target", "_blank");
       }
       link.setAttribute("href", url[1]);
       link.setAttribute("data-hapyak-log", true);
       urlString = url[0];
       if (shortenUrls) {
        urlString = urlString.replace(protocolRegex, "");
        if (urlString.length > 20) {
         urlString = urlString.substr(0, 17) + "...";
        }
       }
       link.appendChild(document.createTextNode(urlString));
       link.addEventListener("click", pauseMedia, true);
       textContainer.appendChild(link);
      } else if (textContainer.lastChild.nodeType === 3) {
       textContainer.lastChild.nodeValue += url[0];
      } else {
       textContainer.appendChild(document.createTextNode(url[0]));
      }
     } else if (url[7]) {
      link = document.createElement("a");
      link.setAttribute("href", "#");
      link.appendChild(document.createTextNode(url[0]));
      link.addEventListener("click", makeTimeLinkCallback((parseFloat(url[8]) || 0) * 60 + (parseFloat(url[9]) || 0)), true);
      textContainer.appendChild(link);
     }
     j = linkRegex.lastIndex;
     url = linkRegex.exec(s);
     if (link) {
      link.setAttribute("title", link.href);
     }
     link = null;
    }
    if (j < s.length) {
     textContainer.appendChild(document.createTextNode(s.substr(j)));
    }
   }
  }
  function watchText() {
   if (!popcorn.getData(options.dataId || options.id, "hapyak-editing")) {
    setText();
   }
  }
  function setMode() {
   var mode, drawFn;
   for (mode in modes) {
    if (mode !== options.mode && modes[mode].className) {
     base.removeClass(container, modes[mode].className);
    } else {
     drawFn = modes[mode].drawFn;
     if (modes[mode].className) {
      base.addClass(container, modes[mode].className);
     }
    }
   }
   setLinkState();
   if (options.mode === "outline") {
    if (document.createElement("div").style.webkitTextStroke === "") {
     base.addClass(container, "popcorn-pop-outline-stroke");
    } else if (document.createElement("div").style.textShadow === "") {
     base.addClass(container, "popcorn-pop-outline-shadow");
    } else {
     base.addClass(container, "popcorn-pop-outline-fallback");
    }
   } else {
    base.removeClass(container, "popcorn-pop-outline-stroke");
    base.removeClass(container, "popcorn-pop-outline-shadow");
    base.removeClass(container, "popcorn-pop-outline-fallback");
   }
   beforeDraw(drawFn);
  }
  function setFont() {
   base.addClass(container, "hide");
   requireFont(options.fontProvider || "google", options.fontFamily || "Open Sans", function() {
    if (destroyed) {
     return;
    }
    loaded = true;
    if (container) {
     base.removeClass(container, "hide");
     if (typeof options.onLoad === "function") {
      options.onLoad(options);
     }
     popcorn.emit("resized");
    }
   });
  }
  shortenUrls = popcorn.options && popcorn.options.shortenUrls;
  if (shortenUrls === undefined) {
   shortenUrls = true;
  }
  validateLink = popcorn.options && popcorn.options.validateLink;
  if (!base.target) {
   return {
    _update:function() {}
   };
  }
  if (!options.mode) {
   options.mode = "pop";
  }
  if (!options.text) {
   options.text = "";
  }
  video = popcorn.media;
  target = base.target;
  container = base.makeContainer();
  options.container = container;
  relative = document.createElement("div");
  container.appendChild(relative);
  base.animate();
  baseWidth = options.baseWidth || 800;
  if (options.textContainer) {
   relative.appendChild(options.textContainer);
  } else {
   textContainer = document.createElement("div");
   relative.appendChild(textContainer);
   setText();
  }
  setMode();
  setFont();
  templateEvaluator.watchTemplateVars(options.text, watchText);
  if (options.sound) {
   if (options.sound === true) {
    options.sound = "/sounds/mouthpop.ogg";
   } else if (options.sound instanceof window.HTMLMediaElement) {
    audio = options.sound;
    options.sound = audio.currentSrc;
   }
   if (!audio) {
    audio = selectAudio(options.sound);
    options.audio = audio;
   }
   events.push(options);
  }
  if (options.pause) {
   pause = options.pause;
   if (Popcorn.isArray(pause)) {
    pause = pause[0];
   }
   base.pause(pause === true ? 2 :pause);
  }
  return {
   start:function(event, options) {
    base.addClass(base.container, "active");
    setLinkState();
    if (audio && audio.duration && !video.paused && video.currentTime - 1 < options.start) {
     audio.volume = video.volume;
     audio.muted = video.muted;
     audio.play();
     if (!audio.duration || isNaN(audio.duration) || audio.duration > MAX_AUDIO_TIME) {
      setTimeout(function() {
       audio.currentTime = 0;
       audio.pause();
      }, MAX_AUDIO_TIME);
     }
    }
   },
   end:function() {
    base.removeClass(base.container, "active");
   },
   _update:function(trackEvent, changes) {
    var BASE_WIDTH, width;
    textContainer.innerHTML = "";
    options.text = changes.text || "";
    templateEvaluator.watchTemplateVars(options.text, watchText);
    setText();
    if (changes.pause !== undefined && options.pause !== changes.pause || changes.end !== options.end || changes.start !== options.start) {
     options.pause = changes.pause;
     if (options.pause) {
      base.pause(options.pause === true ? 2 :options.pause);
     } else {
      base.cancelPause();
     }
    }
    if (!trackEvent.width || !/[0-9\.]+px/i.test(trackEvent.width)) {
     BASE_WIDTH = configuration.player.baseWidth || 1200;
     width = utils.measurePopText(trackEvent, BASE_WIDTH);
     options.width = width / BASE_WIDTH * 100 + "%";
     container.style.width = options.width;
    }
    if (changes.hasOwnProperty("mode") && changes.mode !== options.mode || changes.hasOwnProperty("arrow") && options.arrow !== changes.arrow || changes.hasOwnProperty("flipTail") && changes.flipTail !== options.flipTail || changes.hasOwnProperty("backgroundColor") && options.backgroundColor !== changes.backgroundColor) {
     options.mode = changes.mode;
     options.arrow = changes.arrow;
     options.flipTail = changes.flipTail;
     options.backgroundColor = changes.backgroundColor;
     container.style.backgroundColor = options.backgroundColor;
     setMode();
    }
    if (changes.hasOwnProperty("fontFamily") && options.fontFamily !== changes.fontFamily || changes.hasOwnProperty("fontProvider") && options.fontProvider !== changes.fontProvider) {
     options.fontFamily = changes.fontFamily;
     options.fontProvider = changes.fontProvider;
     setFont();
    }
   },
   _teardown:function() {
    var i;
    destroyed = true;
    i = events.indexOf(options);
    if (i >= 0) {
     events.splice(i, 1);
    }
   }
  };
 }, {
  about:{
   name:"Popcorn Pop Plugin",
   version:.2,
   author:"Hapyak",
   website:"http://www.hapyak.com"
  },
  options:{
   start:{
    elem:"input",
    type:"number",
    label:"Start",
    units:"seconds"
   },
   end:{
    elem:"input",
    type:"number",
    label:"End",
    units:"seconds"
   },
   text:{
    elem:"input",
    type:"text",
    label:"Text"
   },
   link:{
    elem:"input",
    type:"url",
    label:"Link URL"
   },
   linkTarget:{
    elem:"input",
    type:"text",
    label:"Link Target"
   }
  }
 });
});

define("player.normalizeonclick", [ "popcorn", "utils", "utils.validatelink" ], function(Popcorn, utils, validateLink, undefined) {
 var protocolRegex = /^(https?:\/\/|mailto:)/i, trackTimeRegex = /^([0-9]+)?(?:#((([0-9]+):)?([0-9]+(?:\.[0-9]+)?)))?$/, cssRegex = /^[\-\w]+$/, varListRegex = utils.regex.onClickVariables, normalize;
 normalize = {
  gotoLink:function(link, trackEvent) {
   var onClick;
   if (!link) {
    onClick = Popcorn.extend({}, trackEvent && trackEvent.onClick);
    onClick.gotoLink = null;
   }
   if (utils.regex.validDomain.test(link.replace(/(?:(mailto|https?):)?\/\//, "")) && validateLink(link)) {
    onClick = Popcorn.extend({}, trackEvent && trackEvent.onClick);
    if (protocolRegex.test(link)) {
     onClick.gotoLink = link;
    } else {
     onClick.gotoLink = "http://" + link;
    }
   }
   utils.regex.validDomain.lastIndex = 0;
   protocolRegex.lastIndex = 0;
   return onClick ? {
    onClick:onClick
   } :false;
  },
  gotoTrack:function(trackTime, trackEvent, callback) {
   var parse, duration, onClick, me = this;
   function evaluateTime() {
    var time = Popcorn.util.toSeconds(parse[2]);
    time = Math.min(duration, time);
    onClick.gotoTrack = (parse[1] || "") + "#" + time;
    return {
     onClick:onClick
    };
   }
   if (!trackTime) {
    onClick = Popcorn.extend({}, trackEvent && trackEvent.onClick);
    onClick.gotoTrack = null;
    return {
     onClick:onClick
    };
   }
   parse = trackTimeRegex.exec(trackTime);
   if (parse) {
    onClick = Popcorn.extend({}, trackEvent && trackEvent.onClick);
    if (!parse[2]) {
     onClick.trackTime = trackTime;
     return {
      onClick:onClick
     };
    }
    duration = me.duration();
    if (duration) {
     return evaluateTime();
    }
    me.on("durationchange", function() {
     duration = me.duration();
     callback(evaluateTime());
    });
    return undefined;
   }
   trackTimeRegex.lastIndex = 0;
   return false;
  },
  addClasses:function(classes, trackEvent) {
   var onClick;
   if (!classes || cssRegex.test(classes)) {
    onClick = Popcorn.extend({}, trackEvent && trackEvent.onClick);
    onClick.addClasses = classes || null;
    return {
     onClick:onClick
    };
   }
   cssRegex.lastIndex = 0;
   return false;
  },
  setVariables:function(expr, trackEvent) {
   var onClick;
   varListRegex.test("");
   if (!expr || varListRegex.test(expr)) {
    onClick = Popcorn.extend({}, trackEvent && trackEvent.onClick);
    onClick.setVariables = expr || null;
    return {
     onClick:onClick
    };
   }
   varListRegex.lastIndex = 0;
   return false;
  },
  onClick:function(onClick, trackEvent, callback) {
   var obj = {}, result;
   if (onClick.gotoLink) {
    result = normalize.gotoLink.call(this, onClick.gotoLink, trackEvent, callback);
    if (result === false) {
     return false;
    }
    obj.gotoLink = result.onClick.gotoLink;
   }
   if (onClick.addClasses) {
    result = normalize.addClasses.call(this, onClick.addClasses, trackEvent, callback);
    if (result === false) {
     return false;
    }
    obj.addClasses = result.onClick.addClasses;
   }
   if (onClick.setVariables) {
    result = normalize.setVariables.call(this, onClick.setVariables, trackEvent, callback);
    if (result === false) {
     return false;
    }
    obj.setVariables = result.onClick.setVariables;
   }
   if (onClick.gotoTrack) {
    result = normalize.gotoTrack.call(this, onClick.gotoTrack, trackEvent, function(result) {
     if (result === false) {
      callback(false);
     } else {
      obj.gotoTrack = result.onClick.gotoTrack;
      callback({
       onClick:obj
      });
     }
    });
    if (result === false) {
     return false;
    }
    if (result !== undefined) {
     obj.gotoTrack = result.onClick.gotoTrack;
     return {
      onClick:obj
     };
    }
   } else {
    return {
     onClick:obj
    };
   }
  }
 };
 return normalize;
});

define("player.normalizetransition", [], function(undefined) {
 var transitionRegex = /^hapyak-transition-(none|fade|pop|slide-up)$/;
 return function(value) {
  if (!value) {
   return "hapyak-transition-none";
  }
  if (transitionRegex.test(value)) {
   return value;
  }
  return false;
 };
});

define("utils.parsecolor", [], function() {
 var rgbaRegex = /^rgba?\(\s*(\d+)(%?)\s*,\s*(\d+)(%?)\s*,\s*(\d+)(%?)\s*(,\s*(\d+(\.\d*)?)\s*)?\)/i, hexRegex = /^#([0-9a-fA-F]{3,6})/, hslaRegex = /^hsla?\(\s*(\d+(?:\.\d*)?)\s*,\s*(\d+)%?\s*,\s*(\d+)%?\s*(?:,\s*(\d+(?:\.\d*)?)\s*)?\)/i, colorRegex = /^[a-zA-Z]+/, colorNames = {
  transparent:{
   r:0,
   g:0,
   b:0,
   a:0
  },
  black:{
   r:0,
   g:0,
   b:0,
   a:1
  },
  red:{
   r:255,
   g:0,
   b:0,
   a:1
  },
  green:{
   r:0,
   g:128,
   b:0,
   a:1
  },
  blue:{
   r:0,
   g:0,
   b:255,
   a:1
  },
  white:{
   r:255,
   g:255,
   b:255,
   a:1
  },
  silver:{
   r:192,
   g:192,
   b:192,
   a:1
  },
  gray:{
   r:128,
   g:128,
   b:128,
   a:1
  },
  maroon:{
   r:128,
   g:0,
   b:0,
   a:1
  },
  purple:{
   r:128,
   g:0,
   b:128,
   a:1
  },
  fuchsia:{
   r:255,
   g:0,
   b:255,
   a:1
  },
  lime:{
   r:0,
   g:255,
   b:0,
   a:1
  },
  olive:{
   r:128,
   g:128,
   b:0,
   a:1
  },
  yellow:{
   r:255,
   g:255,
   b:0,
   a:1
  },
  navy:{
   r:0,
   g:0,
   b:128,
   a:1
  },
  teal:{
   r:0,
   g:128,
   b:128,
   a:1
  },
  aqua:{
   r:0,
   g:255,
   b:255,
   a:1
  },
  orange:{
   r:255,
   g:165,
   b:0,
   a:1
  }
 }, colorElement;
 function hslToRgb(h, s, l, a) {
  function hueToRgb(m1, m2, h) {
   h = h - Math.floor(h);
   if (h < 1 / 6) {
    return m1 + (m2 - m1) * h * 6;
   }
   if (h < 1 / 2) {
    return m2;
   }
   if (h < 2 / 3) {
    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
   }
   return m1;
  }
  var m1, m2;
  if (l < .5) {
   m2 = l * (s + 1);
  } else {
   m2 = l + s - l * s;
  }
  m1 = l * 2 - m2;
  return {
   r:Math.floor(hueToRgb(m1, m2, h + 1 / 3) * 255),
   g:Math.floor(hueToRgb(m1, m2, h) * 255),
   b:Math.floor(hueToRgb(m1, m2, h - 1 / 3) * 255),
   a:a === undefined ? 1 :a
  };
 }
 function parseHex(str) {
  var parsed, color, s;
  parsed = hexRegex.exec(str);
  if (parsed && parsed.length >= 2) {
   s = parsed[1];
   if (s.length < 6) {
    color = {
     r:parseInt(s[0], 16) * 255 / 15,
     g:parseInt(s[1], 16) * 255 / 15,
     b:parseInt(s[2], 16) * 255 / 15,
     a:1
    };
   } else {
    color = {
     r:parseInt(s.substr(0, 2), 16),
     g:parseInt(s.substr(2, 2), 16),
     b:parseInt(s.substr(4, 2), 16),
     a:1
    };
   }
   return color;
  }
  return false;
 }
 function parseRGBA(str) {
  var color, parsed = rgbaRegex.exec(str);
  if (parsed && parsed.length) {
   color = {
    r:Math.round(parseFloat(parsed[1]) * (parsed[2] ? 255 / 100 :1)),
    g:Math.round(parseFloat(parsed[3]) * (parsed[4] ? 255 / 100 :1)),
    b:Math.round(parseFloat(parsed[5]) * (parsed[6] ? 255 / 100 :1))
   };
   if (parsed[8]) {
    color.a = parseFloat(parsed[8]);
   } else {
    color.a = 1;
   }
   return color;
  }
  return false;
 }
 function parseHSLA(str) {
  var h, s, l, a, parsed;
  parsed = hslaRegex.exec(str);
  if (parsed && parsed.length) {
   h = parseFloat(parsed[1]) / 360;
   s = parseFloat(parsed[2]) / 100;
   l = parseFloat(parsed[3]) / 100;
   a = parsed[4] && parseFloat(parsed[4]);
   return hslToRgb(h, s, l, a);
  }
 }
 function parseName(str) {
  var color, computed, bg;
  if (colorRegex.test(str)) {
   str = str.toLowerCase();
   color = colorNames[str];
   if (color) {
    return {
     r:color.r,
     g:color.g,
     b:color.b,
     a:color.a
    };
   }
   if (!colorElement) {
    colorElement = document.createElement("a");
   }
   colorElement.style.backgroundColor = "";
   colorElement.style.backgroundColor = str;
   computed = window.getComputedStyle(colorElement);
   bg = computed.getPropertyValue("background-color") || computed.getPropertyValue("backgroundColor") || colorElement.style.backgroundColor;
   if (bg && bg !== str) {
    colorNames[str] = parseColor(bg);
    return colorNames[str];
   }
  }
  return false;
 }
 function parseColor(str) {
  var color;
  if (!str) {
   return false;
  }
  color = parseHex(str);
  if (color) {
   return color;
  }
  color = parseRGBA(str);
  if (color) {
   return color;
  }
  color = parseHSLA(str);
  if (color) {
   return color;
  }
  color = parseName(str);
  if (color) {
   return color;
  }
  return false;
 }
 return parseColor;
});

define("player.normalizecolor", [ "utils.parsecolor" ], function(parseColor) {
 return function(value) {
  var color = parseColor(value);
  function hexify(channelValue) {
   var hex = Math.round(channelValue).toString(16).toUpperCase();
   if (hex.length === 1) {
    hex = "0" + hex;
   }
   return hex;
  }
  if (!color) {
   return false;
  }
  if (!color.a) {
   return "rgba(0, 0, 0, 0)";
  }
  if (color.a === 1) {
   return "#" + hexify(color.r) + hexify(color.g) + hexify(color.b);
  }
  return "rgba(" + Math.round(color.r) + ", " + Math.round(color.g) + ", " + Math.round(color.b) + ", " + color.a + ")";
 };
});

define("popcorn.profile.pop", [ "utils", "popcorn", "player.normalizeonclick", "player.normalizetransition", "player.normalizecolor", "configuration", "popcorn.pop" ], function(utils, Popcorn, normalizeonclick, normalizeTransition, normalizeColor, configuration) {
 var template = {
  "":"textarea",
  "#":"popText",
  ".":"disabled",
  placeholder:"write pop comment here",
  title:"Any text you enter in the box below will show up as popup comment synchronized to the video."
 }, modeRegex = /^(thought|speech|outline|black|white|pop)$/;
 function PopText() {
  var elements = utils.microTemplate(null, template), editor;
  function onKeyUp(e) {
   if (editor && e.keyCode === 13 && !e.shiftKey && !e.ctrlKey) {
    editor.done();
    elements.popText.blur();
   }
  }
  utils.inputPlaceholder(elements.popText);
  this.width = 150;
  this.id = "popText";
  this.element = elements.popText;
  this.activate = function() {
   elements.popText.addEventListener("keyup", onKeyUp, false);
  };
  this.deactivate = function() {
   elements.popText.removeEventListener("keyup", onKeyUp, false);
  };
  this.editor = function(e) {
   editor = e;
  };
 }
 return {
  id:"pop",
  title:"Text",
  icon:"&#x1F4AC;",
  editor:[ "popcorn.quickedit.pop" ],
  sortIndex:1,
  zIndex:7,
  normalize:{
   "onClick.gotoLink":normalizeonclick.gotoLink,
   "onClick.gotoTrack":normalizeonclick.gotoTrack,
   "onClick.addClasses":normalizeonclick.addClasses,
   "onClick.setVariables":normalizeonclick.setVariables,
   onClick:normalizeonclick.onClick,
   mode:function(value) {
    if (!value) {
     return "";
    }
    if (modeRegex.test(value)) {
     return value;
    }
    return false;
   },
   backgroundColor:normalizeColor,
   "background-color":normalizeColor,
   color:normalizeColor,
   transitionClass:normalizeTransition
  },
  defaults:{
   text:"",
   onLoad:function(trackEvent) {
    var BASE_WIDTH, width;
    if (trackEvent && trackEvent.container) {
     utils.removeClass(trackEvent.container, "hide");
    }
    if (!trackEvent._natives) {
     delete trackEvent.onLoad;
     delete trackEvent.onStart;
     return;
    }
    trackEvent._natives._loaded = true;
    if (trackEvent.text && (!trackEvent.width || !/[0-9\.]+(?:px|%)/i.test(trackEvent.width))) {
     BASE_WIDTH = configuration.player.baseWidth || 1200;
     width = utils.measurePopText(trackEvent, BASE_WIDTH);
     trackEvent.width = width / BASE_WIDTH * 100 + "%";
     trackEvent.container.style.width = trackEvent.width;
    }
   }
  },
  enableAltControls:true,
  altControls:function(editor) {
   return [ new PopText(editor) ];
  },
  filter:function(trackEvent, annotation) {
   var text, wordCount, meta, dim;
   if (!isNaN(trackEvent.start) && !trackEvent._duration && (trackEvent.content || trackEvent.text)) {
    text = trackEvent.content || trackEvent.text;
    wordCount = 0;
    Popcorn.forEach(text.split(/[\n\r\s\t ]+/), function(word) {
     if (word.length > 2) {
      wordCount++;
     }
    });
    if (trackEvent.pause) {
     trackEvent.pause = Math.min(6, Math.max(2, .5 * wordCount));
     trackEvent.end = .5;
    } else if (!trackEvent.end) {
     trackEvent.end = trackEvent.start + Math.min(10, Math.max(3, .5 * wordCount));
    }
   }
   if (trackEvent.content && trackEvent.top) {
    trackEvent.top = parseFloat(trackEvent.top) * 505 / 393;
    if (trackEvent.top) {
     trackEvent.top = trackEvent.top + "%";
    }
   }
   if (!trackEvent.text && trackEvent.content) {
    trackEvent.text = trackEvent.content;
   }
   if (!trackEvent.text) {
    return false;
   }
   delete trackEvent.content;
   delete trackEvent.maxWidth;
   delete trackEvent["max-width"];
   if (trackEvent.mode === "outline" && trackEvent.fontFamily) {
    meta = Popcorn.extend({}, annotation.getCustomProperty("meta"));
    meta.fontFamily = trackEvent.fontFamily;
    annotation.setCustomProperty("meta", meta);
   }
   if (!trackEvent.left) {
    trackEvent.left = Math.random() * 15 + "%";
   } else if (parseFloat(trackEvent.left) < 0) {
    trackEvent.left = "0px";
   }
   if (!trackEvent.top) {
    trackEvent.top = Math.random() * 15 + "%";
   } else if (parseFloat(trackEvent.top) < 0) {
    trackEvent.top = "0px";
   }
   dim = /([\-+]?[0-9]*\.?[0-9]*)px/.exec(trackEvent.width);
   if (dim) {
    trackEvent.width = parseFloat(dim[1]) / 800 * 100 + "%";
   }
  },
  create:function(id, annotation, editor, alt) {
   editor.setting(id, "textInput", alt && alt[0].element);
   if (alt) {
    alt[0].editor(editor);
   }
  }
 };
});

(function(root, factory) {
 if (typeof define === "function" && define.amd) {
  define("popcorn.captions", [ "popcorn", "popcorn.filter", "dao", "utils", "configuration", "popcorn.pop", "popcorn.profile.pop" ], factory);
 } else {
  factory(root.Popcorn);
 }
})(this, function(Popcorn, popcornfilter, dao, utils, configuration, undefined) {
 var ccOptions = {}, validVideoTypes = [ "jplayer", "jwplayer", "mediaelement", "videojs", "wistia" ];
 function isMobile() {
  var userAgent = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(userAgent.substr(0, 4));
 }
 function onCanPlay() {
  var popcorn = this, track, video = ccOptions.video;
  popcorn.off("canplay", onCanPlay);
  if (!video) {
   video = popcorn.media.parentNode.querySelector("video");
  }
  if (video) {
   track = document.createElement("track");
   track.setAttribute("kind", "subtitles");
   track.setAttribute("label", "English subtitles");
   track.setAttribute("srclang", "en");
   track.setAttribute("default", "default");
   track.setAttribute("src", "/api/srt?url=" + options.src + "&format=vtt");
   video.appendChild(track);
  }
 }
 Popcorn.filter("closedcaptions", "closedcaptions", function(name, options, next, node) {
  var popcorn = this, ccInstanceData;
  function loadSubtitles(subtitleData) {
   var branchId = 0;
   if (subtitleData && typeof subtitleData === "object") {
    Popcorn.forEach(subtitleData.data, function(data) {
     next(branchId, Popcorn.extend({
      mode:"black",
      isSubtitle:true,
      onLoad:function(trackEvent) {
       var BASE_WIDTH, container, left, parentNode, top, width;
       container = trackEvent.container;
       parentNode = container.parentNode;
       container.style.position = "absolute";
       if (trackEvent && trackEvent.container) {
        utils.removeClass(trackEvent.container, "hide");
       }
       if (options.popTop) {
        top = options.popTop;
       } else {
        top = (parentNode.offsetHeight / 2 - container.firstChild.offsetHeight / 2) / parentNode.offsetHeight * 100 + 25 + "%";
       }
       container.style.top = trackEvent.top = top;
       if (options.popLeft) {
        left = options.popLeft;
       } else {
        left = (parentNode.offsetWidth / 2 - container.firstChild.offsetWidth / 2) / parentNode.offsetWidth * 100 + "%";
       }
       container.style.left = trackEvent.left = left;
       if (!trackEvent.width) {
        BASE_WIDTH = configuration.player.baseWidth || 1200;
        width = utils.measurePopText(trackEvent, BASE_WIDTH);
        trackEvent.width = width / BASE_WIDTH * 100 + "%";
        container.style.width = trackEvent.width;
       }
       if (!trackEvent._natives) {
        delete trackEvent.onLoad;
        delete trackEvent.onStart;
        return;
       }
       trackEvent._natives._loaded = true;
      }
     }, data), "pop");
     branchId++;
    });
   }
   options.subtitles = node.fakeTrackEvent.subtitles = null;
   ccInstanceData.subtitlesLoaded = true;
  }
  if (ccOptions[popcorn.id]) {
   ccInstanceData = ccOptions[popcorn.id];
  } else {
   ccInstanceData = ccOptions[popcorn.id] = {};
  }
  if (ccInstanceData.captionAnnotationId !== options._id || ccInstanceData.src !== options.src) {
   ccInstanceData.captionAnnotationId = options._id;
   ccInstanceData.subtitlesLoaded = false;
  }
  ccInstanceData.src = options.src;
  if (!ccInstanceData.subtitlesLoaded && options.src) {
   if (!isMobile() || popcorn.media._util && validVideoTypes.indexOf(popcorn.media._util.type) < 0) {
    dao.store.getJSON(null, "/api/srt/", {
     url:options.src
    }, loadSubtitles);
   } else {
    ccInstanceData.video = popcorn.media.parentNode.querySelector("video");
    if (!ccInstanceData.video) {
     popcorn.on("canplay", onCanPlay);
    } else {
     onCanPlay.call(popcorn);
    }
   }
   if (popcorn) {}
  }
  next(options);
 }, false, function() {
  var popcorn = this, instanceOptions = ccOptions[popcorn.id];
  popcorn.off("canplay", onCanPlay);
  instanceOptions.subtitlesLoaded = false;
  instanceOptions.captionAnnotationId = undefined;
  instanceOptions.src = undefined;
  instanceOptions.video = undefined;
 });
});

define("popcorn.skip", [ "utils", "popcorn", "logging" ], function(utils, Popcorn) {
 Popcorn.prototype.next = function() {
  var nextEvent, i, events = this.data.trackEvents.byStart, len = events.length, time = this.currentTime();
  if (!this.duration()) {
   return;
  }
  i = utils.binarySearchByKey(events, "start", time);
  while (i < len) {
   nextEvent = events[i];
   if (nextEvent.start > time) {
    break;
   }
   i++;
  }
  if (!nextEvent || nextEvent.start <= time || nextEvent.start >= this.duration()) {
   return;
  }
  this.currentTime(nextEvent.start + .01);
 };
 Popcorn.prototype.prev = function() {
  var prevEvent, i, events = this.data.trackEvents.byStart, time = this.currentTime();
  if (!this.duration()) {
   return;
  }
  i = utils.binarySearchByKey(events, "start", time);
  if (!i) {
   this.currentTime(.01);
   return;
  }
  prevEvent = events[i];
  prevEvent = !prevEvent._running ? prevEvent :function(prevIndex) {
   var currEvent = prevEvent;
   prevIndex = prevIndex > 0 ? prevIndex :0;
   prevEvent = events[prevIndex];
   while (prevIndex > -1 && currEvent.start === prevEvent.start) {
    currEvent = events[i--];
    prevEvent = events[prevIndex--];
   }
   return prevEvent;
  }(i - 1);
  this.currentTime(Math.max(.01, prevEvent.start));
 };
});

define("hapyak.player", [ "require", "module", "configuration", "player.wrappers", "popcorn", "dao", "model", "logging", "utils", "utils.embed", "utils.uuid", "utils.validatelink", "touch", "environment", "lodash.noconflict", "popcorn.data", "popcorn.classes", "popcorn.onclick", "popcorn.precondition", "popcorn.transitions", "popcorn.captions", "popcorn.compatible", "popcorn.skip", "popcorn.filter", "popcorn.datafilter" ], function(require, module, configuration, wrappers, Popcorn, dao, model, logging, utils, embedUtils, uuid, validateLink, Touch, Environment, _) {
 function isFullscreen(containerIsFullscreen) {
  return document.fullScreen || document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement || containerIsFullscreen;
 }
 function getFullscreenDimensions() {
  var height, width;
  var hyBrowser = hapyak.browser, screen = window.screen;
  if (isIOS || hyBrowser.name === "MSIE" && hyBrowser.version <= 10) {
   height = window.innerHeight;
   width = window.innerWidth;
  } else {
   height = screen.height;
   width = screen.width;
  }
  return {
   width:width,
   height:height
  };
 }
 var document = window.document, moduleConfig = module.config(), playerConfig = configuration.player, debug = moduleConfig.debug || hapyak.debug, pluginsEnabled = configuration.provisioning && configuration.provisioning.annotationTypes || {}, defaultDuration = 3, fullscreenEnabled = hapyak.supports.fullscreen(), isIOS = navigator.userAgent.match(/iP(od|ad|hone)/), auth = hapyak.auth(), uploadAuth = "csrf=" + moduleConfig.csrfToken + (moduleConfig.apiKey ? "&key=" + moduleConfig.apiKey :"") + (auth.partner.groupId ? "&partner_group=" + auth.partner.groupId :"") + (auth.partner.groupToken ? "&partner_group_token=" + auth.partner.groupToken :"") + (auth.partner.userId ? "&partner_user=" + auth.partner.userId :"") + (auth.partner.username ? "&partner_username=" + auth.partner.username :"") + (auth.partner.userToken ? "&partner_user_token=" + auth.partner.userToken :""), addClass = utils.addClass, removeClass = utils.removeClass, instanceOfElement = utils.instanceOfElement, requestAnimationFrame, hiddenProperty, visibilityEvent, oldCurrentTime, currentTimeSeekedTimeout, currentTimeOnSeek, annotationTemplate = [ {
  "#":"annotationContainer",
  ".":"hapyak-annotation-container hapyak-root",
  ">":[ {
   "#":"contentsContainer"
  } ]
 }, {
  "#":"annotationNoscaleContainer",
  ".":"hapyak-annotation-container hapyak-annotation-noscale-container hapyak-root"
 }, {
  "#":"topLeftContainer",
  ".":"hapyak-top-left-container hapyak-root",
  ">":[ {
   "#":"audioNoteContainer"
  }, {
   "#":"drawingEditContainer"
  } ]
 }, {
  "#":"editorContainer",
  ".":"hapyak-editor-container hapyak-root"
 }, {
  "#":"overlayContainer",
  ".":"hapyak-overlay-container hapyak-root"
 } ], rootBoxTemplate = [ {
  "#":"rootBox",
  ".":"hapyak-root-box",
  ">":[ annotationTemplate ]
 } ], controlBarTemplate = {
  "#":"controlBar",
  ".":"hapyak-control-bar hapyak-root",
  ">":[ {
   "":"canvas",
   "#":"timeline",
   height:6
  }, {
   "#":"controls",
   ">":[ {
    "#":"groupStandard",
    ".":"hapyak-group-standard group",
    ">":[ {
     ">":{
      "":"span",
      "#":"playButton",
      ".":"hapyak-play-button ss-icon",
      ">":"&#x25B6;"
     }
    }, {
     "#":"annotationSkipContainer",
     ">":[ {
      "":"span",
      "#":"prevButton",
      ".":"ss-skipback",
      title:"Skip back to previous comment"
     }, {
      "":"span",
      "#":"nextButton",
      ".":"ss-skipforward",
      title:"Skip to next comment"
     } ]
    }, {
     "#":"volumeContainer",
     ">":[ {
      "":"span",
      "#":"volume",
      ".":"hapyak-volume ss-volumehigh"
     }, {
      "#":"volumeSliderContainer",
      ".":"hapyak-volume hapyak-volume-slider-container",
      ">":[ {
       "":"canvas",
       "#":"volumeSlider",
       width:8,
       height:100
      } ]
     } ]
    } ]
   }, {
    "#":"groupCreate",
    ".":"hapyak-group-create group loading",
    ">":[ {
     "#":"editControls",
     ".":"hapyak-edit-controls",
     ">":[ {
      "#":"moreIcon",
      ".":"hapyak-more-icon",
      ">":[ '<div class="ss-icon">&hellip;</div>', {
       "#":"editMoreIcons",
       ".":"hapyak-edit-more-icons dropdown-menu"
      } ]
     }, {
      "#":"modeSwitch",
      ">":[ {
       "#":"hideAnnotations",
       "":"span",
       ">":"hide"
      }, {
       "#":"showAnnotations",
       "":"span",
       ">":"show"
      }, {
       "#":"editAnnotations",
       "":"span",
       ">":"edit",
       style:"display: none;"
      } ]
     } ]
    } ]
   }, {
    "#":"groupInfo",
    ".":"hapyak-group-info hapyak-group",
    ">":[ {
     "":"a",
     "#":"tinyLogo",
     ">":"&nbsp;",
     target:"_blank"
    }, {
     ">":[ {
      "":"span",
      "#":"timeCode",
      ">":"00:00"
     }, {
      "":"div",
      "#":"durationContainer",
      ">":[ {
       "":"span",
       ">":"&nbsp;/&nbsp;"
      }, {
       "":"span",
       "#":"duration",
       ">":"00:00"
      } ]
     } ],
     "#":"timeCodeContainer"
    }, {
     "#":"fullScreen",
     ".":"hapyak-full-screen ss-expand"
    } ]
   } ]
  } ]
 }, playerTemplate = [ {
  "#":"playBox",
  ".":"hapyak-play-box hapyak-root",
  ">":[ {
   "#":"videoContainer"
  }, annotationTemplate, {
   "#":"trackInfo",
   ">":{
    ">":[ {
     "":"img",
     "#":"ownerProfileImage"
    }, {
     "#":"trackInfoClose",
     ".":"ss-delete"
    }, {
     "#":"trackInfoDetails",
     ">":[ {
      ">":[ {
       "#":"ownerName",
       "":"span"
      }, "'s Commentary" ]
     }, {
      "#":"trackTitle"
     }, {
      "#":"trackDescription"
     }, {
      "#":"trackRating"
     }, {
      "#":"trackDetails",
      ">":[ {
       "#":"trackMessage"
      }, {
       "":"button",
       "#":"trackReplayButton",
       style:"display: none;"
      } ]
     } ]
    } ]
   }
  }, {
   "#":"trackCapContent"
  }, {
   "#":"warning"
  } ]
 }, controlBarTemplate ], embedTemplate = [ {
  "#":"playBox",
  ".":"hapyak-play-box hapyak-root",
  ">":[ {
   "#":"videoContainer"
  }, annotationTemplate, {
   "#":"warning"
  } ]
 }, controlBarTemplate ], normalizeMethods = {
  start:function(value, trackEvent, callback) {
   var duration, me = this;
   function evaluate() {
    var originalStart, result = {};
    try {
     result.start = Popcorn.util.toSeconds(value, 30);
    } catch (e) {
     return false;
    }
    result.start = Math.min(result.start, duration);
    result.start = Math.max(result.start, 0);
    if (trackEvent.end > 0) {
     originalStart = parseFloat(trackEvent.start) || 0;
     if (trackEvent.end > trackEvent.start) {
      result._duration = Math.max(trackEvent.end - originalStart, .5);
      result.end = result.start + result._duration;
      if (result.end > duration) {
       result.end = duration;
       result._duration = result.end - result.start;
      }
      return result;
     }
    }
    if (trackEvent._duration > .5) {
     result.end = result.start + result._duration;
     return result;
    }
    result._duration = defaultDuration;
    result.end = result.start + defaultDuration;
   }
   callback = typeof callback === "function" && callback;
   duration = this.duration();
   if (duration) {
    return evaluate();
   }
   if (callback) {
    this.on("durationchange", function() {
     duration = me.duration();
     callback(evaluate());
    });
   }
  },
  end:function(value, trackEvent, callback) {
   var duration, me = this;
   function evaluate() {
    var originalStart, result = {};
    originalStart = parseFloat(trackEvent.start) || 0;
    try {
     result.end = Popcorn.util.toSeconds(value, 30);
    } catch (e) {
     return false;
    }
    if (result.end < originalStart) {
     return false;
    }
    result.start = originalStart;
    result.end = Math.max(originalStart + .5, result.end);
    result.end = Math.min(result.end, duration);
    result._duration = result.end - result.start;
    return result;
   }
   callback = typeof callback === "function" && callback;
   duration = this.duration();
   if (duration) {
    return evaluate();
   }
   if (callback) {
    this.on("durationchange", function() {
     duration = me.duration();
     callback(evaluate());
    });
   }
  },
  pause:function(value, trackEvent) {
   var start, end;
   if (!value && !trackEvent.pause) {
    return {
     pause:false
    };
   }
   start = trackEvent.start || 0;
   if (!value) {
    if (trackEvent._duration > .5) {
     end = start + trackEvent._duration;
    } else {
     end = start + defaultDuration;
    }
    return {
     pause:false,
     start:start,
     end:end
    };
   }
   value = parseFloat(value);
   if (value < 0) {
    return false;
   }
   if (isNaN(value)) {
    value = 2;
   } else {
    value = Math.max(value, .5);
   }
   return {
    pause:value,
    start:start,
    end:start + .5
   };
  }
 }, blacklist = {
  _id:1,
  _natives:1,
  _running:1,
  addClass:1,
  removeClass:1,
  startTimeValue:1,
  startTimeFormat:1,
  durationValue:1,
  durationFormat:1,
  hapyakPlayer:1,
  compose:1,
  effect:1,
  pluginData:1,
  id:1,
  toString:1,
  type:1,
  plugin:1,
  target:1,
  container:1,
  annotationId:1,
  onResize:1
 }, youTubeQualityLevels = {
  small:240,
  medium:360,
  large:480,
  hd720:720,
  hd1080:1080,
  highres:1280
 }, pluginOrder = {}, aTypeAliases = {
  "audio-note":"audio",
  toc:"contents",
  pearsonLearningStudioQuizSubmit:"pearsonlssubmit"
 }, activePlayers = 0, BASE_WIDTH = playerConfig.baseWidth || 1200, MIN_PLAYER_HEIGHT = playerConfig.minHeight || 200, MIN_PLAYER_WIDTH = playerConfig.minWidth || 300, defaultControlBarHeight = playerConfig.controlBarHeight !== null && playerConfig.controlBarHeight >= 0 ? parseInt(playerConfig.controlBarHeight, 10) :59, timeRegex = /^(?:([0-9]+):)?([0-9]+(?:\.[0-9]+)?)$/;
 function die() {
  var args = Array.prototype.slice.call(arguments, 0);
  args.unshift("HapyakPlayer:");
  throw new Error(args.join(" "));
 }
 function safeTry(fn) {
  if (debug) {
   fn();
  } else {
   try {
    fn();
   } catch (e) {
    logging.error(e);
    logging.captureException(e);
   }
  }
 }
 function timeToText(t) {
  var hr, min, sec;
  t = Math.floor(t);
  sec = t % 60;
  min = (t - sec) / 60;
  if (sec < 10) {
   sec = "0" + sec;
  }
  if (min > 59) {
   hr = Math.floor(min / 60);
   min = min % 60;
   if (min < 10) {
    min = "0" + min;
   }
   return hr + ":" + min + ":" + sec;
  }
  if (min < 10) {
   min = "0" + min;
  }
  return min + ":" + sec;
 }
 function setText(element, text) {
  if (element.firstChild) {
   if (element.firstChild.nodeType === 3) {
    element.firstChild.nodeValue = text || "";
    return;
   }
   element.innerHTML = "";
  }
  element.appendChild(document.createTextNode(text || ""));
 }
 function setPrefixedStyle(element, attr, value) {
  var style = element.style, cap = attr.replace(/^[a-z]/, function(match) {
   return match.toUpperCase();
  });
  style["webkit" + cap] = value;
  style["khtml" + cap] = value;
  style["moz" + cap] = value;
  style["ms" + cap] = value;
  style["o" + cap] = value;
  style[attr] = value;
 }
 function captureBackKeys(evt) {
  var code, element, prevent = false;
  if (!evt) {
   evt = window.event;
  }
  code = evt.keyCode || evt.which;
  if (code === 8 || code === 46) {
   element = evt.srcElement || evt.target;
   if (element.isContentEditable || element.tagName === "TEXTAREA" || element.tagName === "INPUT" && [ "PASSWORD", "TEXT", "EMAIL" ].indexOf(element.type.toUpperCase()) > -1) {
    prevent = element.readOnly || element.disabled;
   } else {
    prevent = true;
   }
   if (prevent) {
    evt.preventDefault();
   }
  }
 }
 oldCurrentTime = Popcorn.p.currentTime;
 Popcorn.p.currentTime = function(time) {
  var paused, previousDifference = 1, media = this.media, that = this;
  if (_.isNaN(time) || !_.isNumber(time) || time < 0) {
   return oldCurrentTime.call(this);
  }
  if (media && media._util && media._util.type === "vidyard") {
   oldCurrentTime.call(this, time);
   return;
  }
  if (currentTimeSeekedTimeout) {
   clearTimeout(currentTimeSeekedTimeout);
  }
  if (currentTimeOnSeek) {
   this.off("seeked", currentTimeOnSeek);
  }
  currentTimeOnSeek = function() {
   clearTimeout(currentTimeSeekedTimeout);
   var currentTime = that.currentTime();
   if (currentTime < 1 || currentTime - previousDifference < 1 || currentTime <= time + .25) {
    if (!paused) {
     that.play();
    }
    that.off("seeked", currentTimeOnSeek);
   } else {
    currentTimeSeekedTimeout = setTimeout(function() {
     currentTimeOnSeek();
    }, 1e3);
    oldCurrentTime.call(that, time - previousDifference);
    previousDifference++;
   }
  };
  currentTimeSeekedTimeout = setTimeout(function() {
   currentTimeOnSeek();
  }, 1e3);
  paused = this.paused();
  this.pause();
  this.on("seeked", currentTimeOnSeek);
  oldCurrentTime.call(this, time);
 };
 function HapyakPlayer(container, video, opts) {
  var me = this, wrapper, src, popcorn, duration = 0, source, sourceId, existingVideo = false, playerType, options = opts || {}, lastTimelineTime = -1, shuttlePaused = true, editorLocked = false, annotationsLoaded = true, annotationsToLoad = 0, loadedMetadataFired = false, durationChangeVal = -1, destroyed = false, showAnnotations, playerTooSmall = false, showControls, showNativeControls = options.nativeControls, editMode = false, startEditMode = false, ended = false, volume, pendingCreate = [], showTrackInfoTimeout, editControlsTimeout, sectionsViewed = [ {
   start:0,
   end:0
  } ], currentSection = sectionsViewed[0], currentSectionIndex = 0, accumulatedViewTime = 0, currentViewSection = {
   start:0,
   end:0
  }, targetAnnotation, qualityLevel, warnings = {}, played, playerScale = 1, playerBelowThreshold = false, pageHideTime = document[hiddenProperty] || 0, minPlayerWidth = Math.max(0, parseFloat(options.minWidth)) || MIN_PLAYER_WIDTH, minPlayerHeight = Math.max(0, parseFloat(options.minHeight)) || MIN_PLAYER_HEIGHT, controlBarHeight = options.controlBarHeight !== null && options.controlBarHeight >= 0 ? parseInt(options.controlBarHeight, 10) :embedUtils.controlStyle() || defaultControlBarHeight, hideEndAnnotations = options.hideEndAnnotations === undefined ? playerConfig.hideEndAnnotations :options.hideEndAnnotations, annotationSources = Popcorn.extend(playerConfig.annotationSources || {}, options.annotationSources), queuedAnnotations, queuedAnnotationSources, annotationsWaitingForDuration = [], queuedTrackOpts, queuedPlaying = false, queuedFullscreen = false, queuedEditorCallbacks = [], queuedEditorRequested, profilesPending = 0, environment = new Environment(null, {
   storage:Environment.localStorage,
   autosave:"hapyak-env",
   migrate:true
  }), trackSystemScope = environment, trackScope = environment, scopesByPopcornId = {}, dataChangeTimeout = 0, variablesBackup = {}, elements, ctx, vctx, volumeTouch, timelineTouch, playerWidth, playerHeight, backupWidth, backupHeight, fullscreenContainerBackgroundColorBackup = null, annotationContainerMarginBackup = null, fullscreenContainerPositionBackup = null, fullscreenContainerPaddingBackup = null, containerIsFullscreen = false, preserveFullscreenStyles, fullscreenElement, resizeTimeout, lastResizeTime, autoResize = options.autoResize === undefined ? playerConfig.autoResize :options.autoResize, autoResizeTimer, lastResizeWidth, lastResizeHeight, activeTrack, editor, i, popOutWindow, annotationsById = {}, listeners = {}, emitQueue = [], editorLocks = {}, popcornAnnotations = {}, transientAnnotations = {}, activeTrackEvents = {}, trackStartTimes = {}, popcornEventsByType = {}, popcornIdLookup = {}, popcornDeleteQueue = {}, annotationBacklog = {}, provisionCallbacks = {}, annotationProfiles = {}, annotationEditorsLoaded = {}, editButtons = [], blockSave = {}, markers = {}, alternateControls = {}, remotes = options.remotes;
  options.controls = options.edit ? true :options.controls;
  function addProvisioningClasses(root, container) {
   Popcorn.forEach(root, function(value, key) {
    if (value === true) {
     addClass(container, "hapyak-enable-" + key);
    } else if (typeof value === "object") {
     addProvisioningClasses(value, container);
    }
   });
  }
  function removeProvisioningClasses(root, container) {
   Popcorn.forEach(root, function(value, key) {
    if (value === true) {
     removeClass(container, "hapyak-enable-" + key);
    } else if (typeof value === "object") {
     removeProvisioningClasses(value, container);
    }
   });
  }
  function getScope(popcornId) {
   if (!popcornId) {
    return trackScope;
   }
   return scopesByPopcornId[popcornId] || trackScope.scope("tmp-event-" + popcornId);
  }
  function updateAnnotationDisplay() {
   if (duration && annotationsWaitingForDuration.length > 0) {
    Popcorn.forEach(annotationsWaitingForDuration, function(annotation) {
     loadAnnotation(annotation);
    });
    annotationsWaitingForDuration = [];
   }
   if (!showAnnotations || configuration.provisioning.waitForCanplay && popcorn.readyState() < 3 || ended && hideEndAnnotations && !editMode || playerTooSmall) {
    Popcorn.forEach(Popcorn.registry, function(plugin) {
     popcorn.disable(plugin.name);
    });
   } else {
    Popcorn.forEach(Popcorn.registry, function(plugin) {
     popcorn.enable(plugin.name);
    });
   }
  }
  function drawVolume() {
   var width, height;
   if (!elements.volumeSlider) {
    return;
   }
   width = elements.volumeSlider.width;
   height = elements.volumeSlider.height;
   vctx.strokeStyle = "#bbb";
   vctx.lineWidth = height;
   vctx.clearRect(0, 0, width, height);
   if (volume && !popcorn.muted()) {
    vctx.beginPath();
    vctx.moveTo(width / 2, 100);
    vctx.lineTo(width / 2, (1 - volume) * height);
    vctx.stroke();
   }
  }
  function drawTimeline() {
   var width, height, currentTime, buffered, i, max, start, end;
   function drawProgressLine(end) {
    var from = 0, to = end / duration * width;
    ctx.beginPath();
    ctx.moveTo(from, height / 2);
    ctx.lineTo(to, height / 2);
    ctx.stroke();
   }
   if (destroyed || !showControls) {
    return;
   }
   currentTime = popcorn.currentTime();
   if (lastTimelineTime !== currentTime && duration) {
    lastTimelineTime = currentTime;
    width = elements.timeline.width;
    height = elements.timeline.height;
    ctx.clearRect(0, 0, width, height);
    ctx.lineWidth = height;
    ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
    buffered = popcorn.buffered();
    if (buffered) {
     for (i = 0, max = buffered.length; i < max; i++) {
      start = buffered.start(i);
      end = buffered.end(i);
      if (start > duration || start < 0) {
       start = 0;
      }
      if (end > start) {
       drawProgressLine(end);
      }
     }
    } else {
     drawProgressLine(duration);
    }
    if (currentTime) {
     ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
     drawProgressLine(currentTime);
    }
    elements.timeCode.firstChild.nodeValue = timeToText(currentTime);
    elements.duration.firstChild.nodeValue = timeToText(duration);
   }
   requestAnimationFrame(drawTimeline);
  }
  function mouseShuttle(evt, x) {
   var posx, t, canvas = elements.timeline, parent;
   shuttlePaused = shuttlePaused && popcorn.paused();
   posx = x - canvas.clientLeft - canvas.offsetLeft;
   parent = canvas.offsetParent;
   while (parent && parent.nodeName !== "BODY") {
    posx -= parent.clientLeft + parent.offsetLeft;
    parent = parent.offsetParent;
   }
   t = posx / elements.timeline.offsetWidth;
   if (t >= 0 && t <= 1) {
    t *= duration;
    if (duration) {
     popcorn.currentTime(t);
    }
   }
   popcorn.pause();
   return true;
  }
  function dragVolume(evt, x, y) {
   var posy, canvas = elements.volumeSlider, parent;
   posy = y - canvas.clientTop - canvas.offsetTop;
   parent = canvas.offsetParent;
   while (parent && parent.nodeName !== "BODY") {
    posy -= parent.clientTop + parent.offsetTop;
    parent = parent.offsetParent;
   }
   volume = Math.min(Math.max(0, posy / canvas.offsetHeight), 1);
   popcorn.volume(1 - volume);
   if (volume && popcorn.muted()) {
    popcorn.muted(false);
   }
   return true;
  }
  function emit(hook, async) {
   var args = Array.prototype.slice.call(arguments, 2);
   function syncEmit() {
    var list = listeners[hook];
    if (!list) {
     return;
    }
    Popcorn.forEach(list, function(callback) {
     callback.apply(this, args);
    });
   }
   function asyncEmit() {
    if (!emitQueue.length) {
     setTimeout(function() {
      while (emitQueue.length) {
       emitQueue.shift()();
      }
     }, 0);
    }
    emitQueue.push(syncEmit);
   }
   if (!hook) {
    return;
   }
   if (async) {
    asyncEmit();
   } else {
    syncEmit();
   }
  }
  function controlPadding(name) {
   var style = elements[name] && window.getComputedStyle(elements[name]), value = 0;
   if (style) {
    value += Math.round(parseFloat(style.getPropertyValue("padding-left")) || 0);
    value += Math.round(parseFloat(style.getPropertyValue("padding-right")) || 0);
    value += Math.round(parseFloat(style.getPropertyValue("border-left-width")) || 0);
    value += Math.round(parseFloat(style.getPropertyValue("border-right-width")) || 0);
   }
   return value;
  }
  function controlWidth(name) {
   var style = elements[name] && window.getComputedStyle(elements[name]), value = 0;
   if (style) {
    value = Math.round(parseFloat(style.getPropertyValue("width")) || 0);
   }
   return value;
  }
  function resizeControls() {
   var i = 0, len = editButtons.length - 1, showMore = false;
   var alt, element, obj, targetWidth, w, width;
   function showHideAltControl(control) {
    if (!alt && control.width + width <= targetWidth) {
     alt = control;
     control.element.style.display = "";
    } else {
     control.element.style.display = "none";
    }
   }
   if (!showControls || !elements.controlBar) {
    return;
   }
   elements.controls.style.display = "";
   elements.timeline.width = elements.timeline.offsetWidth;
   targetWidth = controlWidth("controlBar");
   width = controlPadding("controls") + controlPadding("groupCreate") + controlPadding("editControls") + controlWidth("groupStandard") + controlWidth("groupInfo") + 10;
   if ([ "play", "viewer" ].indexOf(showControls) > -1) {
    elements.groupCreate.style.display = "none";
    return;
   }
   elements.groupCreate.style.display = "";
   elements.moreIcon.style.display = "";
   width += controlWidth("modeSwitch") + controlWidth("moreIcon");
   if (width > targetWidth) {
    elements.groupCreate.style.display = "none";
    return;
   }
   while (i <= len) {
    obj = editButtons[i];
    element = elements[obj.id];
    if (element) {
     alt = null;
     if (alternateControls[obj.alt]) {
      Popcorn.forEach(alternateControls[obj.alt], showHideAltControl);
     }
     if (alt) {
      element.style.display = "none";
      element = alt.element;
     } else {
      element.style.display = "";
     }
     elements.editControls.insertBefore(element, elements.moreIcon);
     w = alt ? alt.width :controlWidth(obj.id);
     if (width + w <= targetWidth) {
      width += w;
     } else {
      break;
     }
    }
    i++;
   }
   if (i < len) {
    len++;
    while (i < len) {
     obj = editButtons[i];
     element = elements[obj.id];
     if (element) {
      elements.editMoreIcons.appendChild(element);
      showMore = true;
     }
     i++;
    }
   } else if (i < editButtons.length) {
    obj = editButtons[i];
    element = elements[obj.id];
    if (element) {
     elements.editControls.insertBefore(element, elements.moreIcon);
    }
   }
   if (!showMore) {
    elements.moreIcon.style.display = "none";
   }
  }
  function visibilityChange() {
   var hidden = document[hiddenProperty], diff, i;
   if (hidden) {
    if (!pageHideTime) {
     pageHideTime = Date.now();
    }
   } else {
    if (pageHideTime) {
     diff = Date.now() - pageHideTime;
     for (i in trackStartTimes) {
      if (trackStartTimes.hasOwnProperty(i) && trackStartTimes[i]) {
       trackStartTimes[i] += diff;
      }
     }
    }
    pageHideTime = 0;
   }
  }
  function orientationChange(event) {
   if (!containerIsFullscreen) {
    return;
   }
   fullScreenChange(null, true);
  }
  function resize(width, height, sync) {
   function resizePlayer() {
    var width, height, maxWidth = options.maxWidth || Infinity, maxHeight = options.maxHeight || Infinity, aspectRatio, canChange = !existingVideo, qualityHeight, heightDifference, wrapperPluginHeight, newQualityHeight = 0;
    if (!wrapper) {
     return;
    }
    wrapperPluginHeight = showControls === "play" && wrapper.pluginData ? wrapper.pluginData.height :0;
    try {
     if (window.innerWidth === 0 && window.parent) {
      window.innerWidth = window.parent.innerWidth;
      window.innerHeight = window.parent.innerHeight;
     }
    } catch (e) {}
    aspectRatio = me.aspectRatio();
    if (!canChange) {
     playerHeight = wrapper.offsetHeight || wrapper.height || wrapper.videoHeight;
     playerWidth = wrapper.offsetWidth || wrapper.width || wrapper.videoWidth;
     if (!(isFullscreen() || options.embed) && (!playerHeight || !playerWidth)) {
      return;
     }
    }
    if (playerHeight > 0) {
     height = playerHeight;
     width = playerWidth > 0 ? playerWidth :container.offsetWidth || height * aspectRatio;
    } else {
     width = playerWidth > 0 ? playerWidth :container.offsetWidth || 640;
     height = width / aspectRatio;
    }
    width = Math.round(width);
    height = Math.round(height);
    if (isFullscreen() || options.embed) {
     maxWidth = window.innerWidth;
     maxHeight = showControls ? window.innerHeight - controlBarHeight :window.innerHeight;
    } else {
     maxWidth = Math.min(maxWidth, width);
     maxHeight = Math.min(maxHeight - (showControls ? controlBarHeight :0), height);
     if (canChange) {
      container.style.width = Math.round(maxWidth) + "px";
     }
    }
    if (width / maxWidth > height / maxHeight) {
     height = Math.round(maxWidth * height / width);
     width = maxWidth;
     if (showControls && showControls !== "viewer" && fullscreenElement) {
      heightDifference = window.innerHeight - (height + (showControls ? controlBarHeight :0));
      fullscreenElement.style.padding = heightDifference / 2 + "px 0px";
     }
    } else {
     width = Math.round(maxHeight * width / height);
     height = maxHeight;
    }
    if (width === lastResizeWidth && height + wrapperPluginHeight === lastResizeHeight) {
     return;
    } else {
     lastResizeWidth = width;
     lastResizeHeight = height;
    }
    if (canChange) {
     wrapper.width = width;
     wrapper.height = height;
    }
    if (elements.playBox) {
     elements.playBox.style.width = width + "px";
     elements.playBox.style.height = height + wrapperPluginHeight + "px";
    }
    if (isIOS && !isFullscreen(containerIsFullscreen) && options.controls === "viewer") {
     container.style.width = width + "px";
     container.style.height = height + wrapperPluginHeight + "px";
    }
    playerScale = width / BASE_WIDTH;
    elements.annotationContainer.style.width = BASE_WIDTH + "px";
    elements.annotationContainer.style.height = BASE_WIDTH * height / width + "px";
    elements.annotationNoscaleContainer.style.width = width + "px";
    elements.annotationNoscaleContainer.style.height = height + "px";
    if (embedUtils.dotget(wrapper, "_utils.resize")) {
     wrapper._utils.resize(elements, playerScale, options);
    }
    setPrefixedStyle(elements.annotationContainer, "transform", "scale(" + playerScale + ")");
    Popcorn.forEach(elements.annotationContainer.querySelectorAll(".popcorn-quickedit-edit"), function(e) {
     setPrefixedStyle(e, "transform", "scale(" + 1 / playerScale + ")");
    });
    if (video.get("source") === "youtube") {
     qualityHeight = youTubeQualityLevels[qualityLevel] || 0;
     if (!qualityLevel || qualityHeight !== height) {
      Popcorn.forEach(youTubeQualityLevels, function(h, level) {
       if (h <= height && h > newQualityHeight && h > qualityHeight) {
        newQualityHeight = h;
        qualityLevel = level;
       }
      });
     }
    }
    resizeControls();
    if (width < minPlayerWidth || height < minPlayerHeight) {
     playerTooSmall = true;
     if (!playerBelowThreshold) {
      logging.log("Player size (" + width + " x " + height + ") is too small to show annotations. Minimum size is " + minPlayerWidth + " x " + minPlayerHeight);
      playerBelowThreshold = true;
     }
    } else {
     playerTooSmall = false;
     if (playerBelowThreshold) {
      logging.log("Player is big enough. Resuming annotations.");
      playerBelowThreshold = false;
     }
    }
    updateAnnotationDisplay();
    if (editor) {
     editor.resize();
    }
    popcorn.emit("resized");
    emit("resized", true, {
     width:me.width(),
     height:me.height(),
     videoWidth:me.videoWidth(),
     videoHeight:me.videoHeight()
    });
    lastResizeTime = Date.now();
    clearTimeout(resizeTimeout);
   }
   if (width && typeof width !== "object") {
    width = parseFloat(width);
    playerWidth = width > 0 ? width :false;
    height = parseFloat(height);
    playerHeight = height > 0 ? height :false;
   }
   if (sync || !lastResizeTime || Date.now() - lastResizeTime > 100) {
    resizePlayer();
    return;
   }
   clearTimeout(resizeTimeout);
   resizeTimeout = setTimeout(resizePlayer, 100);
  }
  function fullScreenChange(evt, force) {
   var aspectRatio = me.aspectRatio().toFixed(2), dimensions, heightDifference, widthDifference;
   function fullscreenAspectRatio() {
    return (dimensions.width / (controlBarHeight ? dimensions.height - controlBarHeight :dimensions.height)).toFixed(2);
   }
   controlBarHeight = isIOS ? 0 :controlBarHeight;
   fullscreenElement = fullscreenElement || document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || container;
   if (force || isFullscreen()) {
    dimensions = getFullscreenDimensions();
    if (!backupWidth) {
     backupWidth = fullscreenElement.style.width || fullscreenElement.offsetWidth || "";
     backupHeight = fullscreenElement.style.height || fullscreenElement.offsetHeight || "";
    }
    if (annotationContainerMarginBackup === null) {
     annotationContainerMarginBackup = elements.annotationContainer.style.margin || "";
    }
    if (fullscreenContainerPositionBackup === null) {
     fullscreenContainerPositionBackup = fullscreenElement.style.position || "";
    }
    if (fullscreenContainerPaddingBackup === null) {
     fullscreenContainerPaddingBackup = fullscreenElement.style.padding || "";
    }
    if (fullscreenContainerBackgroundColorBackup === null) {
     fullscreenContainerBackgroundColorBackup = fullscreenElement.style.backgroundColor || "";
    }
    if (!containerIsFullscreen) {
     containerIsFullscreen = true;
     addClass(container, "fullscreen");
     addClass(document.body, "hapyak-fullscreen");
     if (elements.fullScreen) {
      addClass(elements.fullScreen, "ss-contract");
      removeClass(elements.fullScreen, "ss-expand");
     }
     fullscreenElement.style.width = "100%";
     fullscreenElement.style.height = "100%";
     fullscreenElement.style.backgroundColor = "black";
     if (isIOS) {
      fullscreenElement.style.position = "fixed";
     }
     resize();
    }
    if ((!showControls || showControls === "viewer") && dimensions && fullscreenAspectRatio() !== aspectRatio && !preserveFullscreenStyles) {
     widthDifference = Math.abs(((dimensions.height - controlBarHeight) * aspectRatio - dimensions.width) / 2);
     heightDifference = Math.abs((dimensions.height - dimensions.width / aspectRatio) / 2);
     if (+fullscreenAspectRatio() < +aspectRatio) {
      widthDifference = 0;
     } else {
      heightDifference = 0;
     }
     if (showControls === "viewer" && popcorn && popcorn.media) {
      popcorn.media.width = dimensions.width - widthDifference * 2;
      popcorn.media.height = dimensions.height - controlBarHeight - heightDifference * 2;
     }
     elements.annotationContainer.style.margin = elements.annotationNoscaleContainer.style.margin = heightDifference + "px " + widthDifference + "px";
     if (embedUtils.dotget(popcorn, "media._util.fullscreenChange")) {
      popcorn.media._util.fullscreenChange(elements.annotationContainer.style.margin);
     }
    }
   } else if (containerIsFullscreen) {
    removeClass(container, "fullscreen");
    removeClass(document.body, "hapyak-fullscreen");
    if (elements.fullScreen) {
     removeClass(elements.fullScreen, "ss-contract");
     addClass(elements.fullScreen, "ss-expand");
    }
    if (annotationContainerMarginBackup !== null) {
     elements.annotationContainer.style.margin = elements.annotationNoscaleContainer.style.margin = annotationContainerMarginBackup;
     annotationContainerMarginBackup = null;
    }
    if (fullscreenContainerPaddingBackup !== null) {
     fullscreenElement.style.padding = fullscreenContainerPaddingBackup;
     fullscreenContainerPaddingBackup = null;
    }
    if (fullscreenContainerPositionBackup !== null) {
     fullscreenElement.style.position = fullscreenContainerPositionBackup;
     fullscreenContainerPositionBackup = null;
    }
    if (fullscreenContainerBackgroundColorBackup !== null) {
     fullscreenElement.style.backgroundColor = fullscreenContainerBackgroundColorBackup;
     fullscreenContainerBackgroundColorBackup = null;
    }
    if (embedUtils.dotget(popcorn, "media._util.fullscreenChange")) {
     popcorn.media._util.fullscreenChange(elements.annotationContainer.style.margin);
    }
    if (backupWidth !== null) {
     fullscreenElement.style.width = backupWidth;
     fullscreenElement.style.height = backupHeight;
     if (showControls === "viewer" && popcorn && popcorn.media) {
      popcorn.media.width = fullscreenElement.offsetWidth;
      popcorn.media.height = fullscreenElement.offsetHeight - controlBarHeight;
     }
     backupWidth = backupHeight = null;
    }
    containerIsFullscreen = false;
    fullscreenElement = null;
   }
   resize();
  }
  function removeTrackEvents() {
   Popcorn.forEach(popcornAnnotations, function(annotation, id) {
    var trackEvent;
    if (markers[id]) {
     elements.controlBar.removeChild(markers[id]);
     delete markers[id];
    }
    delete popcornAnnotations[id];
    popcorn.removeTrackEvent(id);
   });
  }
  function unloadTrack() {
   if (!activeTrack) {
    return;
   }
   queuedAnnotations = null;
   queuedAnnotationSources = null;
   queuedTrackOpts = null;
   logging.debug("player: unloading track #" + activeTrack.get("id"));
   if (editor) {
    editor.done();
   }
   Popcorn.forEach(annotationBacklog, function(obj, key) {
    annotationBacklog[key].splice(0);
   });
   removeTrackEvents();
   activeTrack = null;
   annotationsToLoad = 0;
   if (elements && !destroyed) {
    if (elements.editAnnotations) {
     elements.editAnnotations.style.display = "none";
     resizeControls();
    }
    updateTrackInfo();
   }
   trackScope.unobserve(trackDataObserver);
   trackSystemScope = environment;
   trackScope = environment;
  }
  function lockEditor(name) {
   editorLocks[name || ""] = true;
   if (editorLocked || !elements || !elements.controlBar) {
    return;
   }
   editButtons.forEach(function(e) {
    var element = elements[e.id];
    if (element) {
     addClass(element, "disabled");
     element.disabled = true;
    }
   });
   addClass(elements.moreIcon, "disabled");
   addClass(elements.modeSwitch, "disabled");
   editorLocked = true;
  }
  function unlockEditor(name) {
   var key;
   delete editorLocks[name || ""];
   if (!editorLocked || !elements || !elements.controlBar) {
    return;
   }
   for (key in editorLocks) {
    if (editorLocks.hasOwnProperty(key) && editorLocks[key]) {
     return;
    }
   }
   editButtons.forEach(function(e) {
    var element = elements[e.id];
    if (element) {
     removeClass(element, "disabled");
     element.disabled = false;
    }
   });
   removeClass(elements.moreIcon, "disabled");
   removeClass(elements.modeSwitch, "disabled");
   editorLocked = false;
  }
  function updateMarkers(id) {
   function updateMarker(id) {
    var marker = markers[id], trackEvent = popcorn.getTrackEvent(id);
    if (!marker) {
     marker = document.createElement("div");
     marker.className = "hapyak-marker marker-" + embedUtils.dotget(trackEvent, "_natives.type");
     markers[id] = marker;
     elements.controlBar.appendChild(marker);
    }
    marker.style.left = 100 * trackEvent.start / duration + "%";
   }
   var i;
   if (duration && elements.controlBar) {
    if (id) {
     updateMarker(id);
     return;
    }
    for (i in popcornAnnotations) {
     if (popcornAnnotations.hasOwnProperty(i)) {
      updateMarker(i);
     }
    }
   }
  }
  function createButtonClick(profile, options, callback) {
   var plugin, id, cb, commit, count = 0, events, defaults;
   if (editorLocked) {
    return;
   }
   popcorn.pause();
   if (!me.editMode(true)) {
    emit("requestCreateTrack");
    return;
   }
   plugin = profile.plugin || profile.id;
   if (profile.maxAllowed && (events = popcornEventsByType[plugin])) {
    for (id in events) {
     if (events.hasOwnProperty(id)) {
      count++;
      if (count >= profile.maxAllowed) {
       return;
      }
     }
    }
   }
   if (typeof options === "function") {
    callback = options;
    options = null;
   }
   if (!annotationEditorsLoaded[profile.id]) {
    pendingCreate.push([ profile, options, callback ]);
    return;
   }
   defaults = {};
   if (profile.defaults) {
    for (id in profile.defaults) {
     if (profile.defaults.hasOwnProperty(id)) {
      if (typeof profile.defaults[id] === "function" && !utils.startsWith.call(id, "on")) {
       defaults[id] = profile.defaults[id].call(null, video, popcorn, defaults, elements);
      } else {
       defaults[id] = profile.defaults[id];
      }
     }
    }
   }
   Popcorn.extend(defaults, options);
   if (typeof callback === "function") {
    cb = function(id, annotation, editor, altControl) {
     if (profile.create) {
      profile.create(id, annotation, editor, altControl);
     }
     callback(id, annotation);
    };
    commit = true;
   } else {
    cb = profile.create;
    commit = profile.commit;
   }
   createAnnotation(plugin, defaults, cb, commit, profile.id);
  }
  function editButtonsSort(a, b) {
   return a.index - b.index;
  }
  function setUpAltControl(profile) {
   var id = profile.id, alt;
   if (profile.altControls && !alternateControls[id]) {
    alt = profile.altControls();
    alternateControls[id] = alt;
    Popcorn.forEach(alt, function(control) {
     var deactivate = control.deactivate, activate = control.activate;
     function focus() {
      var editing, trackEvent, plugin;
      if (editor) {
       editing = editor.editing();
       for (i = 0; i < editing.length; i++) {
        trackEvent = editing[i];
        plugin = trackEvent._natives && trackEvent._natives.type || trackEvent.plugin;
        if (plugin === profile.plugin) {
         return;
        }
       }
      }
      createButtonClick(profile);
      control.element.focus();
     }
     editButtons.push({
      index:profile.sortIndex,
      id:control.id
     });
     control.activate = function() {
      activate.call(this);
      control.element.removeEventListener("focus", focus, false);
     };
     control.deactivate = function() {
      deactivate.call(this);
      control.element.addEventListener("focus", focus, false);
     };
     control.deactivate();
    });
    editButtons.sort(editButtonsSort);
   }
   if (editor) {
    Popcorn.forEach(alternateControls[id], function(control) {
     control.editor(editor);
    });
   }
  }
  function doneLoadingAnnotations() {
   trackSystemScope.set("annotationsLoaded", true, true);
   annotationsLoaded = true;
   popcorn.emit("annotationsloaded");
   emit("annotationsloaded");
   updateMarkers();
   emit("changeTrack", false, activeTrack);
  }
  function canEditAnnotation(annotation) {
   return annotation.hasPermission("edit") && annotation.get("track.id") === activeTrack.get("id");
  }
  function setUpAnnotationId(popcornId, annotation) {
   var annotationId = annotation.id || annotation.get("id"), scope;
   if (scopesByPopcornId[popcornId]) {
    if (annotationsById[annotationId] && popcornIdLookup[annotationId]) {
     return;
    }
    scope = scopesByPopcornId[popcornId];
   } else {
    scope = trackScope.scope("tmp-event-" + popcornId, null, true);
   }
   if (scope) {
    scope.rename("event-" + annotationId);
   } else {
    environment.load("hapyak-env", trackSystemScope.name() + "/" + trackScope.name() + "/event-" + annotationId);
    scope = trackScope.scope("event-" + annotationId);
   }
   trackSystemScope.set("annotationIds." + annotationId, true, true);
   scopesByPopcornId[popcornId] = scope;
   annotationsById[annotationId] = annotation;
   popcornIdLookup[annotationId] = popcornId;
  }
  function getAnnotationTimeInSeconds(annotation, field) {
   var time = annotation.get(field), format = annotation.get(field + "_format"), percentageTime;
   if (format === "percent") {
    if (time && duration) {
     percentageTime = duration * (Math.abs(time) / 100);
     if (time < 0) {
      return duration - percentageTime;
     } else {
      return percentageTime;
     }
    }
    return 0;
   } else if (time < 0) {
    return duration ? duration + time :0;
   } else {
    return time;
   }
  }
  function setUpAnnotation(profile, annotation) {
   var aType = annotation.get("type"), annotationId, id, plugin = profile.plugin || aType, trackEvent, videoDuration;
   if (!duration) {
    if (annotation.get("start_time_format") === "percent" && annotation.get("start_time") > 0) {
     annotationsWaitingForDuration.push(annotation);
     return;
    }
    if (annotation.get("duration_format") === "percent") {
     annotationsWaitingForDuration.push(annotation);
     return;
    }
   }
   aType = aTypeAliases[aType] || aType;
   if (!Popcorn.registryByName[plugin] && !Popcorn.filterRoutes[plugin]) {
    logging.warn("Cannot load annotation. Unknown type: " + plugin);
   } else {
    trackEvent = Popcorn.extend({}, annotation.getCustomProperty("popcorn") || annotation.get("properties") || {});
    trackEvent.start = getAnnotationTimeInSeconds(annotation, "start_time");
    if (Math.abs(trackEvent.start - duration) < .5) {
     trackEvent.start = duration - .5;
    }
    trackEvent.startTimeValue = annotation.get("start_time");
    trackEvent.startTimeFormat = annotation.get("start_time_format");
    trackEvent._duration = getAnnotationTimeInSeconds(annotation, "duration");
    trackEvent.durationValue = annotation.get("duration");
    trackEvent.durationFormat = annotation.get("duration_format");
    if (profile.filter && profile.filter(trackEvent, annotation) === false) {
     logging.log("Empty or invalid event " + annotation.get("id"));
    } else {
     annotationId = annotation.id || annotation.get("id");
     trackEvent.annotationId = annotationId;
     if (trackEvent._duration) {
      trackEvent.end = trackEvent.start + trackEvent._duration;
     }
     if (trackEvent.pause) {
      trackEvent.end = trackEvent.start + .5;
     }
     if (!trackEvent.end || trackEvent.end < trackEvent.start) {
      trackEvent.end = trackEvent.start + defaultDuration;
     }
     videoDuration = video.get("duration");
     if (_.isFinite(videoDuration) && videoDuration > 0) {
      trackEvent.start = Math.min(trackEvent.start, videoDuration);
      trackEvent.end = Math.min(trackEvent.end, videoDuration);
     }
     if (trackEvent.noscale) {
      trackEvent.dragContainer = trackEvent.editorContainer = trackEvent.target = trackEvent.topContainer = elements.annotationNoscaleContainer;
     }
     id = Popcorn.guid(plugin);
     popcornAnnotations[id] = annotation;
     setUpAnnotationId(id, annotation);
     popcorn[plugin](id, trackEvent);
     if (id !== popcorn.getLastTrackEventId()) {
      logging.warn("Error loading annotation " + annotation.get("id"), trackEvent);
      delete popcornAnnotations[id];
      delete annotationsById[annotationId];
      return;
     }
     if (editor && profile.create) {
      profile.create(id, annotation, editor, alternateControls[profile.id]);
     }
     if (editor && (!window.HapyakApp || !canEditAnnotation(annotation))) {
      editor.disable(id);
     }
     setDebugAttributes(popcorn.getTrackEvent(id), annotation);
    }
   }
   annotationsToLoad--;
   if (!annotationsToLoad) {
    doneLoadingAnnotations();
   }
  }
  function provisionAnnotationEditor(aType) {
   var profile;
   aType = aTypeAliases[aType] || aType;
   profile = annotationProfiles[aType];
   if (!profile) {
    provisionAnnotationType(aType);
    return;
   }
   if (editor && !annotationEditorsLoaded.hasOwnProperty(aType)) {
    annotationEditorsLoaded[aType] = false;
    require(profile.editor, function() {
     var i = 0, pending;
     annotationEditorsLoaded[aType] = true;
     while (i < pendingCreate.length) {
      pending = pendingCreate[i];
      if (pending[0] === profile) {
       if (popcorn.paused()) {
        createButtonClick.apply(me, pending);
       }
       pendingCreate.splice(i, 1);
      } else {
       i++;
      }
     }
    }, function(err) {
     delete annotationEditorsLoaded[aType];
     logging.warn("Failed to load editor", err);
     logging.captureException(err);
    });
   }
  }
  function provisionAnnotationType(aType, callback) {
   var profileName, dependencies;
   function doneLoading() {
    profilesPending--;
    if (!profilesPending) {
     updateAnnotationDisplay();
     if (elements.editControls && showControls === "edit") {
      removeClass(elements.groupCreate, "loading");
      resizeControls();
     }
     emit("setupannotations");
    }
   }
   aType = aTypeAliases[aType] || aType;
   profileName = "popcorn.profile." + aType;
   if (annotationProfiles.hasOwnProperty(aType)) {
    if (callback) {
     if (annotationProfiles[aType]) {
      callback();
     } else {
      if (!provisionCallbacks[aType]) {
       provisionCallbacks[aType] = [];
      }
      provisionCallbacks[aType].push(callback);
     }
    }
    return;
   }
   dependencies = [ profileName ];
   if (playerConfig.pluginDependencies && Popcorn.isArray(playerConfig.pluginDependencies[aType])) {
    dependencies.push.apply(dependencies, playerConfig.pluginDependencies[aType]);
   }
   annotationProfiles[aType] = false;
   profilesPending++;
   require(dependencies, function(profile) {
    var annotation, backlog = annotationBacklog[aType], buttonElements, compatible, id, plugin, defaults, callbacks;
    if (!annotationProfiles[aType]) {
     if (typeof profile === "function") {
      profile = profile({
       uploadAuth:uploadAuth,
       rootUrl:moduleConfig.rootUrl
      });
     }
     Popcorn.forEach(playerConfig.profiles && playerConfig.profiles[aType], function(val, key) {
      if (typeof profile[key] !== "function") {
       profile[key] = val;
      }
     });
     id = profile.id;
     plugin = profile.plugin || id;
     annotationProfiles[aType] = profile;
     compatible = !Popcorn.incompatible(plugin);
     if (compatible) {
      if (!profile.defaults) {
       profile.defaults = {};
      }
      if (playerConfig.defaults && playerConfig.defaults[plugin]) {
       Popcorn.extend(profile.defaults, playerConfig.defaults[plugin]);
      }
      defaults = Popcorn.extend(profile.defaults, {
       target:elements[profile.target] || elements.annotationContainer
      });
      popcorn.defaults(plugin, defaults);
      if (!profile.normalize) {
       profile.normalize = {};
      }
      Popcorn.forEach(normalizeMethods, function(method, key) {
       if (normalizeMethods.hasOwnProperty(key) && typeof profile.normalize[key] !== "function") {
        profile.normalize[key] = method;
       }
      });
      if (elements.editControls && (pluginsEnabled[plugin] || pluginsEnabled[aType])) {
       buttonElements = utils.microTemplate(elements.editControls, {
        "#":id,
        ".":"ss-icon disabled hapyak-new-" + id,
        ">":profile.icon,
        title:"Add " + profile.title
       });
       profile.button = buttonElements[id];
       elements["new-" + id] = profile.button;
       editButtons.push({
        index:profile.sortIndex,
        id:"new-" + id,
        alt:id
       });
       editButtons.sort(editButtonsSort);
       pluginOrder[id] = profile.zIndex;
       addButtonListener(profile.button, function() {
        createButtonClick(profile);
       });
       if (!editorLocked) {
        removeClass(profile.button, "disabled");
       }
       if (profile.enableAltControls !== false && options.enableAltControls !== false) {
        setUpAltControl(profile);
       }
       provisionAnnotationEditor(aType);
      }
     }
     doneLoading();
    }
    if (backlog) {
     while (backlog.length) {
      annotation = backlog.shift();
      setUpAnnotation(profile, annotation);
     }
     updateMarkers();
    }
    if (typeof callback === "function") {
     callback();
    }
    callbacks = provisionCallbacks[aType];
    if (callbacks) {
     while (callbacks.length) {
      callbacks.shift()();
     }
    }
   }, function(err) {
    var backlog = annotationBacklog[aType];
    if (backlog) {
     annotationsToLoad -= backlog.length;
     backlog.length = 0;
    }
    doneLoading();
    logging.warn("Failed to load plugin " + aType, err);
    logging.captureException(err);
    if (!annotationsToLoad) {
     doneLoadingAnnotations();
    }
   });
  }
  function loadAnnotation(annotation) {
   var aType = annotation.get("type");
   aType = aTypeAliases[aType] || aType;
   if (annotationProfiles[aType]) {
    setUpAnnotation(annotationProfiles[aType], annotation);
    return;
   }
   if (!annotationBacklog[aType]) {
    annotationBacklog[aType] = [];
   }
   annotationBacklog[aType].push(annotation);
   provisionAnnotationType(aType);
  }
  function createAnnotation(plugin, options, callback, commit, aType) {
   function createTrackEvent() {
    var id, currentTime, duration;
    function done(id) {
     var annotation;
     if (id) {
      editor.edit(id);
      if (typeof callback === "function") {
       if (commit) {
        annotation = popcornAnnotations[id];
        annotation.onSave(function() {
         setUpAnnotationId(id, annotation);
         callback(id, annotation, editor, alternateControls[aType]);
        });
        dao.store.commit();
       } else {
        callback(id, null, editor, alternateControls[aType]);
       }
      } else if (commit) {
       dao.store.commit();
      }
     }
    }
    if (!options) {
     options = {};
    }
    if (isNaN(options.start)) {
     currentTime = getCurrentTime();
     duration = options._duration;
     if (!duration || duration < 0) {
      duration = playerConfig.duration || 3;
     }
     options.start = currentTime;
     options.end = currentTime + duration;
    }
    options.end = Math.min(options.end, popcorn.duration());
    getEditor(function() {
     id = editor.create(plugin, options, done);
     logging.log("Created editor, id is", id, options);
     done(id);
    });
   }
   if (activeTrack && window.HapyakApp && activeTrack.hasPermission("add_annotations")) {
    createTrackEvent();
   } else {
    emit("requestCreateTrack");
    return false;
   }
  }
  function sortAnnotations(time) {
   function sortFn(a, b) {
    var pluginA, pluginB;
    pluginA = pluginOrder[a._natives.type];
    pluginB = pluginOrder[b._natives.type];
    if (pluginA === undefined) {
     pluginA = -1;
    }
    if (pluginB === undefined) {
     pluginB = -1;
    }
    return pluginA - pluginB || b.end - a.end;
   }
   var i, events = [], nextContainer = null;
   var event, eventsByStart, targetContainer;
   if (!popcorn) {
    return;
   }
   eventsByStart = popcorn.data.trackEvents.byStart;
   if (eventsByStart.length <= 2) {
    return;
   }
   for (i = 1; i < eventsByStart.length; i++) {
    event = eventsByStart[i];
    if (event.container && [ elements.annotationContainer, elements.annotationNoscaleContainer ].indexOf(event.container.parentNode) !== -1) {
     if (event.start > time) {
      nextContainer = event.container;
      break;
     }
     if (event.start === time) {
      events.push(event);
     }
    }
   }
   if (events.length <= 1) {
    return;
   }
   events.sort(sortFn);
   for (i = 0; i < events.length; i++) {
    event = events[i];
    if (event.noscale) {
     targetContainer = elements.annotationNoscaleContainer;
    } else {
     targetContainer = elements.annotationContainer;
    }
    event.dragContainer = event.editorContainer = event.target = event.topContainer = targetContainer;
    if (nextContainer && nextContainer.parentNode !== event.container.parentNode) {
     nextContainer = null;
    }
    targetContainer.insertBefore(event.container, nextContainer);
   }
  }
  function loadEditor() {
   if (editor || !elements || !queuedEditorRequested) {
    return;
   }
   editor = Popcorn.quickEdit(popcorn, {
    permission:function(action, id) {
     var annotation, permission;
     if (action === "create") {
      return activeTrack && window.HapyakApp && activeTrack.hasPermission("edit");
     }
     if (action === "edit" && transientAnnotations[id]) {
      return false;
     }
     annotation = popcornAnnotations[id];
     try {
      permission = !annotation || (action === "edit" ? canEditAnnotation(annotation) :annotation.hasPermission(action));
     } catch (e) {
      permission = false;
     }
     return permission;
    },
    getAnnotationObject:function(id) {
     return popcornAnnotations[id];
    },
    dialogContainer:elements.editorContainer,
    dragContainer:elements.annotationContainer,
    topContainer:elements.annotationContainer,
    baseWidth:BASE_WIDTH
   });
   editor.setting("drawing", "editorContainer", elements.drawingEditContainer);
   editor.setting("remote", "editorContainer", elements.topLeftContainer);
   editor.setting("remote", "remotes", remotes || []);
   editor.on("activate", function(trackEvent, editor) {
    if (editor.editContainer.parentNode === elements.annotationContainer || editor.editContainer.parentNode === elements.contentsContainer) {
     setPrefixedStyle(editor.editContainer, "transform", "scale(" + 1 / playerScale + ")");
    }
    editor.setting("annotation", popcornAnnotations[trackEvent.id]);
   });
   editor.on("edit", function(trackEvent) {
    var annotation, aType, id = trackEvent._id, container = trackEvent.container, parent = container && container.parentNode || trackEvent.target, editContainer = parent && parent.querySelectorAll('div[data-popcorn-id="' + id + '"].popcorn-quickedit-edit')[0], plugin = trackEvent.plugin || trackEvent._natives && trackEvent._natives.type, profile;
    me.pause();
    popcorn.setData(id, "hapyak-editing", true, true);
    annotation = popcornAnnotations[id];
    aType = annotation && annotation.get("type") || plugin;
    aType = aTypeAliases[aType] || aType;
    if (container) {
     addClass(container, "hapyak-editing-" + plugin);
     if (container.parentNode !== parent || parent.lastElementChild !== container && parent.lastElementChild !== editContainer) {
      parent.appendChild(container);
     }
    }
    if (editContainer && editContainer.parentNode) {
     parent.appendChild(editContainer);
    }
    if (alternateControls[aType]) {
     Popcorn.forEach(alternateControls[aType], function(control) {
      control.activate();
     });
    }
    if (annotation && annotation.get("isSaved")) {
     profile = annotationProfiles[aType];
     if (profile && profile.create) {
      profile.create(id, annotation, editor, alternateControls[profile.id]);
     }
    }
    emit("annotationFocus", false, annotation.get("id"));
   }, true);
   editor.on("done", function(trackEvent) {
    var editing = editor && editor.editing(), annotation, aType;
    popcorn.setData(trackEvent._id, "hapyak-editing", false, true);
    annotation = popcornAnnotations[trackEvent._id];
    emit("annotationBlur", false, annotation.get("id"));
    Popcorn.forEach(Popcorn.registryByName, function(obj, plugin) {
     var i, e, remove = true;
     for (i = editing.length - 1; i >= 0; i--) {
      e = editing[i];
      if (e && (e.plugin || e._natives && e._natives.type) === plugin) {
       remove = false;
       editing.splice(i, 1);
      }
     }
     if (remove) {
      if (trackEvent.container) {
       removeClass(trackEvent.container, "hapyak-editing-" + plugin);
      }
      annotation = popcornAnnotations[trackEvent._id];
      aType = annotation && annotation.get("type") || plugin;
      aType = aTypeAliases[aType] || aType;
      if (alternateControls[aType]) {
       Popcorn.forEach(alternateControls[aType], function(control) {
        control.deactivate();
       });
      }
     }
    });
   });
   Popcorn.forEach(pluginsEnabled, function(val, key) {
    if (val) {
     provisionAnnotationEditor(key);
    }
   });
   Popcorn.forEach(popcornAnnotations, function(annotation, id) {
    var aType, profile;
    aType = annotation.get("type");
    aType = aTypeAliases[aType] || aType;
    profile = annotationProfiles[aType];
    if (profile && profile.create) {
     profile.create(id, annotation, editor, alternateControls[profile.id]);
    }
   });
   unlockEditor("loadEditor");
   updateAnnotationDisplay();
   while (queuedEditorCallbacks.length) {
    queuedEditorCallbacks.shift()();
   }
  }
  function getEditor(callback) {
   if (editor) {
    if (callback) {
     callback();
    }
    return;
   }
   lockEditor("loadEditor");
   queuedEditorRequested = true;
   if (callback) {
    queuedEditorCallbacks.push(callback);
   }
   require([ "popcorn.quickedit" ], loadEditor);
  }
  function trackLinks(trackEvent) {
   var links, i, link, element;
   function trackLink(evt) {
    var annotation, link = evt.currentTarget;
    if (link && link.href) {
     annotation = popcornAnnotations[trackEvent._id];
     logging.tracking.annotationAction(annotation, "External Click", {
      Target:link.href,
      Text:annotation.getCustomProperty("popcorn.text"),
      Remaining:popcorn.duration() - popcorn.currentTime()
     });
    }
   }
   if (!trackEvent || !trackEvent.container) {
    return;
   }
   element = trackEvent.container;
   links = element.querySelectorAll("a");
   for (i = 0; i < links.length; i++) {
    link = links[i];
    link.removeEventListener("click", trackLink, false);
    if (link.hasAttribute("data-hapyak-log")) {
     link.addEventListener("click", trackLink, false);
    }
   }
  }
  function updateModeSwitch() {
   if (!elements.controlBar) {
    return;
   }
   if (editMode) {
    addClass(elements.editAnnotations, "active");
    removeClass(elements.showAnnotations, "active");
    removeClass(elements.hideAnnotations, "active");
    return;
   }
   if (showAnnotations) {
    removeClass(elements.editAnnotations, "active");
    addClass(elements.showAnnotations, "active");
    removeClass(elements.hideAnnotations, "active");
    Popcorn.forEach(popcorn.data.trackEvents.byStart.slice(1, popcorn.data.trackEvents.byStart.length - 2), function(trackEvent) {
     removeClass(trackEvent.container, "hapyak-editing-" + trackEvent._natives.type);
    });
    return;
   }
   removeClass(elements.editAnnotations, "active");
   removeClass(elements.showAnnotations, "active");
   addClass(elements.hideAnnotations, "active");
  }
  function clearWarnings() {
   var now = Date.now(), remain = 0;
   Popcorn.forEach(warnings, function(w) {
    if (w.expire <= now) {
     elements.warning.removeChild(w.element);
     delete warnings[w];
    } else {
     remain++;
    }
   });
   if (remain) {
    elements.warning.style.display = "block";
    elements.warning.style.marginTop = -elements.warning.offsetHeight + "px";
    setTimeout(clearWarnings, 100);
   } else {
    elements.warning.style.marginTop = "";
   }
  }
  function addWarning(msg) {
   var warning = warnings[msg];
   if (!warning) {
    warning = {
     element:document.createElement("div")
    };
    warning.element.appendChild(document.createTextNode(msg));
    elements.warning.appendChild(warning.element);
    warnings[msg] = warning;
   }
   warning.expire = Date.now() + 5e3;
   clearWarnings();
  }
  function updateSectionsViewed(force) {
   var time = popcorn.currentTime(), next;
   if (force || !popcorn.paused()) {
    while (time < currentSection.start && currentSectionIndex >= 0) {
     currentSectionIndex--;
     currentSection = sectionsViewed[currentSectionIndex];
    }
    if (time < currentSection.end) {
     return;
    }
    next = sectionsViewed[currentSectionIndex + 1];
    while (next && next.start <= time) {
     currentSectionIndex++;
     currentSection = sectionsViewed[currentSectionIndex];
     next = sectionsViewed[currentSectionIndex + 1];
    }
    if (currentSection && (!force && time - currentSection.end < 5 || time - currentSection.end < 1)) {
     currentSection.end = time;
     if (currentSectionIndex < sectionsViewed.length - 1) {
      if (next.start - time < 1) {
       currentSection.end = next.end;
       sectionsViewed.splice(currentSectionIndex + 1, 1);
      }
     }
     return;
    }
    currentSection = {
     start:time,
     end:time
    };
    currentSectionIndex++;
    sectionsViewed.splice(currentSectionIndex, 0, currentSection);
   }
  }
  function addButtonListener(button, callback) {
   if (!button) {
    return;
   }
   button.style.webkitTouchCallout = "none";
   setPrefixedStyle(button, "userSelect", "none");
   button.setAttribute("unselectable", "on");
   button.addEventListener("click", function(evt) {
    if (evt.which === 3 || evt.button === 2 || evt.ctrlKey) {
     return false;
    }
    evt.preventDefault();
    if (button !== elements.moreIcon) {
     removeClass(elements.moreIcon, "hover");
    }
    callback.call(this, evt);
   }, false);
  }
  function setDebugAttributes(trackEvent, annotation) {
   var container = trackEvent.container;
   if (container) {
    if (!container.getAttribute("data-popcorn-id")) {
     container.setAttribute("data-popcorn-id", trackEvent._id);
    }
    if (annotation && !container.getAttribute("data-hapyak-id")) {
     if (annotation.get("isSaved") && annotation.get("id")) {
      container.setAttribute("data-hapyak-id", annotation.get("id"));
     } else {
      annotation.onSave(function() {
       container.setAttribute("data-hapyak-id", annotation.get("id"));
      });
     }
    }
   }
  }
  function updateTrackInfo() {
   var user, image, fullName, title, description, ratingsAvg, show = false;
   if (!elements.trackInfo || moduleConfig.hideTrackInfo) {
    return false;
   }
   user = activeTrack && activeTrack.get("owner");
   image = user && user.get("image");
   if (image) {
    elements.ownerProfileImage.src = image;
    elements.ownerProfileImage.style.display = "";
    show = true;
   } else {
    elements.ownerProfileImage.style.display = "none";
   }
   fullName = user && user.get("full_name");
   if (fullName) {
    show = true;
    setText(elements.ownerName, fullName);
    elements.ownerName.parentNode.style.display = "";
   } else {
    elements.ownerName.parentNode.style.display = "none";
   }
   if (activeTrack) {
    title = activeTrack.get("title");
    description = activeTrack.get("description");
    ratingsAvg = activeTrack.get("ratings_avg");
    if (title || description) {
     show = true;
    }
   } else {
    title = video && video.get("title");
   }
   setText(elements.trackTitle, title);
   setText(elements.trackDescription, description);
   return true;
  }
  function trackEventUpdated(data) {
   var trackEvent = data.track, newTrackEvent = {}, plugin, transientAnnotation, annotation, id, duration, notEmpty = false, notEmptyFields = /^(bottom|end|height|left|right|start|top|width)$/;
   trackLinks(trackEvent);
   id = trackEvent._id;
   if (!editor || editor.editing().length <= 0) {
    sortAnnotations(trackEvent.start);
   }
   if (!trackEvent._natives) {
    return;
   }
   if (!popcornEventsByType[trackEvent._natives.type]) {
    popcornEventsByType[trackEvent._natives.type] = {};
   }
   popcornEventsByType[trackEvent._natives.type][id] = trackEvent;
   if (!annotationsLoaded) {
    return;
   }
   updateMarkers(id);
   if (blockSave[id]) {
    return;
   }
   annotation = popcornAnnotations[id];
   Popcorn.forEach(trackEvent, function(val, key) {
    if (blacklist[key]) {
     return;
    }
    if (val === undefined || typeof val === "function" || val === null) {
     return;
    }
    if (instanceOfElement(val) || val instanceof window.Popcorn) {
     return;
    }
    try {
     if (!JSON.stringify(val)) {
      return;
     }
    } catch (e) {
     return;
    }
    if (typeof val !== "object" || Popcorn.isArray(val)) {
     if (val === Infinity) {
      val = Number.MAX_VALUE;
     } else if (val === -Infinity) {
      val = -Number.MAX_VALUE;
     }
     newTrackEvent[key] = val;
    } else {
     newTrackEvent[key] = Popcorn.extend({}, val);
    }
    if (!notEmptyFields.test(key)) {
     notEmpty = true;
    }
   });
   trackEvent._duration = trackEvent._duration || 0;
   duration = popcorn.duration();
   if (duration > 0) {
    trackEvent.start = Math.min(trackEvent.start || 0, duration);
    trackEvent.end = Math.min(trackEvent.end || trackEvent.start, duration);
   }
   if (annotation) {
    if (popcornDeleteQueue[id]) {
     delete popcornDeleteQueue[id];
    }
    if (notEmpty && canEditAnnotation(annotation)) {
     annotation.set("start_time", trackEvent.startTimeValue);
     annotation.set("start_time_format", trackEvent.startTimeFormat);
     annotation.set("duration", trackEvent.durationValue);
     annotation.set("duration_format", trackEvent.durationFormat);
     annotation.setCustomProperty("target", null);
     annotation.setCustomProperty("popcorn", newTrackEvent);
     annotation.onSave(function() {
      if (editor) {
       editor.emit("commit", false, id, annotation);
      }
      emit("updateTrackEventSaved", false, annotation);
     });
     dao.store.commit();
     emit("updateTrackEvent", false, annotation);
    }
   } else {
    if (trackEvent._isTransient) {
     transientAnnotations[id] = trackEvent;
    }
    transientAnnotation = transientAnnotations[id];
    trackEvent.startTimeValue = trackEvent.start;
    trackEvent.startTimeFormat = "seconds";
    trackEvent.durationValue = trackEvent._duration;
    trackEvent.durationFormat = "seconds";
    annotation = model.Comment.createRecord(null, !!transientAnnotation);
    if (transientAnnotation) {
     annotation.setCustomProperty("externalId", transientAnnotation.id);
    }
    plugin = trackEvent.plugin || trackEvent._natives && trackEvent._natives.type;
    annotation.set("type", plugin);
    annotation.set("track", activeTrack);
    annotation.set("start_time", trackEvent.startTimeValue);
    annotation.set("start_time_format", trackEvent.startTimeFormat);
    annotation.set("duration", trackEvent.durationValue);
    annotation.set("duration_format", trackEvent.durationFormat);
    if (window.HapyakApp) {
     annotation.set("user", window.HapyakApp.currentUser);
    }
    annotation.set("privacy", "public");
    annotation.setCustomProperty("popcorn", newTrackEvent);
    if (newTrackEvent._duration) {
     annotation.set("duration", newTrackEvent._duration);
    }
    annotation.onSave(function() {
     setUpAnnotationId(id, annotation);
     if (editor) {
      editor.emit("commit", false, id, annotation);
     }
     trackEvent.annotationId = annotation.id || annotation.get("id");
     blockSave[id] = true;
     popcorn[plugin](trackEvent);
     delete blockSave[id];
     emit("createTrackEventSaved", false, annotation);
    });
    popcornAnnotations[trackEvent._id] = annotation;
    if (!transientAnnotation) {
     dao.store.commit();
    }
    emit("createTrackEvent", false, annotation);
   }
   setDebugAttributes(trackEvent, annotation);
  }
  function getVideoLink() {
   return "http://corp.hapyak.com";
  }
  function setLinks() {
   if (elements && elements.tinyLogo) {
    elements.tinyLogo.setAttribute("href", getVideoLink());
   }
   if (popcorn) {
    popcorn.options.sharing.url = getVideoLink();
   }
  }
  function getCurrentTime() {
   return popcorn && Math.max(popcorn.currentTime(), 0) || 0;
  }
  function loadQueuedAnnotations() {
   var annotations, opts, changeTrack = false, reloadAnnotationSources = false;
   if (!queuedAnnotations || destroyed) {
    return;
   }
   if (popcorn.getTrackEvents().length) {
    removeTrackEvents();
    reloadAnnotationSources = true;
   }
   if (queuedAnnotationSources && queuedAnnotationSources.length) {
    return;
   }
   annotations = queuedAnnotations;
   queuedAnnotations = null;
   opts = queuedTrackOpts;
   queuedTrackOpts = null;
   if (window.HapyakApp && !activeTrack.hasPermission("edit")) {
    if (elements.editAnnotations) {
     elements.editAnnotations.style.display = "none";
    }
    me.editMode(false);
   }
   logging.debug("player: " + annotations.get("length") + " annotation(s) found, " + annotations);
   annotationsToLoad = annotations.get("length");
   if (annotationsToLoad) {
    annotationsLoaded = false;
    annotations.forEach(function(annotation) {
     if (!annotation.hasPermission("view")) {
      logging.warn("Do not have permission to view annotation " + annotation.get("id"));
      return;
     }
     loadAnnotation(annotation);
    });
   } else {
    changeTrack = true;
    annotationsLoaded = true;
    updateMarkers();
    trackSystemScope.set("annotationsLoaded", true, true);
    if (reloadAnnotationSources) {
     loadAnnotationSources();
    }
    popcorn.emit("annotationsloaded");
   }
   if (!moduleConfig.hideTrackInfo && elements.trackInfo) {
    if (!options.hasOwnProperty("trackInfo") || options.trackInfo) {
     me.showTrackInfo();
    } else {
     updateTrackInfo();
    }
   }
   if (startEditMode) {
    me.editMode(true);
   } else {
    me.showAnnotations(true);
   }
   if (window.HapyakApp && activeTrack.hasPermission("edit")) {
    if (elements.editAnnotations) {
     elements.editAnnotations.style.display = "";
    }
    resizeControls();
   }
   if ((!popcorn.checkGates || !popcorn.checkGates(true)) && opts && opts.autoplay && !played && (!editor || !editor.editing().length)) {
    if (targetAnnotation) {
     me.seekAnnotation(targetAnnotation);
    }
    me.play();
   }
   if (changeTrack) {
    emit("changeTrack", false, activeTrack);
   }
   if (opts && opts.callback) {
    opts.callback();
   }
  }
  function loadAnnotationSources() {
   queuedAnnotationSources = [];
   Popcorn.forEach(annotationSources, function(enabled, sourceName) {
    if (enabled) {
     queuedAnnotationSources.push(sourceName);
     require([ sourceName ], function(source) {
      var sourceNameIndex = queuedAnnotationSources.indexOf(sourceName);
      queuedAnnotationSources.splice(sourceNameIndex, sourceNameIndex);
      source.call(this, container, video, opts, wrapper, function(events, plugins) {
       var numAnnotations = {};
       if (destroyed || !events) {
        return;
       }
       popcorn.getTrackEvents().forEach(function(te) {
        numAnnotations[te._natives.type] = numAnnotations[te._natives.type] || 0;
        numAnnotations[te._natives.type]++;
       });
       Popcorn.forEach(events, function(eventData) {
        var plugin = eventData.plugin, trackEvent = eventData.popcorn, maxAllowed;
        if (annotationProfiles && annotationProfiles[plugin]) {
         maxAllowed = annotationProfiles[plugin].maxAllowed;
        }
        if (maxAllowed && maxAllowed > 0 && numAnnotations[plugin] >= maxAllowed) {
         return true;
        }
        provisionAnnotationType(plugin, function() {
         var id;
         id = Popcorn.guid(plugin);
         transientAnnotations[id] = eventData;
         if (trackEvent._duration) {
          trackEvent.end = trackEvent.start + trackEvent._duration;
         }
         if (trackEvent.pause) {
          trackEvent.end = trackEvent.start + .5;
         }
         if (!trackEvent.end || trackEvent.end < trackEvent.start) {
          trackEvent.end = trackEvent.start + defaultDuration;
         }
         popcorn[plugin](id, trackEvent);
        });
       });
      });
      if (!queuedAnnotationSources.length) {
       loadQueuedAnnotations();
      }
     }, function(err) {
      logging.captureException(err);
      die("Unable to load annotation source: " + sourceName);
     });
    }
   });
  }
  function loadVideoWrapper() {
   var wrapperRef, ref, i, result, args, popcornOptions, viewerTemplate, groupStandard, videoElement;
   function onDurationChange() {
    var parsedTime, time;
    duration = popcorn.duration() || duration || video.get("duration");
    if (duration === durationChangeVal) {
     return;
    }
    durationChangeVal = duration;
    if (duration && Math.abs((video.get("duration") || 0) - duration) > 1 && video.hasPermission("edit")) {
     video.set("duration", duration);
    }
    updateMarkers();
    drawTimeline();
    if (wrapperRef && wrapperRef.showControlsEvent === "durationchange") {
     unlockEditor("player");
    }
    if (typeof options.time === "string") {
     parsedTime = timeRegex.exec(options.time);
     if (parsedTime) {
      time = parseFloat(parsedTime[1] || 0) * 60 + parseFloat(parsedTime[2] || 0);
     }
    } else if (options.time) {
     time = options.time;
    }
    if (!isNaN(time) && time > 0 && time < duration) {
     popcorn.currentTime(time);
    }
    emit("durationchange", true);
   }
   function onLoadedMetadata() {
    duration = popcorn.duration();
    if (showControls === "viewer") {
     if (wrapperRef && typeof wrapperRef.forceIpadControls === "function") {
      wrapperRef.forceIpadControls(src);
     }
     elements.controlBar.style.display = "";
    }
    if (duration) {
     onDurationChange();
    }
    if (loadedMetadataFired) {
     return;
    }
    loadedMetadataFired = true;
    if (wrapperRef && wrapperRef.showControlsEvent === "loadedmetadata") {
     unlockEditor("player");
    }
    me.resize();
    updateMarkers();
    drawTimeline();
    if (showTrackInfoTimeout && elements.trackInfo) {
     clearTimeout(showTrackInfoTimeout);
     showTrackInfoTimeout = setTimeout(function() {
      if (elements.trackInfo) {
       removeClass(elements.trackInfo, "visible");
      }
     }, 2e3);
    }
    emit("loadedmetadata", true);
   }
   function canPlay() {
    popcorn.off("canplay", canPlay);
    unlockEditor("player");
    updateAnnotationDisplay();
    emit("canplay", true, {
     controlBarHeight:controlBarHeight,
     videoWidth:me.videoWidth(),
     videoHeight:me.videoHeight(),
     pluginData:me.pluginData()
    });
   }
   if (destroyed) {
    return;
   }
   ref = playerType && wrappers[playerType];
   if (ref) {
    if (Popcorn[ref.fn] && Popcorn[ref.fn]._canPlaySrc(container)) {
     wrapperRef = ref;
    }
   }
   if (!wrapperRef) {
    for (i in wrappers) {
     if (wrappers.hasOwnProperty(i)) {
      ref = wrappers[i];
      result = Popcorn[ref.fn] && Popcorn[ref.fn]._canPlaySrc(container);
      if (result === true || result === "probably") {
       wrapperRef = ref;
       break;
      }
     }
    }
   }
   if (wrapperRef) {
    if (wrapperRef.isDuplicate && wrapperRef.isDuplicate(container)) {
     return;
    }
    if (wrapperRef.args) {
     args = wrapperRef.args(video, Popcorn.extend({
      isIOS:isIOS
     }, options));
     args.unshift(container);
     wrapper = Popcorn[wrapperRef.fn].apply(Popcorn, args);
    } else {
     wrapper = Popcorn[wrapperRef.fn](container, args);
    }
    src = container;
    container = wrapperRef.container(container, wrapper) || container;
   }
   if (!instanceOfElement(container)) {
    die("Missing container element");
   }
   if (wrapper) {
    existingVideo = true;
    viewerTemplate = options.playerType === "skeleton" && embedUtils.dotget(options, "player.minimalRootCss") ? rootBoxTemplate :annotationTemplate;
    elements = utils.microTemplate(container, viewerTemplate);
    if (wrapperRef.setupAnnotationContainer) {
     wrapperRef.setupAnnotationContainer(elements, options);
    }
    if (options.controls === undefined && wrapperRef.forceIpadControls && isIOS || options.controls === "viewer") {
     if (typeof wrapperRef.forceIpadControls === "function") {
      wrapperRef.forceIpadControls(src, elements);
     }
     embedUtils.controlStyle(true, true);
     elements.controlBar = container.appendChild(document.createElement("div"));
     elements.controlBar.className = "hapyak-viewer-control-bar";
     Popcorn.extend(elements, utils.microTemplate(elements.controlBar, controlBarTemplate));
     elements.controlBar.style.paddingBottom = "0";
     groupStandard = elements.groupStandard;
     groupStandard.style.marginTop = "0";
     groupStandard.firstChild.style.border = "none";
     groupStandard.firstChild.style.boxShadow = "none";
     elements.groupCreate.style.display = "none";
     elements.modeSwitch.style.display = "none";
     showControls = "viewer";
    } else {
     showControls = false;
    }
    if (wrapperRef && wrapperRef.modify) {
     wrapperRef.modify(elements, container);
    }
    wrapper.autoplay = options.autoplay;
    showNativeControls = false;
    addClass(container, "hapyak-remote");
   } else {
    elements = utils.microTemplate(container, options.embed ? embedTemplate :playerTemplate);
    if (options.controls === undefined) {
     showControls = "edit";
    } else {
     showControls = showControls === undefined ? options.controls :showControls;
     if (showControls === "play") {
      elements.groupCreate.style.display = "none";
     } else if (showControls) {
      showControls = "edit";
     }
     elements.controlBar.style.display = showControls ? "" :"none";
    }
    if (showNativeControls === undefined) {
     showNativeControls = !showControls;
    }
    wrapperRef = wrappers[source] || options.playerType && wrappers[options.playerType];
    if (wrapperRef) {
     if (wrapperRef.src) {
      src = wrapperRef.src(video, options);
     } else {
      src = (wrapperRef.pre || "") + encodeURIComponent(sourceId) + (wrapperRef.post || "");
     }
     if (wrapperRef.args) {
      options.playerParameters = Popcorn.extend({
       forceReadyState:showControls === "edit"
      }, options.playerParameters);
      args = wrapperRef.args(video, options);
      args.unshift(elements.videoContainer);
      wrapper = Popcorn[wrapperRef.fn].apply(Popcorn, args);
     } else {
      wrapper = Popcorn[wrapperRef.fn](elements.videoContainer);
     }
    } else if (source === "html5") {
     (function() {
      var sourceMimeType, canPlay = false, sources, source;
      sources = video.getCustomProperty("sources");
      if (!sources || !sources.length) {
       die("No video sources found");
       return;
      }
      src = [];
      wrapper = document.createElement("video");
      for (i = 0; i < sources.length; i++) {
       source = sources[i];
       sourceMimeType = source.mime_type;
       src.push({
        src:source.url,
        type:sourceMimeType
       });
       if (sourceMimeType && wrapper.canPlayType(sourceMimeType)) {
        canPlay = true;
       }
      }
      if (canPlay) {
       for (i = 0; i < src.length; i++) {
        source = document.createElement("source");
        source.setAttribute("src", src[i].src);
        source.setAttribute("type", src[i].type || "");
        wrapper.appendChild(source);
       }
       elements.videoContainer.appendChild(wrapper);
       wrapper.addEventListener("error", function() {
        if (!destroyed) {
         logging.error("Unable to play video", sources);
        }
       }, false);
       src = null;
      } else {
       wrapper = Popcorn.HTMLVideojsVideoElement(elements.videoContainer);
       wrapper.preload = "auto";
      }
     })();
    } else {
     die("Unknown source: " + video.get("source"));
    }
    wrapper.controls = showNativeControls;
    wrapper.autoplay = options.autoplay;
    addClass(elements.playBox, video.get("source"));
   }
   if (!wrapper) {
    die("Unable to create video element");
   }
   addClass(container, "hapyak-player");
   ctx = elements.timeline && elements.timeline.getContext("2d");
   addProvisioningClasses(configuration.provisioning, container);
   preserveFullscreenStyles = wrapperRef && wrapperRef.preserveFullscreenStyles;
   Popcorn.forEach(playerConfig.styles, function(styles, name) {
    var element = elements[name];
    if (element) {
     Popcorn.forEach(styles, function(value, key) {
      element.style[key] = value;
     });
    }
   });
   if (showControls === "edit") {
    Popcorn.forEach(pluginsEnabled, function(val, key) {
     if (val) {
      provisionAnnotationType(key);
     }
    });
   }
   if (options.embed) {
    addClass(container, "hapyak-embed");
    addClass(container, "hapyak-remote");
    setLinks();
    elements.tinyLogo.addEventListener("click", function() {
     popcorn.pause();
     logging.tracking.playerAction("Controls", "Embed Logo Link");
    }, true);
    if (!fullscreenEnabled && !playerConfig.fullScreenPopOut) {
     elements.fullScreen.style.display = "none";
    }
   } else if (elements.controlBar) {
    elements.tinyLogo.style.display = "none";
   }
   addClass(container, "hapyak-" + (options.edit ? "edit" :"view") + "-mode");
   if (elements.timeline) {
    timelineTouch = new Touch(elements.timeline, mouseShuttle, mouseShuttle, function() {
     if (!shuttlePaused) {
      popcorn.play();
      shuttlePaused = true;
     }
    });
   }
   if (elements.volumeContainer && (isIOS || navigator.userAgent.match(/Android/))) {
    elements.volumeContainer.style.display = "none";
    elements.annotationSkipContainer.style.display = "none";
   }
   if (elements.volumeSliderContainer) {
    volumeTouch = new Touch(elements.volumeSliderContainer, function(evt, x, y) {
     addClass(elements.volumeContainer, "active");
     dragVolume(evt, x, y);
    }, dragVolume, function() {
     removeClass(elements.volumeContainer, "active");
    });
    vctx = elements.volumeSlider.getContext("2d");
   }
   volume = 1;
   if (configuration.provisioning.watermark) {
    elements.watermark = document.createElement("a");
    elements.watermark.style.cssText = [ "position: absolute", "width: 100%", "top: 0", "left: 0", "display: block", "visibility: visible", "opacity: 0.3", "margin: 10% 0 0 0", "padding: 20px", "color: white", "background-color: black", "text-align: center", "font-size: 30px", "line-height: 30px", "font-weight: bold", "box-sizing: border-box;", "z-index: auto" ].join(";");
    if (startEditMode) {
     elements.watermark.style.display = "none";
    }
    elements.watermark.className = "hapyak-watermark";
    elements.watermark.setAttribute("target", "_new");
    elements.watermark.innerHTML = '<img src="' + hapyak.assets + '/img/yak-blue.png"/>';
    elements.watermark.appendChild(document.createTextNode(playerConfig.watermarkText || "Contact HapYak to purchase API Keys"));
    elements.watermark.setAttribute("href", playerConfig.contactUrl || "http://corp.hapyak.com");
    elements.watermark.addEventListener("click", function() {
     if (popcorn) {
      popcorn.pause();
     }
    }, false);
    elements.annotationContainer.parentNode.insertBefore(elements.watermark, elements.annotationContainer.nextSibling);
   }
   popcornOptions = {
    environment:trackScope,
    hapyakPlayer:me,
    getScope:getScope,
    frameAnimation:true,
    sharing:{
     image:video.get("image"),
     title:video.get("title"),
     url:getVideoLink()
    },
    shortenUrls:playerConfig.shortenUrls,
    validateLink:validateLink,
    hostWindow:options.hostWindow || window,
    disableInlineTextEdit:moduleConfig.disableInlineTextEdit === undefined ? playerConfig.disableInlineTextEdit :moduleConfig.disableInlineTextEdit,
    autoEditDialog:moduleConfig.autoEditDialog === undefined ? playerConfig.autoEditDialog :moduleConfig.autoEditDialog
   };
   Popcorn.extend(popcornOptions, playerConfig.popcornOptions);
   popcorn = Popcorn(wrapper, popcornOptions);
   updateAnnotationDisplay();
   popcorn.options.loadTrackTime = function(trackId, time, callback) {
    var track;
    if (typeof time === "string") {
     time = Popcorn.util.toSeconds(time, popcorn.options.framerate);
    }
    if (!isNaN(time) && time >= 0 && time < popcorn.duration()) {
     popcorn.currentTime(time);
    }
    if (trackId) {
     if (activeTrack && activeTrack.get("id") === trackId && trackScope !== environment) {
      Popcorn.forEach(trackScope.keys(), function(key) {
       if (key !== "trackId") {
        trackScope.clear(key, true);
       }
      });
      Popcorn.forEach(scopesByPopcornId, function(scope) {
       Popcorn.forEach(scope.keys(), function(key) {
        scope.clear(key, true);
       });
      });
     }
     track = model.Track.find(trackId);
     track.onLoad(function() {
      me.loadTrack(track, {
       callback:callback
      });
     });
    } else if (callback) {
     callback();
    }
   };
   popcorn.on("pluginerror", function(e) {
    logging.captureException(e);
   });
   Popcorn.forEach(Popcorn.registryByName, function(plugin, name) {
    popcorn.defaults(name, {
     target:elements.annotationContainer
    });
   });
   if (elements.trackReplayButton) {
    elements.trackReplayButton.innerHTML = "Replay";
    elements.trackReplayButton.addEventListener("click", function(e) {
     if (e.which === 3 || e.button === 2 || e.ctrlKey) {
      return false;
     }
     removeClass(elements.annotationContainer, "hapyak-player-overlay");
     removeClass(elements.annotationNoscaleContainer, "hapyak-player-overlay");
     removeClass(elements.trackInfo, "visible");
     removeClass(elements.trackMessage, "visible");
     elements.trackReplayButton.style.display = "none";
     popcorn.play(0);
    }, false);
   }
   (function() {
    var seekingTimeout, clearSeekingTimeout, seekingMessageElement = elements.trackMessage, previousCurrentTime = popcorn.currentTime();
    if (!elements.trackInfo || moduleConfig.hideTrackInfo) {
     return;
    }
    popcorn.on("seeking", function() {
     clearTimeout(seekingTimeout);
     clearTimeout(clearSeekingTimeout);
     if (elements.trackCapContent) {
      removeClass(elements.trackCapContent, "visible");
     }
     seekingTimeout = setTimeout(function() {
      var minutes = parseInt(popcorn.currentTime() / 60, 10), seconds, buffered = popcorn.buffered(), end = 0, start = 0, showOverlay = false, i, l;
      if (Math.abs(previousCurrentTime - popcorn.currentTime()) < 1) {
       return;
      }
      for (i = 0, l = buffered.length; i < l && !showOverlay; i++) {
       end = buffered.end(i);
       start = buffered.start(i);
       if (popcorn.currentTime() < start || popcorn.currentTime() > end) {
        showOverlay = true;
       }
      }
      if (!showOverlay) {
       return;
      }
      previousCurrentTime = popcorn.currentTime();
      if (minutes >= 1) {
       if (minutes >= 10) {
        minutes += ":";
       } else {
        minutes = "0" + minutes + ":";
       }
      } else {
       minutes = "00:";
      }
      seconds = parseInt(popcorn.currentTime() % 60, 10);
      if (seconds < 10) {
       seconds = "0" + seconds;
      }
      addClass(elements.trackInfo, "visible");
      addClass(elements.trackMessage, "visible");
      elements.trackReplayButton.style.display = "none";
      seekingMessageElement.innerHTML = "Seeking to: " + minutes + seconds;
      clearSeekingTimeout = setTimeout(function() {
       if (elements.trackInfo) {
        removeClass(elements.trackInfo, "visible");
       }
       if (seekingMessageElement) {
        seekingMessageElement.innerHTML = "";
       }
      }, 3e3);
     }, 250);
    });
    popcorn.on("ended", function() {
     clearTimeout(seekingTimeout);
     clearTimeout(clearSeekingTimeout);
     seekingMessageElement.innerHTML = "";
     removeClass(elements.annotationContainer, "hapyak-player-overlay");
     removeClass(elements.annotationNoscaleContainer, "hapyak-player-overlay");
     elements.trackReplayButton.style.display = "";
     addClass(elements.trackInfo, "visible");
     addClass(elements.trackMessage, "visible");
    });
    popcorn.on("seeked", function() {
     clearTimeout(clearSeekingTimeout);
     removeClass(elements.trackInfo, "visible");
     seekingMessageElement.innerHTML = "";
    });
   })();
   addButtonListener(elements.playButton, function() {
    if (editor) {
     editor.done();
    }
    if (me.paused()) {
     me.play();
     logging.tracking.playerAction("Controls", "Play");
    } else {
     me.pause();
     logging.tracking.playerAction("Controls", "Pause");
    }
   });
   addButtonListener(elements.volume, function() {
    var muted = popcorn.muted();
    popcorn.muted(!muted);
    if (muted && !popcorn.volume()) {
     popcorn.volume(1);
    }
   });
   addButtonListener(elements.moreIcon, function(evt) {
    if (evt.target !== elements.moreIcon && evt.target !== elements.moreIcon.firstChild) {
     return;
    }
    clearTimeout(editControlsTimeout);
    addClass(elements.moreIcon, "hover");
    editControlsTimeout = setTimeout(function() {
     removeClass(elements.moreIcon, "hover");
    }, 5e3);
   });
   require([ "hapyak.overlay" ], function(overlay) {
    if (!destroyed && typeof overlay.setup === "function") {
     overlay.setup(elements.overlayContainer, {});
    }
   });
   if (fullscreenEnabled) {
    document.addEventListener("fullscreenchange", fullScreenChange, false);
    document.addEventListener("mozfullscreenchange", fullScreenChange, false);
    document.addEventListener("webkitfullscreenchange", fullScreenChange, false);
    document.addEventListener("MSFullscreenChange", fullScreenChange, false);
   }
   if (elements.fullScreen) {
    if (!options.embed || fullscreenEnabled) {
     addButtonListener(elements.fullScreen, function() {
      me.fullscreen(!isFullscreen(containerIsFullscreen));
      logging.tracking.playerAction("Controls", "Fullscreen");
     });
    } else if (playerConfig.fullScreenPopOut) {
     elements.fullScreen.setAttribute("title", "Open video at full size in new window");
     addButtonListener(elements.fullScreen, function() {
      var windowName = video.get("id") + "hapyak", location = window.location, url, query, i;
      if (activeTrack) {
       windowName += activeTrack.get("id");
      }
      url = [ moduleConfig.rootUrl + location.pathname ];
      if (location.search && location.search.length > 1) {
       query = location.search.substr(1).split("&");
       for (i = 0; i < query.length; i++) {
        if (utils.startsWith.call(query[i], "time=")) {
         query.splice(i, 1);
         i--;
        }
       }
      } else {
       query = [];
      }
      if (popcorn) {
       query.push("time=" + popcorn.currentTime());
       url.push(query.join("&"));
      }
      logging.tracking.playerAction("Controls", "Fullscreen");
      me.pause();
      if (popOutWindow && !popOutWindow.closed) {
       popOutWindow.focus();
      } else {
       popOutWindow = window.open(url.join("?"), windowName);
      }
     });
    }
   }
   if (elements.showAnnotations) {
    addButtonListener(elements.showAnnotations, function() {
     if (editorLocked) {
      return;
     }
     me.editMode(false);
     me.showAnnotations(true);
     logging.tracking.playerAction("Controls", "Show Annotations");
    });
   }
   if (elements.hideAnnotations) {
    addButtonListener(elements.hideAnnotations, function() {
     if (editorLocked) {
      return;
     }
     me.showAnnotations(false);
     logging.tracking.playerAction("Controls", "Hide Annotations");
    });
   }
   if (elements.editAnnotations) {
    addButtonListener(elements.editAnnotations, function() {
     if (editorLocked) {
      return;
     }
     me.editMode(true);
     logging.tracking.playerAction("Controls", "Edit Annotations");
    });
   }
   if (popcorn.prev && elements.prevButton) {
    addButtonListener(elements.prevButton, function() {
     if (editMode) {
      popcorn.pause();
     }
     if (editor) {
      editor.done();
     }
     popcorn.prev();
     logging.tracking.playerAction("Controls", "Skip Backward");
    });
   }
   if (popcorn.next && elements.nextButton) {
    addButtonListener(elements.nextButton, function() {
     if (editMode) {
      popcorn.pause();
     }
     if (editor) {
      editor.done();
     }
     popcorn.next();
     logging.tracking.playerAction("Controls", "Skip Forward");
    });
   }
   if (elements.createTrack) {
    if (window.HapyakApp && window.HapyakApp.currentUser) {
     addButtonListener(elements.createTrack, function() {
      if (editorLocked) {
       return;
      }
      if (editor) {
       editor.done();
      }
      if (!window.HapyakApp.currentUser) {
       logging.info("No permission to create track");
       return;
      }
      me.editMode(true);
      me.createTrack();
     }, false);
    } else {
     elements.createTrack.display = "none";
    }
   }
   if (elements.trackInfoClose) {
    addButtonListener(elements.trackInfoClose, function() {
     removeClass(elements.trackInfo, "visible");
    });
   }
   window.addEventListener("resize", resize, false);
   window.addEventListener("orientationchange", orientationChange, false);
   if (autoResize) {
    autoResizeTimer = setInterval(resize, 500);
   }
   popcorn.on("resize", function onDimensionsChange() {
    popcorn.off("resize", onDimensionsChange);
    me.resize();
   });
   popcorn.on("loadedmetadata", onLoadedMetadata);
   popcorn.on("durationchange", onDurationChange);
   popcorn.on("progress", function() {
    lastTimelineTime = -1;
   });
   popcorn.on("volumechange", function() {
    var muted = popcorn.muted();
    if (!muted) {
     volume = popcorn.volume();
    }
    if (elements.volume) {
     if (!volume || muted) {
      elements.volume.className = "hapyak-volume ss-volume";
     } else if (volume < .5) {
      elements.volume.className = "hapyak-volume ss-volumelow";
     } else {
      elements.volume.className = "hapyak-volume ss-volumehigh";
     }
    }
    drawVolume();
   });
   popcorn.on("trackadded", trackEventUpdated);
   popcorn.on("trackchange", trackEventUpdated);
   popcorn.on("trackremoved", function(trackEvent) {
    function deleteAnnotation() {
     var annotation, annotationId;
     if (popcornDeleteQueue[trackEvent._id]) {
      annotation = popcornDeleteQueue[trackEvent._id];
      annotationId = annotation.get("id");
      if (!window.HapyakApp || !annotation.hasPermission("delete")) {
       logging.warn("Do not have permission to delete track " + annotation.get("id"));
       return;
      }
      logging.info("delete event " + trackEvent._id);
      delete popcornDeleteQueue[trackEvent._id];
      emit("removeTrackEvent", false, annotation);
      annotation.onDelete(function() {
       emit("removeTrackEventSaved", false, annotation);
      });
      annotation.deleteRecord();
      dao.store.commit();
      delete popcornAnnotations[trackEvent._id];
      popcorn.removeTrackEvent(trackEvent._id);
      if (activeTrack) {
       trackSystemScope.set("annotationIds." + annotationId, false, true);
       getScope(trackEvent._id).destroy();
      }
      delete scopesByPopcornId[trackEvent._id];
      delete popcornIdLookup[annotationId];
      delete annotationsById[annotationId];
      if (markers[trackEvent._id]) {
       if (elements.controlBar) {
        elements.controlBar.removeChild(markers[trackEvent._id]);
       }
       delete markers[trackEvent._id];
      }
     }
    }
    var eventType = trackEvent._natives && trackEvent._natives.type || "", events = popcornEventsByType[eventType];
    if (events) {
     delete events[trackEvent._id];
    }
    if (popcornAnnotations[trackEvent._id]) {
     popcornDeleteQueue[trackEvent._id] = popcornAnnotations[trackEvent._id];
     if (destroyed) {
      deleteAnnotation();
     }
     setTimeout(deleteAnnotation, 10);
    }
   });
   popcorn.on("trackstart", function(trackEvent) {
    var annotation, links, link, i, p;
    if (activeTrackEvents[trackEvent.id]) {
     return;
    }
    annotation = popcornAnnotations[trackEvent._id];
    if (annotation && !me.editMode()) {
     if (trackEvent.container && annotation.get("type") === "pop") {
      p = {};
      links = trackEvent.container.querySelectorAll("a");
      for (i = 0; i < links.length; i++) {
       link = links[i];
       p["Target" + (i + 1)] = link.href;
      }
     }
     logging.tracking.annotationView(annotation, p);
     trackStartTimes[trackEvent.id] = Date.now();
    }
    if (trackEvent && trackEvent.container) {
     if (trackEvent.gate) {
      addClass(trackEvent.container, "hapyak-action-gate");
     }
     if (trackEvent.pause) {
      addClass(trackEvent.container, "hapyak-action-pause");
     }
    }
    setDebugAttributes(trackEvent.track, annotation);
    emit("trackEventViewed", false, annotation, trackEvent);
   });
   popcorn.on("trackend", function(trackEvent) {
    var start = trackStartTimes[trackEvent._id], annotation;
    if (start) {
     annotation = popcornAnnotations[trackEvent._id];
     if (annotation) {
      logging.tracking.annotationEnded(annotation, {
       Elapsed:(Date.now() - start) / 1e3,
       Paused:!!trackEvent.pause
      });
     }
    }
    if (trackEvent && trackEvent.container) {
     removeClass(trackEvent.container, "hapyak-action-gate");
     removeClass(trackEvent.container, "hapyak-action-pause");
    }
    delete trackStartTimes[trackEvent._id];
    delete activeTrackEvents[trackEvent.id];
   });
   popcorn.on("timeupdate", function() {
    var currentTime = getCurrentTime();
    if (currentTime < duration) {
     if (ended) {
      ended = false;
      updateAnnotationDisplay();
     } else {
      ended = false;
     }
    }
    if (popcorn.checkGates && popcorn.checkGates()) {
     return;
    }
    if (currentTime < currentViewSection.start || currentTime - currentViewSection.end >= 5) {
     accumulatedViewTime += currentViewSection.end - currentViewSection.start;
     currentViewSection.start = currentTime;
    }
    currentViewSection.end = currentTime;
    updateSectionsViewed();
    emit("timeupdate", false, popcorn.currentTime());
    logging.tracking.updateVideoPlayback();
   });
   popcorn.on("seeking", function() {
    var currentTime = popcorn.currentTime();
    accumulatedViewTime += currentViewSection.end - currentViewSection.start;
    currentViewSection.start = currentTime;
    currentViewSection.end = currentTime;
   });
   popcorn.on("seeked", function() {
    updateSectionsViewed(true);
    emit("seeked", false, popcorn.currentTime());
    logging.tracking.updateVideoPlayback();
   });
   popcorn.on("ended", function() {
    var action;
    ended = true;
    if (hideEndAnnotations) {
     updateAnnotationDisplay();
    }
    emit("ended", false, popcorn.currentTime());
    if (accumulatedViewTime > duration) {
     action = "End-over";
    } else if (duration - accumulatedViewTime < .5) {
     action = "End-complete";
    } else {
     action = "End-under";
    }
    logging.tracking.playerAction("Video", action);
   });
   popcorn.on("play", function onPlay() {
    played = true;
    addClass(container, "playing");
    if (elements.playButton) {
     elements.playButton.innerHTML = "&#xE8A0;";
    }
    if (elements.trackInfo) {
     removeClass(elements.trackInfo, "visible");
     removeClass(elements.trackCapContent, "visible");
    }
    emit("play");
   });
   popcorn.on("pause", function onPause() {
    if (shuttlePaused) {
     removeClass(container, "playing");
     if (elements.playButton) {
      elements.playButton.innerHTML = "&#x25B6;";
     }
    }
    emit("pause");
   });
   popcorn.on("disable", function() {
    me.showAnnotations(false);
   });
   popcorn.fallback({
    start:function(event, options) {
     var type, msg;
     type = options && options._natives && options._natives.type;
     msg = popcorn.incompatible(type);
     addWarning(msg);
    }
   });
   emit("loadedplayer", true, wrapper);
   resize(options.width, options.height);
   if (src) {
    wrapper.src = src;
   }
   if (moduleConfig.tracking && wrapper._util && wrapper._util.trackView) {
    wrapper._util.trackView(JSON.stringify(moduleConfig.tracking));
   }
   if (wrapper._util && wrapper._util.addConversionListener) {
    wrapper._util.addConversionListener(function(type, data) {
     var auth = hapyak.auth(), partnerAuth = auth.partner, email, username, userId;
     if (typeof data.email === "string" && data.email.indexOf("{") === -1) {
      email = partnerAuth.email || data.email;
      username = partnerAuth.username || data.username || email;
      userId = partnerAuth.userId || data.userId || username;
      hapyak.auth({
       partner:{
        userId:userId,
        username:username,
        email:email
       }
      });
     }
     emit("conversion", false, type, data);
    });
   }
   if (moduleConfig.muted) {
    popcorn.muted(true);
   }
   drawVolume();
   me.showAnnotations(true);
   lockEditor("player");
   updateTrackInfo();
   if (popcorn.duration()) {
    onDurationChange();
    if (wrapper.videoWidth === undefined ? wrapper.width && wrapper.height :wrapper.videoWidth && wrapper.videoHeight) {
     onLoadedMetadata();
    }
   }
   if (wrapper.readyState >= 3) {
    canPlay();
   } else {
    popcorn.on("canplay", canPlay);
   }
   loadQueuedAnnotations();
   loadAnnotationSources();
   setLinks();
   me.controls(showControls);
   if (queuedPlaying) {
    me.play();
   }
   me.fullscreen(queuedFullscreen);
  }
  function trackDataObserver() {
   function dataChanged() {
    var obj, changed = false, changes, removed, val, i, key;
    dataChangeTimeout = 0;
    if (destroyed || !listeners.data || !activeTrack) {
     return;
    }
    obj = {};
    changes = {};
    removed = {};
    for (key in variablesBackup) {
     if (variablesBackup.hasOwnProperty(key)) {
      changes[key] = undefined;
      removed[key] = true;
     }
    }
    for (i = 0; i < trackScope.keys.count; i++) {
     key = trackScope.keys(i);
     val = trackScope.get(key);
     obj[key] = val;
     if (variablesBackup[key] === val) {
      delete changes[key];
     } else {
      variablesBackup[key] = val;
      changes[key] = val;
      changed = true;
     }
     delete removed[key];
    }
    if (changed) {
     for (key in removed) {
      if (removed.hasOwnProperty(key)) {
       delete variablesBackup[key];
      }
     }
     emit("data", false, obj, changes);
    }
   }
   if (dataChangeTimeout) {
    return;
   }
   dataChangeTimeout = setTimeout(dataChanged, 0);
  }
  this.annotationPosition = function(annotation) {
   var popcornId = popcornIdLookup[annotation.get("id")];
   var trackEvent = popcorn.getTrackEvent(popcornId);
   if (!trackEvent || !embedUtils.dotget(trackEvent, "container.parentNode")) {
    return [ undefined, undefined ];
   }
   var container = trackEvent.container, parent = trackEvent.container.parentNode, annotationHeight = container.offsetHeight, annotationWidth = container.offsetWidth, parentHeight = parent.offsetHeight, parentWidth = parent.offsetWidth, pctWidth = annotationWidth / parentWidth * 100, pctHeight = annotationHeight / parentHeight * 100, pctTop = container.offsetTop / parentHeight * 100, pctLeft = container.offsetLeft / parentWidth * 100, gridBoundaries = [ 1 / 3 * 100, 2 / 3 * 100 ], horizontalLabels = [ "left", "right" ], verticalLabels = [ "top", "bottom" ], topLeft = {
    x:pctLeft,
    y:pctTop
   }, topRight = {
    x:pctLeft + pctWidth,
    y:pctTop
   }, bottomLeft = {
    x:pctLeft,
    y:pctTop + pctHeight
   }, bottomRight = {
    x:pctLeft + pctWidth,
    y:pctTop + pctHeight
   }, center = {
    x:(topLeft.x + bottomRight.x) / 2,
    y:(topLeft.y + bottomRight.y) / 2
   }, horizontalIndex = gridBoundaries.indexOf(gridBoundaries.concat(center.x).sort()[1]), verticalIndex = gridBoundaries.indexOf(gridBoundaries.concat(center.y).sort()[1]), horizontalLabel = horizontalIndex === -1 ? "center" :horizontalLabels[horizontalIndex], verticalLabel = verticalIndex === -1 ? "center" :verticalLabels[verticalIndex];
   return [ verticalLabel + "-" + horizontalLabel, {
    top_left:topLeft,
    top_right:topRight,
    bottom_left:bottomLeft,
    bottom_right:bottomRight,
    center:center
   } ];
  };
  options = options || {};
  logging.tracking.startPlayerContext(this, options);
  if (typeof container === "string") {
   container = document.querySelector(container);
  }
  if (!container || typeof container !== "object" && !instanceOfElement(container)) {
   die("Missing container element");
   return;
  }
  if (!video) {
   die("Missing video");
   return;
  }
  source = video.get("source");
  if (!source) {
   die("Missing source");
   return;
  }
  sourceId = video.get("source_id");
  if (!sourceId) {
   die("Missing source_id");
   return;
  }
  if (!activePlayers) {
   document.addEventListener("keydown", captureBackKeys, true);
  }
  activePlayers++;
  duration = video.get("duration");
  startEditMode = options.edit;
  environment.register("render", function(scope, str, encode) {
   return str.replace(utils.regex.templateVarsRegex(), function(match, name, def) {
    var value = scope.get(name) || def || "";
    if (encode && value) {
     value = encodeURIComponent(value);
    }
    return value;
   });
  });
  environment.register("templateVars", function(scope, str, a) {
   var array = a || [];
   str.replace(utils.regex.templateVarsRegex(), function(match, name) {
    var i = array.indexOf(name);
    if (i < 0) {
     array.push(name);
    }
   });
   return array;
  });
  (function() {
   var oldUserId, newUserId;
   try {
    oldUserId = parseInt(window.localStorage.hapyakUserId, 10) || 0;
    newUserId = window.HapyakApp.currentUser && window.HapyakApp.currentUser.get("id") || 0;
    if (oldUserId !== newUserId) {
     Popcorn.forEach(window.localStorage, function(val, key) {
      if (utils.startsWith.call(key, "hapyak-env")) {
       window.localStorage.removeItem(key);
      }
     });
     if (newUserId) {
      window.localStorage.setItem("hapyakUserId", newUserId);
     } else if (oldUserId) {
      window.localStorage.removeItem("hapyakUserId");
     }
    }
   } catch (localStorageError) {}
  })();
  Environment.localStorage.move(/^hapyak-env\/track-([0-9]+)($|\/)/, "hapyak-env/track-$1-system/track-$1");
  environment.load("hapyak-env", "");
  environment.set("playerId", uuid(), true);
  environment.set("tracking", moduleConfig.tracking || {}, true);
  environment.set("context", moduleConfig.context || {}, true);
  environment.set("configuration", playerConfig || {}, true);
  environment.set("hapyakCSRFToken", moduleConfig.csrfToken, true);
  environment.set("hapyakAPIKey", moduleConfig.apiKey, true);
  function updateAuth(auth) {
   var partnerAuth = auth.partner;
   if (!_.isEmpty(partnerAuth)) {
    environment.set("hapyakPartnerAuth", partnerAuth, true);
    _.each([ "userId", "username", "email" ], function(field) {
     if (partnerAuth[field]) {
      environment.set(field, partnerAuth[field], true);
     }
    });
   }
   emit("authchange", true, partnerAuth);
  }
  updateAuth(hapyak.auth());
  hapyak.addEventListener("auth", updateAuth);
  this.play = function() {
   if (popcorn) {
    popcorn.play();
   } else {
    queuedPlaying = true;
   }
  };
  this.pause = function() {
   if (popcorn) {
    popcorn.pause();
   } else {
    queuedPlaying = false;
   }
  };
  this.currentTime = function(time) {
   var that = this;
   function deferCurrentTimeUntilPlay() {
    popcorn.off("play", deferCurrentTimeUntilPlay);
    if (opts.autoplay) {
     popcorn.currentTime(time);
     return;
    }
    popcorn.on("pause", deferCurrentTimeUntilPause);
    popcorn.pause();
   }
   function deferCurrentTimeUntilPause() {
    popcorn.off("pause", deferCurrentTimeUntilPause);
    popcorn.currentTime(time);
   }
   if (!popcorn) {
    if (time) {
     this.on("loadedmetadata", function onLoadedMetaData() {
      that.off("loadedmetadata", onLoadedMetaData);
      if (!popcorn.paused) {
       popcorn.currentTime(time);
      } else {
       popcorn.on("play", deferCurrentTimeUntilPlay);
       popcorn.play();
      }
     });
    }
    return 0;
   }
   if (time === undefined || time > popcorn.duration() || time < 0) {
    return popcorn.currentTime();
   }
   return popcorn.currentTime(time);
  };
  this.elapsedTime = function() {
   if (!popcorn) {
    return 0;
   }
   return accumulatedViewTime + Math.max(popcorn.currentTime(), currentViewSection.end) - currentViewSection.start;
  };
  this.mediaType = function() {
   return popcorn && popcorn.media && popcorn.media.mediaType;
  };
  this.duration = function() {
   if (!popcorn) {
    return NaN;
   }
   return popcorn.duration();
  };
  this.paused = function() {
   if (popcorn) {
    return popcorn.paused();
   }
   return !queuedPlaying;
  };
  this.aspectRatio = function(newAspectRatio) {
   var ratio;
   if (newAspectRatio && newAspectRatio > 0) {
    options.aspectRatio = newAspectRatio;
   }
   if (options.aspectRatio === "widescreen") {
    return 16 / 9;
   }
   ratio = parseFloat(options.aspectRatio);
   if (ratio > 0) {
    return ratio;
   }
   if (wrapper && wrapper.videoHeight) {
    return wrapper.videoWidth / wrapper.videoHeight;
   }
   if (playerConfig.aspectRatioOverride === "widescreen" || video.get("aspect_ratio") === "widescreen") {
    return 16 / 9;
   }
   ratio = parseFloat(video.get("aspect_ratio"));
   if (ratio > 0) {
    return ratio;
   }
   return 4 / 3;
  };
  this.width = function() {
   return wrapper.width;
  };
  this.height = function() {
   return wrapper.height;
  };
  this.videoWidth = function() {
   return wrapper.videoWidth;
  };
  this.videoHeight = function() {
   return wrapper.videoHeight;
  };
  this.pluginData = function() {
   return wrapper.pluginData;
  };
  this.volume = function(volume) {
   if (volume !== undefined) {
    return popcorn.volume(volume);
   }
   return popcorn.muted() ? 0 :popcorn.volume();
  };
  this.muted = function() {
   return popcorn.muted();
  };
  this.mute = function(muted) {
   muted = muted || muted === undefined ? true :false;
   popcorn.mute(muted);
  };
  this.seekAnnotation = function(id, offset) {
   function seek(annotation) {
    var props, time;
    function seekWhenReady() {
     if (time < popcorn.duration()) {
      popcorn.currentTime(time);
     }
     popcorn.off("durationchange", seekWhenReady);
    }
    if (annotation instanceof model.Comment) {
     props = annotation.get("properties");
     if (!props || !popcorn) {
      targetAnnotation = annotation;
      return;
     }
     if (props.popcorn && props.popcorn.start) {
      time = props.popcorn.start;
      if (offset) {
       time = time - offset;
      }
      if (popcorn.duration() > time) {
       popcorn.currentTime(time);
      } else {
       popcorn.on("durationchange", seekWhenReady);
      }
     }
     targetAnnotation = null;
    }
   }
   var i;
   if (typeof id === "object") {
    return seek(id);
   }
   for (i in popcornAnnotations) {
    if (popcornAnnotations.hasOwnProperty(i)) {
     if (popcornAnnotations[i].get("id") === id) {
      seek(popcornAnnotations[i]);
     }
    }
   }
  };
  this.fullscreen = function(fs) {
   if (!wrapper) {
    if (fs !== undefined) {
     queuedFullscreen = fs;
    }
    return queuedFullscreen;
   }
   if (fs === undefined) {
    return isFullscreen();
   }
   if (fs) {
    if (fullscreenEnabled) {
     if (container.requestFullScreen) {
      container.requestFullScreen();
      return;
     }
     if (container.mozRequestFullScreen) {
      container.mozRequestFullScreen();
      return;
     }
     if (container.msRequestFullscreen) {
      container.msRequestFullscreen();
      return;
     }
     if (container.webkitRequestFullScreen) {
      if (/chrome/i.test(navigator.userAgent) || !/safari/i.test(navigator.userAgent)) {
       container.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
      } else {
       container.webkitRequestFullScreen();
      }
      return;
     }
    }
    fullScreenChange(null, true);
    return;
   } else if (fullscreenEnabled) {
    if (document.cancelFullScreen) {
     document.cancelFullScreen();
     return;
    }
    if (document.mozCancelFullScreen) {
     document.mozCancelFullScreen();
     return;
    }
    if (document.webkitCancelFullScreen) {
     document.webkitCancelFullScreen();
     return;
    }
    if (document.msExitFullscreen) {
     document.msExitFullscreen();
     return;
    }
   }
   fullScreenChange(null);
  };
  this.resize = resize;
  this.controls = function(show) {
   if (!wrapper) {
    showControls = show && showControls !== "play" ? "edit" :show;
    return;
   }
   if (show !== undefined && elements.controlBar) {
    if (show && !showControls) {
     drawTimeline();
    }
    showControls = show;
    if (showControls === "play" || showControls === "viewer") {
     elements.groupCreate.style.display = "none";
    } else {
     elements.groupCreate.style.display = "";
    }
    elements.controlBar.style.display = show ? "" :"none";
    resize();
    updateMarkers();
   }
   return showControls;
  };
  this.showCapContent = function(content, timeout) {
   if (!elements || !elements.trackCapContent) {
    return;
   }
   if (instanceOfElement(content) || instanceOfElement("DocumentFragment") || instanceOfElement(content, "Text") && instanceOfElement(content)) {
    elements.trackCapContent.innerHTML = "";
    elements.trackCapContent.appendChild(content);
   } else if (content) {
    elements.trackCapContent.innerHTML = content;
   }
   addClass(elements.trackCapContent, "visible");
   if (timeout) {
    setTimeout(function() {
     removeClass(elements.trackCapContent, "visible");
    }, timeout);
   }
  };
  this.loadTrack = function(track, opts) {
   function onLoadComments(annotations) {
    if (!track || activeTrack !== track) {
     return;
    }
    queuedAnnotations = annotations;
    queuedTrackOpts = opts;
    if (wrapper) {
     loadQueuedAnnotations();
    }
   }
   if (activeTrack === track) {
    if (opts && opts.callback) {
     opts.callback();
    }
    return;
   }
   unloadTrack();
   if (!track) {
    setLinks();
    if (activeTrack) {
     emit("changeTrack", false, track);
    }
    return;
   }
   logging.info("player: loading track #" + track.get("id"));
   activeTrack = track;
   trackSystemScope = environment.scope("track-" + track.get("id") + "-system");
   trackSystemScope.set("playerType", options.playerType, true);
   trackSystemScope.set("playlistId", options.playlistId, true);
   trackSystemScope.set("projectId", options.projectId, true);
   trackSystemScope.set("trackId", track.get("id"), true);
   trackSystemScope.set("trackEditPermission", activeTrack.hasPermission("edit"), true);
   trackSystemScope.set("annotationsLoaded", false, true);
   environment.load("hapyak-env", "track-" + track.get("id") + "-system/track-" + track.get("id"));
   trackScope = trackSystemScope.scope("track-" + track.get("id"));
   trackScope.observe(trackDataObserver);
   trackDataObserver();
   setLinks();
   if (popcorn) {
    popcorn.options.sharing.url = getVideoLink();
   }
   if (opts && opts.comments) {
    logging.info("loading comments from passed in options");
    onLoadComments(opts.comments);
   } else {
    logging.info("querying server for comments for track " + track.get("id"));
    model.Comment.find({
     track:track.get("id"),
     limit:500
    }).onLoad(onLoadComments);
   }
  };
  this.createTrack = function(data, callback) {
   function createEmptyTrack(d) {
    var track, title, data = d && typeof d === "object" || {};
    title = data.title || "";
    unloadTrack();
    track = model.Track.createRecord({
     owner:window.HapyakApp.currentUser,
     video:video,
     title:title,
     created:new Date(),
     modified:new Date(),
     privacy:"public"
    });
    dao.store.commit();
    activeTrack = track;
    emit("createTrack", false, track);
    unlockEditor("createTrack");
    me.editMode(true);
    if (typeof callback === "function") {
     callback.call(me, track);
    }
    return track;
   }
   if (!window.HapyakApp.currentUser) {
    emit("createError", false, "no-user");
    die("Do not have permission to create new track");
    return false;
   }
   lockEditor("createTrack");
   return createEmptyTrack(data);
  };
  this.editTrack = function(data, callback) {
   var me = this, validEdit = false;
   if (!window.HapyakApp.currentUser) {
    emit("createError", false, "no-user");
    die("Do not have permission to edit track");
    return false;
   }
   if (!activeTrack) {
    emit("createError", false, "no-active-track");
    die("There is no active track to edit");
    return false;
   }
   if (typeof data.title === "string") {
    activeTrack.set("title", data.title);
    validEdit = true;
   }
   if (typeof data.description === "string") {
    activeTrack.set("description", data.description);
    validEdit = true;
   }
   if (validEdit) {
    activeTrack.onSave(function() {
     emit("editTrack", false, activeTrack);
     if (typeof callback === "function") {
      callback.call(me, activeTrack);
     }
    });
    dao.store.commit();
   }
   return activeTrack;
  };
  this.copyTrack = function(callback) {
   var me = this, track;
   if (!window.HapyakApp.currentUser) {
    emit("createError", false, "no-user");
    die("Do not have permission to create new track");
    return false;
   }
   if (!activeTrack) {
    emit("createError", false, "no-active-track");
    die("There is no active track to copy from");
    return false;
   }
   track = model.Track.createRecord({
    copied_from:activeTrack.get("id")
   });
   track.onSave(function() {
    emit("createTrack", false, track);
    me.loadTrack(track);
    unlockEditor("copyTrack");
    me.editMode(true);
    if (typeof callback === "function") {
     callback.call(me, track);
    }
   });
   dao.store.commit();
   lockEditor("copyTrack");
   return track;
  };
  this.deleteTrack = function(callback) {
   var me = this, trackId;
   if (!window.HapyakApp.currentUser) {
    emit("createError", false, "no-user");
    die("Do not have permission to delete track");
    return false;
   }
   if (!activeTrack) {
    emit("createError", false, "no-active-track");
    die("There is no active track to delete");
    return false;
   }
   trackId = activeTrack.get("id");
   lockEditor("deleteTrack");
   activeTrack.onDelete(function() {
    emit("deleteTrack", false, trackId);
    unloadTrack();
    unlockEditor("deleteTrack");
    me.editMode(false);
    if (typeof callback === "function") {
     callback.call(me, trackId);
    }
   });
   activeTrack.deleteRecord();
   dao.store.commit();
   return trackId;
  };
  this.annotations = function() {
   var array = [];
   function sort(a, b) {
    function ifNum(num, alt) {
     if (isNaN(num)) {
      return alt;
     }
     return num;
    }
    var aStart, bStart, aEnd, bEnd;
    aStart = a.get("properties.popcorn") || a.get("properties");
    aStart = ifNum(aStart && ifNum(aStart.start, aStart.start_time), a.get("start_time"));
    bStart = b.get("properties.popcorn") || b.get("properties");
    bStart = ifNum(bStart && ifNum(bStart.start, bStart.start_time), b.get("start_time"));
    if (aStart === bStart) {
     aEnd = a.get("properties.popcorn") || a.get("properties");
     aEnd = ifNum(aEnd && ifNum(aEnd.end, aEnd.end_time), a.get("end_time"));
     bEnd = b.get("properties.popcorn") || b.get("properties");
     bEnd = ifNum(bEnd && ifNum(bEnd.end, bEnd.end_time), b.get("end_time"));
     return aEnd - bEnd;
    }
    return aStart - bStart;
   }
   Popcorn.forEach(popcornAnnotations, function(annotation) {
    array.push(annotation);
   });
   array.sort(sort);
   return array;
  };
  this.annotations.get = function(annotationId) {
   var annotation = annotationsById[annotationId], popcornId = popcornIdLookup[annotationId];
   if (annotation && popcornId) {
    return {
     annotationId:parseInt(annotationId, 10),
     trackId:activeTrack.get("id"),
     properties:Popcorn.extend({}, annotation.getCustomProperty("popcorn") || annotation.get("properties")),
     type:annotation.get("type"),
     created:annotation.get("created").valueOf(),
     modified:annotation.get("modified").valueOf(),
     writable:!transientAnnotations[popcornId]
    };
   }
   return null;
  };
  this.annotations.all = function(type) {
   var annotationId, annotation, single, result = [];
   function sort(a, b) {
    if (a.properties.start === b.properties.start) {
     return a.properties.end - b.properties.end;
    }
    return a.properties.start - b.properties.start;
   }
   if (activeTrack) {
    for (annotationId in annotationsById) {
     if (annotationsById.hasOwnProperty(annotationId)) {
      annotation = annotationsById[annotationId];
      if (!type || type === annotation.get("type")) {
       single = me.annotations.get(annotationId);
       if (single) {
        result.push(single);
       }
      }
     }
    }
   }
   result.sort(sort);
   return result;
  };
  this.annotations.create = function(type, properties, callback) {
   if (!pluginsEnabled[type]) {
    throw new Error("annotations.create: Unsupported plugin type " + type);
   }
   delete properties.dataId;
   delete properties.id;
   delete properties._id;
   delete properties.annotationId;
   if (properties.end) {
    properties._duration = properties.end - properties.start;
   }
   provisionAnnotationType(type, function() {
    createButtonClick(annotationProfiles[type], properties, function(id, annotation) {
     if (typeof callback === "function") {
      callback(me.annotations.get(annotation.get("id")));
     }
    });
   });
   return properties;
  };
  this.annotations.update = function(id, properties, callback) {
   var popcornId = popcornIdLookup[id], writable, trackEvent, annotation, result;
   if (!id) {
    throw new Error("annotations.update: Annotation ID required");
   }
   if (!popcornId) {
    throw new Error("annotations.update: Annotation '" + id + "' not found");
   }
   writable = !transientAnnotations[popcornId];
   if (!writable) {
    throw new Error("annotations.update: Unable to modify annotation " + id);
   }
   if (!properties) {
    result = me.annotations.get(id);
    if (typeof callback === "function") {
     callback(result);
    }
    return result;
   }
   annotation = annotationsById[id];
   trackEvent = popcorn.getTrackEvent(popcornId);
   delete properties.dataId;
   delete properties.id;
   delete properties._id;
   delete properties.annotationId;
   if (!properties.startTimeValue && properties.start) {
    properties.startTimeValue = properties.start;
   }
   if (!properties.durationValue && properties._duration) {
    properties.durationValue = properties._duration;
   }
   Popcorn.extend(trackEvent, properties);
   if (typeof callback === "function") {
    if (dao.store.isDirty) {
     annotation.onSave(function() {
      callback(me.annotations.get(id));
     });
    } else {
     setTimeout(function() {
      callback(me.annotations.get(id));
     }, 100);
    }
   }
   popcorn[annotation.get("type")](popcornId, trackEvent);
   result = me.annotations.get(id);
   return result;
  };
  this.annotations.remove = function(id, callback) {
   var popcornId = popcornIdLookup[id], writable, annotation = annotationsById[id];
   if (!id) {
    throw new Error("annotations.remove: Annotation ID required");
   }
   if (!popcornId || !annotation) {
    throw new Error("annotations.remove: Annotation '" + id + "' not found");
   }
   writable = !transientAnnotations[popcornId];
   if (!writable) {
    throw new Error("annotations.remove: Unable to remove annotation " + id);
   }
   if (typeof callback === "function") {
    annotation.onDelete(function() {
     callback(id);
    });
   }
   popcorn.removeTrackEvent(popcornId);
   return id;
  };
  this.annotations.types = function(callback) {
   var result = {}, count = Object.keys(annotationProfiles).length;
   if (!callback) {
    return;
   }
   Popcorn.forEach(annotationProfiles, function(val, key) {
    if (pluginsEnabled[key]) {
     provisionAnnotationType(key, function() {
      var profile, type, d;
      profile = annotationProfiles[key];
      type = {
       id:key,
       icon:profile.icon || "",
       title:profile.title || key,
       enabled:!!pluginsEnabled[key],
       defaults:{}
      };
      if (profile.defaults) {
       for (d in profile.defaults) {
        if (profile.defaults.hasOwnProperty(d) && typeof profile.defaults[d] !== "function" && !(profile.defaults[d] instanceof Element)) {
         type.defaults[d] = profile.defaults[d];
         if (type.defaults[d] === Infinity) {
          type.defaults[d] = Number.MAX_VALUE;
         } else if (type.defaults[d] === -Infinity) {
          type.defaults[d] = -Number.MAX_VALUE;
         }
        }
       }
      }
      result[key] = type;
      count--;
      if (!count) {
       callback(result);
      }
     });
    } else {
     count--;
    }
   });
  };
  this.annotations.normalize = function(annotationId, key, value, dictionary, callback) {
   var annotation = annotationsById[annotationId], popcornId, trackEvent, properties, profile, result;
   if (annotationId && typeof callback === "function") {
    if (annotation) {
     popcornId = popcornIdLookup[annotationId];
     trackEvent = popcorn.getTrackEvent(popcornId);
     profile = annotationProfiles[trackEvent._natives.type];
     properties = profile && Popcorn.extend({}, trackEvent, dictionary);
    } else if (pluginsEnabled[annotationId]) {
     profile = annotationProfiles[annotationId];
     properties = dictionary;
    }
    if (profile) {
     if (profile.normalize[key] || profile.normalizeAny) {
      if (profile.normalize[key]) {
       result = profile.normalize[key].call(me, value, properties, callback);
       if (result !== undefined && result !== null) {
        callback(result);
       }
      } else {
       result = profile.normalizeAny.call(me, key, value, properties, callback);
       if (result !== undefined && result !== null) {
        callback(result);
       }
      }
     }
    } else {
     callback(false);
    }
   }
   return null;
  };
  this.annotations.focus = function(annotationId, callback) {
   var popcornId = popcornIdLookup[annotationId], trackEvent, type, writable;
   if (!annotationId) {
    if (editor) {
     editor.done();
    }
    return;
   }
   if (!popcornId) {
    throw new Error("annotations.focus: Annotation '" + annotationId + "' not found");
   }
   writable = !transientAnnotations[popcornId];
   if (!writable) {
    throw new Error("annotations.focus: Unable to edit annotation " + annotationId);
   }
   if (!me.editMode(true)) {
    throw new Error("annotations.focus: Do not have permission to edit");
   }
   trackEvent = popcorn.getTrackEvent(popcornId);
   type = trackEvent && trackEvent._natives && trackEvent._natives.type;
   if (!type || !pluginsEnabled[type]) {
    throw new Error("annotations.focus: Unable to edit annotation " + annotationId);
   }
   getEditor(function() {
    editor.edit(popcornId);
    if (typeof callback === "function") {
     callback(annotationId);
    }
   });
  };
  this.annotations.blur = function(annotationId) {
   var popcornId = popcornIdLookup[annotationId];
   if (editor) {
    editor.done(popcornId || null);
   }
  };
  this.showTrackInfo = function() {
   if (!updateTrackInfo()) {
    return;
   }
   addClass(elements.trackInfo, "visible");
   if (showTrackInfoTimeout) {
    clearTimeout(showTrackInfoTimeout);
   }
   showTrackInfoTimeout = setTimeout(function() {
    if (elements.trackInfo) {
     removeClass(elements.trackInfo, "visible");
    }
   }, 2e3);
  };
  this.editMode = function(show) {
   if (show === undefined) {
    return editMode;
   }
   show = !!show;
   if (show && (!activeTrack || !window.HapyakApp || !activeTrack.hasPermission("edit"))) {
    show = false;
   }
   if (editMode === show) {
    return editMode;
   }
   editMode = show;
   startEditMode = startEditMode && show;
   this.resetVariables();
   environment.set("editMode", editMode, true);
   if (editMode) {
    if (showAnnotations) {
     updateAnnotationDisplay();
    } else {
     this.showAnnotations(true);
    }
    getEditor(function() {
     editor.activate();
     addClass(elements.annotationContainer, "hapyak-editing");
     addClass(elements.annotationNoscaleContainer, "hapyak-editing");
    });
   } else if (editor) {
    editor.done();
    editor.deactivate();
    removeClass(elements.annotationContainer, "hapyak-editing");
    removeClass(elements.annotationNoscaleContainer, "hapyak-editing");
    updateAnnotationDisplay();
   }
   if (elements.watermark) {
    elements.watermark.style.display = editMode ? "none" :"block";
   }
   updateModeSwitch();
   return editMode;
  };
  this.showAnnotations = function(show) {
   var method;
   if (show === undefined) {
    return showAnnotations;
   }
   show = !!show;
   if (showAnnotations === show) {
    return;
   }
   showAnnotations = show;
   if (!showAnnotations) {
    me.editMode(false);
   }
   method = show ? "enable" :"disable";
   Popcorn.forEach(Popcorn.registryByName, function(obj, plugin) {
    var i = 0, l, trackEvents, trackEvent, currentTime = popcorn.currentTime();
    trackEvents = popcorn.data.running[plugin];
    if (method === "disable") {
     popcorn.emit("clearactivepauses");
    }
    updateAnnotationDisplay();
    if (trackEvents) {
     for (l = trackEvents.length; i < l; i++) {
      trackEvent = trackEvents[i];
      if (currentTime >= trackEvent.start && currentTime <= trackEvent.end && method === "enable") {
       addClass(trackEvent.container, "active");
      } else {
       removeClass(trackEvent.container, "active");
      }
     }
    }
   });
   updateModeSwitch();
   return showAnnotations;
  };
  this.updateTrackEvent = function(annotation) {
   var properties, popcornId = popcornIdLookup[annotation.get("id")], trackEvent;
   if (popcornId) {
    trackEvent = popcorn.getTrackEvent(popcornId);
    properties = annotation.getCustomProperty("popcorn");
    Popcorn.extend(trackEvent, properties);
    popcorn[annotation.get("type")](popcornId, trackEvent);
   }
  };
  this.videoViewed = function() {
   var sum = 0;
   if (!duration) {
    return 0;
   }
   Popcorn.forEach(sectionsViewed, function(section) {
    sum += section.end - section.start;
   });
   return sum / duration;
  };
  this.videoViewedFromStart = function() {
   var section;
   if (!duration || !sectionsViewed.length) {
    return 0;
   }
   section = sectionsViewed[0];
   return (section.end - section.start) / duration;
  };
  this.resetVariables = function() {
   if (activeTrack && trackScope) {
    Popcorn.forEach(trackScope.keys(), function(key) {
     trackScope.clear(key, true);
    });
    trackScope.save("hapyak-env");
    Popcorn.forEach(popcornAnnotations, function(annotation, id) {
     var scope = getScope(id), keys = scope.keys(), i;
     for (i = 0; i < keys.length; i++) {
      scope.clear(keys[i], true);
     }
     scope.save("hapyak-env");
    });
   }
  };
  this.getData = function(name) {
   var obj, i, n, key;
   if (name) {
    return trackScope.get(name);
   }
   obj = {};
   for (i = 0, n = trackScope.keys.count; i < n; i++) {
    key = trackScope.keys(i);
    obj[key] = _.clone(trackScope.get(key));
   }
   return obj;
  };
  this.setData = function(name, value) {
   if (name && typeof name === "object") {
    value = name;
    name = null;
   }
   if (name) {
    if (value === undefined) {
     environment.clear(name, true);
    } else {
     environment.set(name, value, true);
    }
    return;
   }
   if (value && typeof value === "object") {
    Popcorn.forEach(value, function(val, name) {
     environment.set(name, val, true);
    });
   }
  };
  this.lockEditor = lockEditor;
  this.unlockEditor = unlockEditor;
  this.addClass = function(value) {
   if (container && typeof value === "string" && value.length) {
    addClass(container, value.indexOf("hapyak-") === 0 ? value :"hapyak-" + value);
   }
  };
  this.removeClass = function(value) {
   if (container && typeof value === "string" && value.length) {
    removeClass(container, value.indexOf("hapyak-") === 0 ? value :"hapyak-" + value);
   }
  };
  this.on = function(hook, callback) {
   var list;
   if (typeof hook !== "string" || typeof callback !== "function") {
    return;
   }
   list = listeners[hook];
   if (!list) {
    list = listeners[hook] = [];
   }
   if (list.indexOf(callback) < 0) {
    list.push(callback);
   }
  };
  this.off = function(hook, callback) {
   var list, i;
   if (typeof hook !== "string" || typeof callback !== "function") {
    return;
   }
   list = listeners[hook];
   if (!list) {
    return;
   }
   i = list.indexOf(callback);
   if (i >= 0) {
    list.splice(i, 1);
   }
  };
  this.setRemotes = function(items) {
   remotes = items;
   if (editor) {
    editor.setting("remote", "remotes", remotes || []);
   }
  };
  this.destroy = function(save, callback) {
   var fn;
   function nop() {}
   function cleanElements() {
    var key, element, elementKeys = [ "controlBar", "playBox", "annotationContainer", "annotationNoscaleContainer", "topLeftContainer", "editorContainer", "overlayContainer", "watermark", "rootBox" ];
    while (elementKeys.length) {
     key = elementKeys.shift();
     element = elements[key];
     if (element && element.parentNode) {
      element.parentNode.removeChild(element);
     }
    }
    for (key in elements) {
     if (elements.hasOwnProperty(key)) {
      delete elements[key];
     }
    }
   }
   destroyed = true;
   logging.tracking.endPlayerContext();
   hapyak.removeEventListener("auth", updateAuth);
   emitQueue.splice(0);
   me.fullscreen(false);
   if (editor) {
    if (save) {
     editor.done();
    }
    editor.destroy();
   }
   clearTimeout(resizeTimeout);
   if (autoResizeTimer) {
    clearInterval(autoResizeTimer);
   }
   window.removeEventListener("resize", resize, false);
   window.removeEventListener("orientationchange", orientationChange, false);
   document.removeEventListener(visibilityEvent, visibilityChange, false);
   if (fullscreenEnabled) {
    document.removeEventListener("fullscreenchange", fullScreenChange, false);
    document.removeEventListener("mozfullscreenchange", fullScreenChange, false);
    document.removeEventListener("webkitfullscreenchange", fullScreenChange, false);
    document.removeEventListener("MSFullscreenChange", fullScreenChange, false);
   }
   unloadTrack();
   if (container.style) {
    removeClass(container, "hapyak-player");
    removeClass(container, "hapyak-embed");
    removeClass(container, "hapyak-remote");
    removeClass(container, "hapyak-" + (options.edit ? "edit" :"view") + "-mode");
   }
   removeProvisioningClasses(configuration.provisioning, container);
   for (fn in this) {
    if (this.hasOwnProperty(fn) && typeof this[fn] === "function") {
     this[fn] = nop;
    }
   }
   activePlayers = Math.max(0, activePlayers - 1);
   if (!activePlayers) {
    document.removeEventListener("keydown", captureBackKeys, true);
   }
   if (popcorn) {
    popcorn.destroy();
   }
   if (timelineTouch) {
    timelineTouch.remove();
   }
   if (volumeTouch) {
    volumeTouch.remove();
   }
   if (elements && (elements.videoContainer || elements.rootBox)) {
    safeTry(function() {
     if (elements.videoContainer && elements.videoContainer.firstChild && elements.videoContainer.firstChild.tagName === "IFRAME") {
      elements.videoContainer.firstChild.src = "";
      setTimeout(function() {
       elements.videoContainer.innerHTML = "";
       cleanElements();
       if (callback) {
        callback();
       }
      }, 10);
      return;
     }
     if (wrapper) {
      if (wrapper._util && wrapper._util.destroy) {
       wrapper._util.destroy();
      } else {
       wrapper.src = "";
       if (wrapper.load) {
        wrapper.load();
       }
      }
     }
     if (elements.videoContainer) {
      elements.videoContainer.innerHTML = "";
     }
     cleanElements();
     if (callback) {
      callback();
     }
    });
   } else {
    if (elements) {
     cleanElements();
    }
    if (callback) {
     callback();
    }
   }
  };
  this.outerContainer = function() {
   if (!popcorn || !popcorn.media) {
    return;
   }
   return popcorn.media.outerContainer;
  };
  this.dispatchSkeletonEvent = function(eventName, data) {
   if (embedUtils.dotget(popcorn, "media._util.events." + eventName)) {
    popcorn.media._util.events[eventName](data);
   }
  };
  document.addEventListener(visibilityEvent, visibilityChange, false);
  if (options.variables) {
   this.setData(null, options.variables);
  }
  playerType = wrappers.detect(container, options.playerType || source) || options.playerType || source;
  if (playerType) {
   playerType = playerType.toLowerCase();
  }
  if (!playerType || wrappers[playerType] || playerType === "html5") {
   loadVideoWrapper();
  } else {
   require([ "player.profile." + playerType ], loadVideoWrapper, function(err) {
    logging.captureException(err);
    die("Unable to load player: " + playerType);
   });
  }
 }
 Popcorn.filter("dataId", "", function(name, options, next, node) {
  options.dataId = node.virtualEventId;
  next(options);
 });
 Popcorn.plugin.debug = debug;
 Popcorn.dom.debug = debug;
 requestAnimationFrame = function() {
  var lastTime = 0;
  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
   var currTime, timeToCall, id;
   function timeoutCallback() {
    callback(currTime + timeToCall);
   }
   currTime = new Date().getTime();
   timeToCall = Math.max(0, 16 - (currTime - lastTime));
   id = window.setTimeout(timeoutCallback, timeToCall);
   lastTime = currTime + timeToCall;
   return id;
  };
 }();
 if (document.hidden !== undefined) {
  hiddenProperty = "hidden";
  visibilityEvent = "visibilitychange";
 } else if (document.webkitHidden !== undefined) {
  hiddenProperty = "webkitHidden";
  visibilityEvent = "webkitvisibilitychange";
 } else if (document.mozHidden !== undefined) {
  hiddenProperty = "mozHidden";
  visibilityEvent = "mozvisibilitychange";
 } else if (document.msHidden !== undefined) {
  hiddenProperty = "msHidden";
  visibilityEvent = "msvisibilitychange";
 }
 Popcorn.forEach(aTypeAliases, function(aType, alias) {
  if (pluginsEnabled[alias]) {
   pluginsEnabled[aType] = true;
  } else if (pluginsEnabled[aType]) {
   pluginsEnabled[alias] = true;
  }
 });
 return HapyakPlayer;
});

define("viewer", [ "require", "module", "configuration", "model", "dao", "utils.embed", "utils.sanitizeparams", "hapyak.player", "cookie", "logging", "raven.hapyak", "lodash.noconflict", "ember.noconflict" ], function(require, module, configuration, model, dao, utils, sanitizeParams, HapyakPlayer, cookie, logging, Raven, _) {
 var host, href, search, tmpElement, moduleConfig = module.config(), viewerEvents = {
  authchange:true,
  data:true,
  durationchange:true,
  load:true,
  loadannotations:true,
  setupannotations:true,
  loadedmetadata:true,
  pause:true,
  play:true,
  conversion:true
 }, hapyakRemote, dotget = utils.dotget, trackingVariables, auth = hapyak.auth(), userId, username, email, queryParamContext;
 try {
  if (window.top && window.top.location) {
   host = window.top.location.host;
   href = window.top.location.href;
   search = window.top.location.search;
  }
 } catch (e) {}
 if (!href) {
  tmpElement = document.createElement("a");
  href = tmpElement.href = parent !== window ? document.referrer :window.location.host;
  host = tmpElement.host;
  search = tmpElement.search;
 }
 queryParamContext = utils.getQueryParams(search, "hapyak_");
 trackingVariables = {
  Embedded:true,
  Context:"Viewer",
  Host:host,
  Href:href
 };
 userId = auth.partner.userId;
 username = auth.partner.username;
 email = auth.partner.email;
 if (!email) {
  email = dotget(moduleConfig, dotget(configuration, "auth.email")) || queryParamContext.email;
 }
 if (!username) {
  username = dotget(moduleConfig, dotget(configuration, "auth.username")) || queryParamContext.username || email;
 }
 if (!userId) {
  userId = dotget(moduleConfig, dotget(configuration, "auth.userId")) || queryParamContext.userId || username;
 }
 auth = hapyak.auth({
  partner:{
   userId:userId,
   username:username,
   email:email
  }
 });
 if (configuration.group) {
  trackingVariables["Group ID"] = configuration.group.id;
  if (configuration.group.name) {
   trackingVariables["Group Name"] = configuration.group.name;
  }
  if (configuration.group.parent) {
   trackingVariables["Group Parent ID"] = configuration.group.parent;
  }
 }
 logging.register(trackingVariables);
 logging.registerPartnerProperties(moduleConfig.tracking);
 logging.registerPartnerProperties(moduleConfig.plugins);
 logging.registerPartnerProperties(queryParamContext);
 logging.track("Load");
 if (auth.user) {
  window.HapyakApp = Ember.Object.create();
  dao.store.load(model.User, auth.user);
  dao.store.find(model.User, auth.user.id).onLoad(function(user) {
   window.HapyakApp.set("currentUser", user);
   logging.tracking.startUserContext(user);
   if (typeof window.postMessage === "function" && window.parent) {
    window.parent.postMessage(JSON.stringify({
     context:"hapyak",
     callback:"loadcurrentuser",
     userId:user.get("id"),
     username:user.get("username")
    }), "*");
   }
  });
 }
 utils.controlStyle(true, true);
 function HapyakViewer(config, project, video, track, comments) {
  if (project) {
   logging.tracking.startProjectContext(project);
  }
  logging.tracking.startVideoContext(video);
  if (track) {
   logging.tracking.startTrackContext(track);
  }
  var player = new HapyakPlayer(config.player, video, sanitizeParams.viewer(config, {
   annotationSources:config.plugins && config.plugins.annotationSources,
   remotes:config.plugins && config.plugins.remote && config.plugins.remote.items
  })), me = this, asyncEventQueue = [], listeners = {}, key, remoteQueue = [], remotes = [];
  function nextAsync() {
   var fn;
   if (asyncEventQueue.length) {
    fn = asyncEventQueue.shift();
    fn();
   }
  }
  function fireAsyncEvent(callbackName) {
   var args = Array.prototype.slice.call(arguments, 1);
   asyncEventQueue.push(function() {
    var i, list = listeners[callbackName];
    if (!list) {
     return;
    }
    for (i = 0; i < list.length; i++) {
     list[i].apply(me, args);
    }
   });
   setTimeout(nextAsync, 0);
  }
  function registerAsyncEvent(eventName, callbackName, arg) {
   player.on(eventName, function() {
    var args = Array.prototype.slice.call(arguments, 0);
    if (arg) {
     args.push(arg);
    }
    args.unshift(callbackName);
    fireAsyncEvent.apply(null, args);
   });
  }
  function remoteInstance(id, container, options) {
   var r = new hapyakRemote.HapyakRemote(id, container, options);
   remotes.push(r);
   return r;
  }
  function requireRemote(callback) {
   require([ "remote" ], function(remote) {
    hapyakRemote = remote;
    while (remoteQueue.length) {
     hapyakRemote.registerItem(remoteQueue.shift());
    }
    if (typeof callback === "function") {
     callback();
    }
   });
  }
  function remote(id, container, options, callback) {
   if (typeof options === "function") {
    callback = options;
    options = null;
   }
   if (hapyakRemote) {
    callback(remoteInstance(id, container));
   } else {
    requireRemote(function() {
     callback(remoteInstance(id, container));
    });
   }
  }
  function addEventListener(name, callback) {
   var list;
   if (!name || typeof name !== "string" || typeof callback !== "function") {
    return;
   }
   name = name.toLowerCase();
   if (!viewerEvents[name]) {
    return;
   }
   list = listeners[name];
   if (!list) {
    list = listeners[name] = [];
   }
   list.push(callback);
  }
  function removeEventListener(name, callback) {
   var list, i;
   if (!name || typeof name !== "string" || typeof callback !== "function") {
    return;
   }
   name = name.toLowerCase();
   if (!viewerEvents[name]) {
    return;
   }
   list = listeners[name];
   if (!list) {
    return;
   }
   i = list.indexOf(callback);
   if (i >= 0) {
    list.splice(i, 1);
   }
  }
  function messageHandler(event) {
   try {
    var data = JSON.parse(event.data);
    if (data.context === "hapyak" && data.event === "notifyResize") {
     player.resize(data.width, data.height, data.sync);
    }
   } catch (e) {}
  }
  registerAsyncEvent("changeTrack", "loadannotations", track);
  registerAsyncEvent("data", "data", track);
  if (config.resetVariables) {
   player.on("changeTrack", function() {
    player.resetVariables();
   });
  }
  fireAsyncEvent("load", this);
  player.loadTrack(track, {
   comments:Ember.A(comments),
   autoplay:config.autoplay
  });
  logging.tracking.playerView("Load");
  if (player.duration()) {
   fireAsyncEvent("durationchange");
   fireAsyncEvent("loadedmetadata");
  } else {
   registerAsyncEvent("loadedmetadata", "loadedmetadata");
  }
  registerAsyncEvent("authchange", "authchange");
  registerAsyncEvent("durationchange", "durationchange");
  registerAsyncEvent("play", "play", track);
  registerAsyncEvent("pause", "pause", track);
  registerAsyncEvent("conversion", "conversion");
  for (key in config) {
   if (config.hasOwnProperty(key) && key.substring(0, 2) === "on") {
    addEventListener(key.substring(2), config[key]);
   }
  }
  if (config.plugins && config.plugins.remote && config.plugins.remote.items) {
   config.plugins.remote.items.forEach(function(item) {
    if (hapyakRemote) {
     hapyakRemote.registerItem(item);
    } else {
     remoteQueue.push(item);
    }
    remotes.push(item);
   });
   if (config.plugins.remote.scan) {
    requireRemote(function() {
     var scannedRemotes = hapyakRemote.scan();
     while (scannedRemotes.length) {
      remotes.push(scannedRemotes.shift());
     }
     if (player) {
      player.setRemotes(remotes);
     }
    });
   }
  }
  this.getTrackId = function() {
   return track.get("id");
  };
  this.resize = function(width, height, sync) {
   player.resize(width, height, sync);
   return this;
  };
  this.trackList = function(element, options) {
   require([ "widget.controls.tracklist" ], function(widget) {
    widget.trackList(element, options, player, video);
   });
  };
  this.resetVariables = function() {
   player.resetVariables();
  };
  this.destroy = function() {
   if (track) {
    logging.tracking.endTrackContext();
   }
   logging.tracking.endVideoContext();
   if (config.projectId) {
    logging.tracking.endProjectContext();
   }
   asyncEventQueue.splice(0);
   while (remotes.length) {
    remotes.pop().destroy();
   }
   window.removeEventListener("message", messageHandler, false);
   player.destroy();
  };
  this.addEventListener = addEventListener;
  this.removeEventListener = removeEventListener;
  this.remote = remote;
  this.getData = function(name) {
   return player.getData(name);
  };
  this.setData = function(name, value) {
   return player.setData(name, value);
  };
  this.dispatchEvent = function(eventName, data) {
   player.dispatchSkeletonEvent(eventName, data);
  };
  this.play = function() {
   player.play();
  };
  this.pause = function() {
   player.pause();
  };
  this.fullscreen = function() {
   player.fullscreen(true);
  };
  Object.defineProperty(this, "currentTime", {
   configurable:false,
   enumerable:true,
   get:function() {
    return player.currentTime();
   },
   set:function(time) {
    player.currentTime(time);
   }
  });
  Object.defineProperty(this, "duration", {
   configurable:false,
   enumerable:true,
   get:function() {
    return player.duration();
   }
  });
  Object.defineProperty(this, "paused", {
   configurable:false,
   enumerable:true,
   get:function() {
    return player.paused();
   }
  });
  Object.defineProperty(this, "outerContainer", {
   configurable:false,
   enumerable:true,
   get:function() {
    return player.outerContainer();
   }
  });
  window.addEventListener("message", messageHandler, false);
 }
 HapyakViewer.prototype.toString = function() {
  return "[object HapyakViewer]";
 };
 var loadViewer = function(config) {
  if (config.css) {
   hapyak.asset.css(config.css);
  }
  if (configuration && configuration.player && configuration.player.css) {
   hapyak.asset.css(configuration.player.css);
  }
  var params = {};
  if (config.videoType) {
   params.source = config.videoType;
  }
  if (config.videoTitle) {
   params.video_title = config.videoTitle;
  }
  if (config.videoId) {
   params.source_id = config.videoId;
  }
  if (config.videoUrl) {
   params.source_url = config.videoUrl;
  }
  if (config.trackId) {
   params.track = config.trackId;
  } else if (config.track) {
   params.track = JSON.stringify(config.track);
  }
  if (config.projectId) {
   params.project = config.projectId;
  } else if (config.project) {
   params.project = JSON.stringify(config.project);
  }
  if (config.plugins) {
   if (config.variables === undefined) {
    config.variables = {};
   }
   config.variables.plugins = config.plugins;
  }
  if (config.controls) {
   config.controls = "viewer";
  }
  if (config.playerParameters) {
   params.source_parameters = JSON.stringify(config.playerParameters);
  }
  if (dotget(configuration, "player.nls")) {
   config.nls = configuration.player.nls;
  }
  if (!config.projectId && !config.trackId && !config.videoId && !config.videoUrl) {
   logging.error("Unable to create viewer. Add a videoId, videoUrl, projectId or trackId parameter.");
  } else {
   dao.store.findOne(model.ViewerSetup, params, function(viewerSetup) {
    var autoplay, comments, project, track, video, viewerInstance;
    if (viewerSetup) {
     project = viewerSetup.get("project"), video = viewerSetup.get("video"), track = viewerSetup.get("track"), comments = viewerSetup.get("comments");
     viewerInstance = new HapyakViewer(config, project, video, track, comments);
     if (!_.isEmpty(queryParamContext)) {
      viewerInstance.setData(queryParamContext);
      autoplay = queryParamContext["autoplay"];
      if (autoplay && autoplay === "true") {
       viewerInstance.play();
      }
      if (queryParamContext["seek"]) {
       viewerInstance.currentTime = parseInt(queryParamContext["seek"], 10);
      }
     }
     if (!video || !track) {
      logging.info("no annotations found");
     }
    } else {
     logging.info("no video/track/annotations found");
    }
   });
  }
 };
 return {
  load:function(config) {
   Raven.context(function() {
    loadViewer(config);
   });
  }
 };
});

define("partners.dailymotion", [ "require", "module" ], function(require, module, undefined) {
 var moduleConfig = module.config();
 function normalizeParameters(p) {
  if (!p.apiKey) {
   p.apiKey = moduleConfig.apiKey;
  }
  if (!p.environment) {
   p.environment = moduleConfig.environment;
  }
  if (!p.plugins) {
   p.plugins = moduleConfig.plugins;
  }
  return p;
 }
 return {
  viewer:function(p) {
   if (!p.videoType) {
    p.videoType = "dailymotion";
   }
   if (!p.playerType) {
    if (p.playerMode === "flash") {
     p.playerType = "dailymotioninternal";
    } else if (p.playerMode === "api") {
     p.playerType = "dailymotion";
    }
   }
   p = normalizeParameters(p);
   return hapyak.viewer(p);
  },
  editor:function(p) {
   if (!p.videoType) {
    p.videoType = "dailymotion";
   }
   p = normalizeParameters(p);
   return hapyak.editor(p);
  },
  externalEditor:function(player, container, p) {
   requirejs.config({
    context:"hapyak",
    paths:{
     lodash:"vendor/lodash.min",
     "app.edit.i18n":"api/sideeditor/i18n/i18n",
     "app.edit.i18n.translations":[ "api/sideeditor/i18n/lang/" + (p && p.lang || "en"), "api/sideeditor/i18n/lang/en" ],
     "app.edit.components":"api/sideeditor/components",
     "app.edit.ember.extend":"api/sideeditor/ember.extend",
     "app.edit.hapyak.api":"api/sideeditor/hapyak.api",
     "app.edit.hapyak.normalize":"api/sideeditor/hapyak.normalize",
     "app.edit.hapyak.repair":"api/sideeditor/hapyak.repair",
     "app.edit.mixins":"api/sideeditor/mixins",
     "app.edit.routes":"api/sideeditor/routes",
     "app.edit.spinner":"api/sideeditor/spinner",
     "app.edit.templates":hapyak.environment !== "dev" || !hapyak.debug ? "api/sideeditor/generated/precompiled" :"api/sideeditor/templates",
     "app.edit.views":"api/sideeditor/views",
     "app.edit.view.annotation":"api/sideeditor/views/annotation",
     "app.edit.view.annotation.edit":"api/sideeditor/views/annotation_edit",
     "app.edit.view.modal":"api/sideeditor/views/modal",
     "app.edit.view.modal.confirm":"api/sideeditor/views/confirm_modal",
     "app.edit.view.modal.delete":"api/sideeditor/views/delete_modal",
     "app.edit.view.modal.save":"api/sideeditor/views/save_modal",
     "app.edit.view.hotlink":"api/sideeditor/views/hotlink",
     "app.edit.view.pop":"api/sideeditor/views/pop",
     "app.edit.view.userfollow":"api/sideeditor/views/userfollow",
     "app.edit.view.videopreview":"api/sideeditor/views/videopreview",
     "bootstrap.affix":"vendor/bootstrap3/affix",
     "bootstrap.alert":"vendor/bootstrap3/alert",
     "bootstrap.button":"vendor/bootstrap3/button",
     "bootstrap.carousel":"vendor/bootstrap3/carousel",
     "bootstrap.collapse":"vendor/bootstrap3/collapse",
     "bootstrap.dropdown":"vendor/bootstrap3/dropdown",
     "bootstrap.modal":"vendor/bootstrap3/modal",
     "bootstrap.popover":"vendor/bootstrap3/popover",
     "bootstrap.scrollspy":"vendor/bootstrap3/scrollspy",
     "bootstrap.tab":"vendor/bootstrap3/tab",
     "bootstrap.tooltip":"vendor/bootstrap3/tooltip",
     "bootstrap.transition":"vendor/bootstrap3/transition",
     "bootstrap.colorpicker":"vendor/bootstrap-colorpicker",
     "bootstrap.editable":"vendor/bootstrap-editable",
     jed:"vendor/jed",
     spin:"vendor/spin"
    },
    shim:{
     ember:{
      deps:[ "jquery.noconflict", "handlebars" ],
      exports:"Ember"
     },
     "app.edit.templates":[ "ember.noconflict" ]
    }
   });
   if (!hapyak.debug) {
    requirejs.config({
     context:"hapyak",
     paths:{
      "api/sideeditor/app.edit.sidepanel":"generated/app.edit.sidepanel.built"
     }
    });
   }
   require([ "jquery.noconflict" ], function($) {
    hapyak.asset.css([ "//storage.googleapis.com/hapyak-assets/symbolset/ss-symbolicons-block.css", "//storage.googleapis.com/hapyak-assets/symbolset/ss-standard.css" ], false);
    hapyak.asset.css(hapyak.assets + "/css/generated/sideeditor.css");
    require([ "api/sideeditor/app.edit.sidepanel" ], function(editor) {
     editor(player, container);
    });
   });
  }
 };
});

define("base64", [], function() {
 var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
 var _utf8_encode = function(string) {
  var utftext = "", c, n;
  string = string.replace(/\r\n/g, "\n");
  for (n = 0; n < string.length; n++) {
   c = string.charCodeAt(n);
   if (c < 128) {
    utftext += String.fromCharCode(c);
   } else if (c > 127 && c < 2048) {
    utftext += String.fromCharCode(c >> 6 | 192);
    utftext += String.fromCharCode(c & 63 | 128);
   } else {
    utftext += String.fromCharCode(c >> 12 | 224);
    utftext += String.fromCharCode(c >> 6 & 63 | 128);
    utftext += String.fromCharCode(c & 63 | 128);
   }
  }
  return utftext;
 };
 var _utf8_decode = function(utftext) {
  var string = "", i = 0, c = 0, c1 = 0, c2 = 0;
  while (i < utftext.length) {
   c = utftext.charCodeAt(i);
   if (c < 128) {
    string += String.fromCharCode(c);
    i++;
   } else if (c > 191 && c < 224) {
    c1 = utftext.charCodeAt(i + 1);
    string += String.fromCharCode((c & 31) << 6 | c1 & 63);
    i += 2;
   } else {
    c1 = utftext.charCodeAt(i + 1);
    c2 = utftext.charCodeAt(i + 2);
    string += String.fromCharCode((c & 15) << 12 | (c1 & 63) << 6 | c2 & 63);
    i += 3;
   }
  }
  return string;
 };
 var _hexEncode = function(input) {
  var output = "", i;
  for (i = 0; i < input.length; i++) {
   output += input.charCodeAt(i).toString(16);
  }
  return output;
 };
 var _hexDecode = function(input) {
  var output = "", i;
  if (input.length % 2 > 0) {
   input = "0" + input;
  }
  for (i = 0; i < input.length; i = i + 2) {
   output += String.fromCharCode(parseInt(input.charAt(i) + input.charAt(i + 1), 16));
  }
  return output;
 };
 var encode = function(input) {
  var output = "", chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
  input = _utf8_encode(input);
  while (i < input.length) {
   chr1 = input.charCodeAt(i++);
   chr2 = input.charCodeAt(i++);
   chr3 = input.charCodeAt(i++);
   enc1 = chr1 >> 2;
   enc2 = (chr1 & 3) << 4 | chr2 >> 4;
   enc3 = (chr2 & 15) << 2 | chr3 >> 6;
   enc4 = chr3 & 63;
   if (isNaN(chr2)) {
    enc3 = enc4 = 64;
   } else if (isNaN(chr3)) {
    enc4 = 64;
   }
   output += _keyStr.charAt(enc1);
   output += _keyStr.charAt(enc2);
   output += _keyStr.charAt(enc3);
   output += _keyStr.charAt(enc4);
  }
  return output;
 };
 var decode = function(input) {
  var output = "", chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  while (i < input.length) {
   enc1 = _keyStr.indexOf(input.charAt(i++));
   enc2 = _keyStr.indexOf(input.charAt(i++));
   enc3 = _keyStr.indexOf(input.charAt(i++));
   enc4 = _keyStr.indexOf(input.charAt(i++));
   chr1 = enc1 << 2 | enc2 >> 4;
   chr2 = (enc2 & 15) << 4 | enc3 >> 2;
   chr3 = (enc3 & 3) << 6 | enc4;
   output += String.fromCharCode(chr1);
   if (enc3 !== 64) {
    output += String.fromCharCode(chr2);
   }
   if (enc4 !== 64) {
    output += String.fromCharCode(chr3);
   }
  }
  return _utf8_decode(output);
 };
 var decodeToHex = function(input) {
  return _hexEncode(decode(input));
 };
 var encodeFromHex = function(input) {
  return encode(_hexDecode(input));
 };
 return {
  encode:encode,
  decode:decode,
  decodeToHex:decodeToHex,
  encodeFromHex:encodeFromHex
 };
}());

define("analytics.ganalytics", [ "module", "configuration", "analytics", "dao", "base64", "lodash.noconflict" ], function(module, configuration, analytics, dao, base64, _, undefined) {
 var config = configuration.analytics && configuration.analytics.google || {}, lastEventTime;
 if (config.setup && !(window && window._gaq)) {
  window._gaq = [];
  _.each(config.setup, function(setting) {
   window._gaq.push(setting);
  });
  (function() {
   var ga = document.createElement("script"), s;
   ga.type = "text/javascript";
   ga.async = true;
   ga.src = ("https:" === document.location.protocol ? "https://ssl" :"http://www") + ".google-analytics.com/ga.js";
   s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(ga, s);
  })();
 }
 function setCustomVar(slot, key, val) {
  window._gaq.push([ "_setCustomVar", slot, key, val, 3 ]);
 }
 function initialize(properties) {
  var projectTitle = properties["Project Title"], videoSource = properties["Video Source"], videoSourceId = properties["Video Source ID"], userId = properties["User ID"], username = properties.Username;
  if (projectTitle) {
   setCustomVar(1, "Project", projectTitle);
  }
  if (videoSource) {
   setCustomVar(2, "Video Source", videoSource);
  }
  if (videoSourceId) {
   setCustomVar(3, "Video Source ID", videoSourceId);
  }
  if (userId) {
   setCustomVar(4, "User ID", userId);
  }
  if (username) {
   setCustomVar(5, "Username", username);
  }
 }
 function push(properties, category, action, label, value) {
  category = "HapYak - " + category;
  if (!(window && window._gaq)) {
   return;
  }
  if (!lastEventTime) {
   initialize(properties);
  }
  if (category.length > 150) {
   category = category.substring(0, 150);
  }
  if (action && action.length > 500) {
   action = action.substring(0, 500);
  }
  if (label && label.length > 500) {
   label = label.substring(0, 500);
  }
  if (typeof value === "number") {
   value = Math.round(value);
  } else if (typeof value === "string") {
   value = parseInt(value, 10);
  } else {
   value = null;
  }
  if (properties.Action !== "Progress") {
   window._gaq.push([ "_trackEvent", category, action, label, value ]);
  }
  lastEventTime = new Date().getTime();
 }
 function track(event, properties) {
  var category = (properties["Project Title"] || "") + " (" + properties["Project ID"] + ")", annotationStartTime = properties["Annotation Start Time"];
  if (properties.Context === "Embedded Editor") {
   return;
  }
  if (event === "Player Action" && properties.Type !== "Controls") {
   push(properties, category, "Play", properties.Action);
  } else if (event === "Annotation Action") {
   if (properties["Target Time"] || properties.Type === "contents" && properties.Target !== properties["Annotation ID"]) {
    push(properties, category, "Navigation", properties["Target Time"] || "Chapter: " + properties.Text, annotationStartTime);
   } else if (properties["Target Link"] || properties.Action === "External Click") {
    push(properties, category, "Link", properties["Target Link"] || properties.Target, annotationStartTime);
   } else if (properties.Action === "Answer") {
    push(properties, category, "Quiz", properties.Question + (properties.Correct ? " - (Correct)" :" - Incorrect"), annotationStartTime);
   }
  }
 }
 function GoogleAnalyticsIntegration() {
  this.track = function(eventName, properties, options, callback) {
   properties = this.transformData(properties);
   if (analytics.shouldTrack({
    include:config.include,
    exclude:config.exclude
   }, eventName, properties)) {
    track(eventName, properties);
   }
  };
  this.transformData = function(properties) {
   var excludeKeys = [ "Annotation Types", "Annotation Position", "Annotation Coordinates", "Partner Data", "Gating", "Pausing", "Summary", "Extension Source", "Player Type", "Rollup", "Templates", "excludeKeys" ], o = _.omit(properties, excludeKeys);
   o["Template IDs"] = _.pluck(properties["Templates"], "id");
   return o;
  };
 }
 GoogleAnalyticsIntegration.prototype = new analytics.integration();
 return new GoogleAnalyticsIntegration();
});

define("analytics.internal", [ "module", "configuration", "analytics", "dao", "base64", "lodash.noconflict" ], function(module, configuration, analytics, dao, base64, _, undefined) {
 var config = configuration.analytics && configuration.analytics.internal || {}, whitelistedPlugins = config.whitelistedPlugins ? _.pick(module.config().plugins || {}, _.keys(config.whitelistedPlugins)) :{};
 function InternalIntegration() {
  this.track = function(eventName, properties, options, callback) {
   if (config.include) {
    if (analytics.shouldTrack({
     include:config.include,
     exclude:config.exclude
    }, eventName, properties)) {
     this.log.apply(this, [ "internal.track", eventName, properties ]);
     if (!properties.Time) {
      properties.Time = new Date().getTime();
     }
     var params = {
      data:base64.encode(JSON.stringify({
       name:eventName,
       properties:properties,
       plugins:whitelistedPlugins
      })),
      key:module.config().apiKey
     };
     dao.store.getJSON(null, "/api/analytics/track", params);
    }
   }
  };
 }
 InternalIntegration.prototype = new analytics.integration();
 return new InternalIntegration();
});

define("vendor/mixpanel", [ "logging" ], function(logging, undefined) {
 if (!window.mixpanel) {
  try {
   (function(e, b) {
    if (!b.__SV) {
     var a, f, i, g;
     window.mixpanel = b;
     b._i = [];
     b.init = function(a, e, d) {
      function f(b, h) {
       var a = h.split(".");
       2 == a.length && (b = b[a[0]], h = a[1]);
       b[h] = function() {
        b.push([ h ].concat(Array.prototype.slice.call(arguments, 0)));
       };
      }
      var c = b;
      "undefined" !== typeof d ? c = b[d] = [] :d = "mixpanel";
      c.people = c.people || [];
      c.toString = function(b) {
       var a = "mixpanel";
       "mixpanel" !== d && (a += "." + d);
       b || (a += " (stub)");
       return a;
      };
      c.people.toString = function() {
       return c.toString(1) + ".people (stub)";
      };
      i = "disable track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config people.set people.set_once people.increment people.append people.track_charge people.clear_charges people.delete_user".split(" ");
      for (g = 0; g < i.length; g++) f(c, i[g]);
      b._i.push([ a, e, d ]);
     };
     b.__SV = 1.2;
     a = e.createElement("script");
     a.type = "text/javascript";
     a.async = !0;
     a.src = ("https:" === e.location.protocol ? "https:" :"http:") + "//cdn.mxpnl.com/libs/mixpanel-2.2.min.js";
     f = e.getElementsByTagName("script")[0];
     f.parentNode.insertBefore(a, f);
    }
   })(document, window.mixpanel || []);
  } catch (e) {
   logging.error("error loading mixpanel");
   window.mixpanel = {
    init:function(value, props, key) {
     window.mixpanel[key] = {
      track:function() {},
      register:function() {},
      identify:function() {},
      people:{
       set:function() {}
      }
     };
    },
    track:function() {},
    register:function() {},
    identify:function() {},
    disable:function() {},
    people:{
     set:function() {}
    }
   };
  }
 }
 return window.mixpanel;
});

define("analytics.mixpanel", [ "require", "module", "configuration", "lodash.noconflict", "analytics", "vendor/mixpanel", "cookie" ], function(require, module, configuration, _, analytics, mixpanel, cookie, undefined) {
 var currentUsersSampleValues = {}, shouldLogEventFilters = {};
 function inMixpanelSample(sampleRate, sampleValueExpiresInDays) {
  var cookieName, groupId = configuration.group ? configuration.group.id :null, currentUsersSampleValue = currentUsersSampleValues[groupId];
  if (currentUsersSampleValue === undefined) {
   if (groupId) {
    cookieName = "hapyak.mixpanel." + groupId + ".sample";
   } else {
    cookieName = "hapyak.mixpanel.sample";
   }
   currentUsersSampleValue = cookie.get(cookieName);
   if (currentUsersSampleValue) {
    currentUsersSampleValue = parseInt(currentUsersSampleValue, 10);
   } else {
    currentUsersSampleValue = Math.floor(Math.random() * 100);
    cookie.set(cookieName, currentUsersSampleValue, sampleValueExpiresInDays || 60);
   }
   currentUsersSampleValues[groupId] = currentUsersSampleValue;
  }
  return sampleRate >= currentUsersSampleValue;
 }
 _.each(configuration.mixpanel, function(value, key) {
  var token = value;
  if (typeof token === "object") {
   token = value["token"];
  }
  mixpanel.init(token, {}, key);
  shouldLogEventFilters[key] = function(name, p) {
   if (!analytics.shouldTrack({
    include:value.include,
    exclude:value.exclude
   }, name, p)) {
    return false;
   }
   if (value.sampleRate !== undefined && !inMixpanelSample(value.sampleRate, value.sampleValueExpiresInDays)) {
    return false;
   }
   return true;
  };
  if (value.filter) {
   require([ value.filter ], function(filter) {
    var existingShouldLogEvent = shouldLogEventFilters[key];
    shouldLogEventFilters[key] = function(name, properties) {
     if (!existingShouldLogEvent(name, properties)) {
      return false;
     }
     return filter.shouldLogEvent(name, properties);
    };
   });
  }
  if (value.enabled === false || module.config().environment !== "production") {
   mixpanel[key].disable();
  }
 });
 function MixpanelIntegration() {
  this.identify = function(userId, traits, options, callback) {
   this.log.apply(this, [ "mixpanel.identify", userId, traits ]);
   _.each(configuration.mixpanel, function(value, key) {
    mixpanel[key].identify(userId);
   });
  };
  this.track = function(eventName, properties, options, callback) {
   properties = this.transformData(properties);
   this.log.apply(this, [ "mixpanel.track", eventName, properties ]);
   _.each(configuration.mixpanel, function(config, key) {
    var partnerMixpanel = mixpanel[key], shouldLogEvent = shouldLogEventFilters[key];
    if (shouldLogEvent && !shouldLogEvent(eventName, properties)) {
     return;
    }
    if (key === "hapyak") {
     partnerMixpanel.track(eventName, properties, callback);
    } else {
     var extended = _.extend({
      "Mixpanel Event Source":"HapYak"
     }, properties);
     partnerMixpanel.track("HapYak / " + eventName, extended);
    }
   });
  };
  this.transformData = function(properties) {
   var excludeKeys = [ "Annotation Types", "Annotation Position", "Annotation Coordinates", "Partner Data", "Gating", "Pausing", "Summary", "Extension Source", "Player Type", "Rollup", "Templates", "excludeKeys" ], o = _.omit(properties, excludeKeys);
   o["Template IDs"] = _.pluck(properties["Templates"], "id");
   return o;
  };
 }
 MixpanelIntegration.prototype = new analytics.integration();
 return new MixpanelIntegration();
});

define("analytics.bigquery", [ "module", "configuration", "analytics", "base64", "jquery.noconflict", "lodash.noconflict", "logging", "utils.embed", "utils.omitinvalid" ], function(module, configuration, analytics, base64, $, _, logging, utils, omitInvalid, undefined) {
 var config = configuration.analytics && configuration.analytics.internal || {}, env = module.config().environment || "production", maxRequests = 10, isOldIE = $.browser.msie && $.browser.version < 10, referringDomain = /\/\/([^/]+)/i.exec(document.referrer), whitelistedPlugins = config.whitelistedPlugins ? _.pick(module.config().plugins || {}, _.keys(config.whitelistedPlugins)) :{};
 if (isOldIE) {
  this.hapyak_analytics_uid = null;
  this.hapyak_analytics_sid = null;
 }
 function BigQueryIntegration() {
  this.queue = [];
  this.hasRateLimits = false;
  this.rateLimitRemaining = 0;
  this.rateLimitReset = 0;
  this.sendDelay = 0;
  this.track = function(eventName, properties, options, callback) {
   var utcNow = new Date().toUTCString();
   if (analytics.shouldTrack({
    include:config.include,
    exclude:config.exclude
   }, eventName, properties)) {
    var params;
    properties = this.transformData(properties);
    if (!properties["Event Time"]) {
     properties["Event Time"] = utcNow;
    }
    this.log.apply(this, [ "bigquery.track", eventName, properties ]);
    params = {
     api_key:utils.dotget(configuration, "analytics.bigquery.api_key"),
     data:base64.encode(JSON.stringify({
      name:eventName,
      properties:properties,
      plugins:whitelistedPlugins
     })),
     attempt:0
    };
    if (isOldIE) {
     params.hapyak_analytics_uid = this.hapyak_analytics_uid;
     params.hapyak_analytics_sid = this.hapyak_analytics_sid;
    }
    if (env !== "production") {
     params.dataset = env + "_client_event_stream";
    } else if (properties["Group ID"] === 101) {
     params.dataset = "dailymotion_client_event_stream";
     params.queue = "dailymotion-analytics:events";
    }
    this.queue.push(params);
    this.sendRequest();
   }
  };
  this.sendRequest = function() {
   var that = this;
   function getRateLimits(response) {
    var remaining = response.getResponseHeader("X-RateLimit-Remaining"), reset = response.getResponseHeader("X-RateLimit-Reset");
    if (remaining !== null) {
     that.rateLimitRemaining = +remaining;
    }
    if (reset !== null) {
     that.rateLimitReset = reset * 1e3;
    }
    that.hasRateLimits = remaining !== null && reset !== null;
   }
   function createRequest(params) {
    return function() {
     params.attempt += 1;
     if (params.attempt > maxRequests) {
      logging.debug("[analytics.bigquery] Runaway requests detected! Aborting.");
      return;
     }
     var ajaxSettings = {}, analyticsUrl = env === "production" ? "https://analytics.hapyak.com/track" :"https://analytics-staging.hapyak.com/track";
     if (isOldIE) {
      ajaxSettings = {
       type:"GET",
       url:analyticsUrl,
       data:params,
       dataType:"jsonp"
      };
     } else {
      ajaxSettings = {
       type:"POST",
       url:analyticsUrl,
       data:params,
       xhrFields:{
        withCredentials:true
       }
      };
     }
     $.ajax(ajaxSettings).done(function(data, text, response) {
      getRateLimits(response);
      if (that.rateLimitRemaining) {
       that.sendDelay = 0;
      }
      logging.dev("[analytics.bigquery] Remaining: " + that.rateLimitRemaining + ", Reset: " + that.rateLimitReset + " (SUCCESS)");
      if (isOldIE) {
       that.hapyak_analytics_uid = response.responseJSON.hapyak_analytics_uid;
       that.hapyak_analytics_sid = response.responseJSON.hapyak_analytics_sid;
      }
     }).fail(function(response, text, error) {
      getRateLimits(response);
      that.queue.unshift(params);
      if (!that.hasRateLimits) {
       that.sendDelay += 500;
      } else if (that.rateLimitRemaining === 0) {
       that.sendDelay += 50;
      }
      that.sendRequest();
     });
    };
   }
   function calculateTimeout() {
    var timeout = that.sendDelay;
    var now, utc;
    if (that.hasRateLimits && that.rateLimitRemaining === 0) {
     now = new Date();
     utc = now.getTime() + now.getTimezoneOffset() * 6e4;
     timeout = Math.max(0, (that.rateLimitReset || 0) - utc + that.sendDelay);
    }
    return timeout;
   }
   while (this.queue.length > 0) {
    setTimeout(createRequest(this.queue.pop()), calculateTimeout());
   }
  };
  this.transformData = function(properties) {
   var excludeKeys = [ "Answers", "Correct", "excludeKeys", "Num Answered", "Num Correct", "Num Questions", "Pass", "Questions", "Submit", "Summary", "Target", "Target Time", "Text", "Target Expression", "Video Elapsed Difference" ].concat(properties.excludeKeys), o = _.omit(properties, excludeKeys), quiz = omitInvalid({
    answers:properties["Answers"],
    correct:properties["Correct"],
    num_answered:properties["Num Answered"],
    num_correct:properties["Num Correct"],
    num_questions:properties["Num Questions"],
    passed:properties["Pass"],
    questions:properties["Questions"],
    submit:properties["Action"] === "Submit",
    summary:properties["Summary"]
   });
   o["Annotation Dwell Time"] = properties["Video Elapsed Difference"];
   o["Annotation Text"] = properties["Text"];
   if (!_.isFinite(properties.Target)) {
    o["Link Url"] = properties["Target"];
   }
   o["Link Time"] = properties["Target Time"];
   o["Link Code"] = properties["Target Expression"];
   o.Quiz = quiz;
   if (quiz.answer) {
    o.Rollup = (o.Rollup || []).concat("response");
   }
   o.Rollup = _.uniq(o.Rollup);
   o.Referrer = document.referrer;
   o["Referring Domain"] = referringDomain && referringDomain[1];
   o["Video Dwell Time"] = properties["Video Accrued"];
   return omitInvalid(o);
  };
 }
 BigQueryIntegration.prototype = new analytics.integration();
 return new BigQueryIntegration();
});

(function() {
 var nlsRegExp = /(^.*(^|\/)nls(\/|$))([^\/]*)\/?([^\/]*)/;
 function addPart(locale, master, needed, toLoad, prefix, suffix) {
  if (master[locale]) {
   needed.push(locale);
   if (master[locale] === true || master[locale] === 1) {
    toLoad.push(prefix + locale + "/" + suffix);
   }
  }
 }
 function addIfExists(req, locale, toLoad, prefix, suffix) {
  var fullName = prefix + locale + "/" + suffix;
  if (require._fileExists(req.toUrl(fullName + ".js"))) {
   toLoad.push(fullName);
  }
 }
 function mixin(target, source, force) {
  var prop;
  for (prop in source) {
   if (source.hasOwnProperty(prop) && (!target.hasOwnProperty(prop) || force)) {
    target[prop] = source[prop];
   } else if (typeof source[prop] === "object") {
    if (!target[prop]) {
     target[prop] = {};
    }
    mixin(target[prop], source[prop], force);
   }
  }
 }
 define("vendor/i18n", [ "module" ], function(module) {
  var masterConfig = module.config ? module.config() :{};
  return {
   version:"2.0.3",
   load:function(name, req, onLoad, config) {
    config = config || {};
    if (config.locale) {
     masterConfig.locale = config.locale;
    }
    var masterName, match = nlsRegExp.exec(name), prefix = match[1], locale = match[4], suffix = match[5], parts = locale.split("-"), toLoad = [], value = {}, i, part, current = "";
    if (match[5]) {
     prefix = match[1];
     masterName = prefix + suffix;
    } else {
     masterName = name;
     suffix = match[4];
     locale = masterConfig.locale;
     if (!locale) {
      locale = masterConfig.locale = typeof navigator === "undefined" ? "root" :(navigator.language || navigator.userLanguage || "root").toLowerCase();
     }
     parts = locale.split("-");
    }
    if (config.isBuild) {
     toLoad.push(masterName);
     addIfExists(req, "root", toLoad, prefix, suffix);
     for (i = 0; i < parts.length; i++) {
      part = parts[i];
      current += (current ? "-" :"") + part;
      addIfExists(req, current, toLoad, prefix, suffix);
     }
     req(toLoad, function() {
      onLoad();
     });
    } else {
     req([ masterName ], function(master) {
      var needed = [], part;
      addPart("root", master, needed, toLoad, prefix, suffix);
      for (i = 0; i < parts.length; i++) {
       part = parts[i];
       current += (current ? "-" :"") + part;
       addPart(current, master, needed, toLoad, prefix, suffix);
      }
      req(toLoad, function() {
       var i, partBundle, part;
       for (i = needed.length - 1; i > -1 && needed[i]; i--) {
        part = needed[i];
        partBundle = master[part];
        if (partBundle === true || partBundle === 1) {
         partBundle = req(prefix + part + "/" + suffix);
        }
        mixin(value, partBundle);
       }
       onLoad(value);
      });
     });
    }
   }
  };
 });
})();

define("nls/ui", {
 root:{
  annotation:{
   quiz:{
    actions:{
     thanks:"Thank you message",
     link:"Load URL",
     time:"Jump to video time",
     track:"Load track ID"
    },
    button:{
     cancel:"Cancel",
     back:"Back",
     next:"Next",
     done:"Done",
     submit:"Submit",
     save:"Save",
     new_choice:"Choice",
     new_input:"Input",
     previous_page:"Prev",
     next_page:"Next",
     show_answer:"Show Answer",
     retry:"Retry"
    },
    menu:{
     new_item:{
      new_question:"Question"
     },
     set_option:{
      menu_label:"Options",
      cancel:"Show cancel button",
      passFail:"Pass/Fail actions",
      question:"Answer types",
      reviewScreen:"Review screen"
     }
    },
    text:{
     label:{
      answer:"Correct answer",
      page:"Page",
      of:"of",
      out_of:"out of",
      correct:"correct",
      incorrect:"Incorrect"
     },
     placeholder:{
      new_question:"Enter Question",
      new_choice:"Enter Answer",
      new_input:"Enter Correct Text Answer"
     },
     title:{
      thanks:"Enter Thank You Text"
     },
     warning:{
      delete_page:"Are you sure you want to delete the current page?"
     }
    },
    dialog:{
     passFail:{
      actions:{
       link:"Load URL",
       threshold:"Set custom pass/fail threshold",
       time:"Jump to video time",
       track:"Load track ID",
       passingMark:"Passing score",
       reset:"Reset questions",
       pause:"Pause video on click",
       javascript:"JavaScript"
      },
      tabs:{
       fail:"On Fail",
       pass:"On Pass"
      },
      title:"Pass/Fail Actions"
     },
     onSubmit:{
      actions:{
       retry:"Allow retry",
       show_answer:"Allow viewer to see correct answer(s)",
       thanks:"Message",
       review:"Show review screen"
      },
      thankYouText:"Review your answers",
      reviewScreenMessage:"Review screen message",
      title:"Review Screen"
     },
     questions:{
      actions:{
       multipleAnswers:"Allow multiple correct choices per question",
       multipleRequired:"Require all correct answers to be chosen"
      },
      title:"Answer Types"
     }
    }
   }
  },
  overlay:{
   common:{
    button:{
     cancel:"Cancel",
     ok:"OK",
     submit:"Submit"
    }
   },
   action:{
    chapter_text:{
     title:"Text"
    },
    comment_text:{
     title:"Text"
    },
    delete_annotation:{
     title:"Delete Annotation",
     message:"Are you sure you want to delete this annotation?"
    },
    set_duration:{
     title:"Set Duration",
     text:{
      label:{
       maxDuration:"Stay active until end of video",
       hours:"Hours",
       minutes:"Minutes",
       seconds:"Seconds"
      }
     }
    }
   }
  }
 },
 custom:true
});

define("utils.hms", [ "jquery.noconflict" ], function($) {
 function formatHmsPart(num) {
  return num < 10 ? "0" + num :num;
 }
 function formatMilliseconds(millisecs) {
  var ms = Math.abs(millisecs) % 1e3;
  ms = "" + ms;
  ms = "000".substring(ms.length) + ms;
  return ms;
 }
 var hms = {
  fromSeconds:function(value) {
   var hours = 0, minutes = 0, seconds = 0, milliseconds = 0, negative = false;
   if ($.isNumeric(value)) {
    if (value < 0) {
     negative = true;
     value = Math.abs(value);
    }
    milliseconds = value % 1;
    seconds = (value - milliseconds) % 60;
    minutes = (value - seconds - milliseconds) / 60;
    if (minutes % 60 === 0) {
     minutes = 0;
    } else if (minutes > 60) {
     minutes = minutes - Math.floor(value / 3600) * 60;
    }
    hours = (value - minutes * 60 - seconds - milliseconds) / 3600;
    milliseconds = Math.floor(Math.round(milliseconds * 1e3));
   }
   return {
    negative:negative,
    hours:hours,
    minutes:minutes,
    seconds:seconds,
    milliseconds:milliseconds
   };
  },
  toSeconds:function(o) {
   if ($.isNumeric(o)) {
    return +o;
   } else if (typeof o !== "object" || !o) {
    return 0;
   }
   var seconds = ($.isNumeric(o.hours) && +o.hours || 0) * 3600 + ($.isNumeric(o.minutes) && +o.minutes || 0) * 60 + ($.isNumeric(o.seconds) && +o.seconds || 0) + ($.isNumeric(o.milliseconds) && +o.milliseconds / 1e3 || 0);
   if (o.negative) {
    seconds = -seconds;
   }
   return seconds;
  },
  toString:function(value) {
   if ($.isNumeric(value)) {
    value = hms.fromSeconds(value);
   }
   return (value.negative ? "-" :"") + (value.hours ? formatHmsPart(value.hours) + ":" :"") + formatHmsPart(value.minutes) + ":" + formatHmsPart(value.seconds) + "." + formatMilliseconds(value.milliseconds);
  },
  fromString:function(value) {
   var timeValues, measuresOfTime = [ "hours", "minutes", "seconds" ], timeObject = {}, len;
   if (value.indexOf("-") === 0) {
    value = value.substring(1);
    timeObject.negative = true;
   }
   timeValues = value.split(/[.:]/);
   len = timeValues.length;
   if (value.indexOf(".") > -1) {
    measuresOfTime.push("milliseconds");
   }
   for (;len > 0; len--) {
    timeObject[measuresOfTime.pop()] = timeValues.pop();
   }
   if (timeObject.milliseconds) {
    timeObject.milliseconds = +("0." + timeObject.milliseconds) * 1e3;
   }
   return timeObject;
  }
 };
 return hms;
});

(function(factory) {
 if (typeof define === "function" && define.amd) {
  define("bootstrap.modal", [ "jquery.noconflict" ], factory);
 } else {
  factory(jQuery);
 }
})(function($) {
 var Modal = function(element, options) {
  this.options = options;
  this.$body = $(document.body);
  this.$element = $(element);
  this.$backdrop = this.isShown = null;
  this.scrollbarWidth = 0;
  if (this.options.remote) {
   this.$element.find(".modal-content").load(this.options.remote, $.proxy(function() {
    this.$element.trigger("loaded.bs.modal");
   }, this));
  }
 };
 Modal.VERSION = "3.2.0";
 Modal.DEFAULTS = {
  backdrop:true,
  keyboard:true,
  show:true
 };
 Modal.prototype.toggle = function(_relatedTarget) {
  return this.isShown ? this.hide() :this.show(_relatedTarget);
 };
 Modal.prototype.show = function(_relatedTarget) {
  var that = this;
  var e = $.Event("show.bs.modal", {
   relatedTarget:_relatedTarget
  });
  this.$element.trigger(e);
  if (this.isShown || e.isDefaultPrevented()) return;
  this.isShown = true;
  this.checkScrollbar();
  this.$body.addClass("modal-open");
  this.setScrollbar();
  this.escape();
  this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', $.proxy(this.hide, this));
  this.backdrop(function() {
   var transition = $.support.transition && that.$element.hasClass("fade");
   if (!that.$element.parent().length) {
    that.$element.appendTo(that.$body);
   }
   that.$element.show().scrollTop(0);
   if (transition) {
    that.$element[0].offsetWidth;
   }
   that.$element.addClass("in").attr("aria-hidden", false);
   that.enforceFocus();
   var e = $.Event("shown.bs.modal", {
    relatedTarget:_relatedTarget
   });
   transition ? that.$element.find(".modal-dialog").one("bsTransitionEnd", function() {
    that.$element.trigger("focus").trigger(e);
   }).emulateTransitionEnd(300) :that.$element.trigger("focus").trigger(e);
  });
 };
 Modal.prototype.hide = function(e) {
  if (e) e.preventDefault();
  e = $.Event("hide.bs.modal");
  this.$element.trigger(e);
  if (!this.isShown || e.isDefaultPrevented()) return;
  this.isShown = false;
  this.$body.removeClass("modal-open");
  this.resetScrollbar();
  this.escape();
  $(document).off("focusin.bs.modal");
  this.$element.removeClass("in").attr("aria-hidden", true).off("click.dismiss.bs.modal");
  $.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", $.proxy(this.hideModal, this)).emulateTransitionEnd(300) :this.hideModal();
 };
 Modal.prototype.enforceFocus = function() {
  $(document).off("focusin.bs.modal").on("focusin.bs.modal", $.proxy(function(e) {
   if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
    this.$element.trigger("focus");
   }
  }, this));
 };
 Modal.prototype.escape = function() {
  if (this.isShown && this.options.keyboard) {
   this.$element.on("keyup.dismiss.bs.modal", $.proxy(function(e) {
    e.which == 27 && this.hide();
   }, this));
  } else if (!this.isShown) {
   this.$element.off("keyup.dismiss.bs.modal");
  }
 };
 Modal.prototype.hideModal = function() {
  var that = this;
  this.$element.hide();
  this.backdrop(function() {
   that.$element.trigger("hidden.bs.modal");
  });
 };
 Modal.prototype.removeBackdrop = function() {
  this.$backdrop && this.$backdrop.remove();
  this.$backdrop = null;
 };
 Modal.prototype.backdrop = function(callback) {
  var that = this;
  var animate = this.$element.hasClass("fade") ? "fade" :"";
  if (this.isShown && this.options.backdrop) {
   var doAnimate = $.support.transition && animate;
   this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />').appendTo(this.$body);
   this.$element.on("click.dismiss.bs.modal", $.proxy(function(e) {
    if (e.target !== e.currentTarget) return;
    this.options.backdrop == "static" ? this.$element[0].focus.call(this.$element[0]) :this.hide.call(this);
   }, this));
   if (doAnimate) this.$backdrop[0].offsetWidth;
   this.$backdrop.addClass("in");
   if (!callback) return;
   doAnimate ? this.$backdrop.one("bsTransitionEnd", callback).emulateTransitionEnd(150) :callback();
  } else if (!this.isShown && this.$backdrop) {
   this.$backdrop.removeClass("in");
   var callbackRemove = function() {
    that.removeBackdrop();
    callback && callback();
   };
   $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", callbackRemove).emulateTransitionEnd(150) :callbackRemove();
  } else if (callback) {
   callback();
  }
 };
 Modal.prototype.checkScrollbar = function() {
  if (document.body.clientWidth >= window.innerWidth) return;
  this.scrollbarWidth = this.scrollbarWidth || this.measureScrollbar();
 };
 Modal.prototype.setScrollbar = function() {
  var bodyPad = parseInt(this.$body.css("padding-right") || 0, 10);
  if (this.scrollbarWidth) this.$body.css("padding-right", bodyPad + this.scrollbarWidth);
 };
 Modal.prototype.resetScrollbar = function() {
  this.$body.css("padding-right", "");
 };
 Modal.prototype.measureScrollbar = function() {
  var scrollDiv = document.createElement("div");
  scrollDiv.className = "modal-scrollbar-measure";
  this.$body.append(scrollDiv);
  var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  this.$body[0].removeChild(scrollDiv);
  return scrollbarWidth;
 };
 function Plugin(option, _relatedTarget) {
  return this.each(function() {
   var $this = $(this);
   var data = $this.data("bs.modal");
   var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == "object" && option);
   if (!data) $this.data("bs.modal", data = new Modal(this, options));
   if (typeof option == "string") data[option](_relatedTarget); else if (options.show) data.show(_relatedTarget);
  });
 }
 var old = $.fn.modal;
 $.fn.modal = Plugin;
 $.fn.modal.Constructor = Modal;
 $.fn.modal.noConflict = function() {
  $.fn.modal = old;
  return this;
 };
 $(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(e) {
  var $this = $(this);
  var href = $this.attr("href");
  var $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, ""));
  var option = $target.data("bs.modal") ? "toggle" :$.extend({
   remote:!/#/.test(href) && href
  }, $target.data(), $this.data());
  if ($this.is("a")) e.preventDefault();
  $target.one("show.bs.modal", function(showEvent) {
   if (showEvent.isDefaultPrevented()) return;
   $target.one("hidden.bs.modal", function() {
    $this.is(":visible") && $this.trigger("focus");
   });
  });
  Plugin.call($target, option, this);
 });
});

define("hapyak.overlay", [ "jquery.noconflict", "lodash", "vendor/i18n!nls/ui", "utils.hms", "logging", "bootstrap.modal" ], function($, _, nls, hms, logging) {
 var overlayNls = nls.overlay, durationNls = overlayNls.action.set_duration, modalDOM = $('<div class="hapyak-overlay-modal modal">' + '<div class="modal-dialog">' + '<div class="modal-content">' + '<div class="modal-header">' + '<button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>' + "</div>" + '<div class="modal-body" />' + '<div class="modal-footer">' + '<a href="#" data-dismiss="modal" class="btn modal-failure">' + _.escape(overlayNls.common.button.cancel) + "</a>" + '<a href="#" class="btn btn-primary modal-success">' + _.escape(overlayNls.common.button.ok) + "</a>" + "</div>" + "</div>" + "</div>" + "</div>"), showOptions = {
  backdrop:"static",
  show:true
 }, setupOptions = {}, isSetup = false, options, element, confirmModal, durationModal, tabsModal, textInputModal;
 function centerDialog() {
  _.forEach([ confirmModal, durationModal, tabsModal, textInputModal ], function(modal) {
   var elem = modal ? modal.el :undefined;
   if (!elem || !elem.hasClass("in")) {
    return;
   }
   if (window.innerHeight <= 600) {
    if (elem.outerHeight()) {
     elem.css("margin-top", "-" + elem.outerHeight() / 2 + "px");
    }
    if (elem.outerWidth()) {
     elem.css("margin-left", "-" + elem.outerWidth() / 2 + "px");
    }
   }
   if (elem.outerHeight() > window.innerHeight) {
    elem.css("overflow-y", "scroll");
   } else {
    elem.css("overflow-y", "visible");
   }
  });
 }
 function confirm(o) {
  if (!element) {
   return;
  }
  var body = o.body, message = o.message || "", title = o.title;
  if (confirmModal) {
   logging.debug("hapyak.overlay [confirm]: Reuse built modal", o);
   confirmModal.dismissed = true;
   confirmModal.title.text(title);
   confirmModal.message.text(message);
   if (confirmModal.body) {
    confirmModal.body.empty();
    if (body && body.callbacks && typeof body.callbacks.didInsertElement === "function") {
     body.callbacks.didInsertElement(confirmModal.el);
    }
   }
   confirmModal.callbacks = o.callbacks;
   confirmModal.el.modal(showOptions);
   centerDialog();
   return;
  }
  logging.debug("hapyak.overlay [confirm]: Create new modal", o);
  confirmModal = {
   dismissed:true,
   callbacks:o.callbacks
  };
  confirmModal.el = modalDOM.clone().addClass("hapyak-overlay-confirm");
  confirmModal.title = $('<h3 class="modal-title" />').text(title).appendTo(confirmModal.el.find(".modal-header:first"));
  if (body) {
   confirmModal.body = $('<section class="active"/>').appendTo(confirmModal.el.find(".modal-body:first"));
   if (body.callbacks && typeof body.callbacks.didInsertElement === "function") {
    body.callbacks.didInsertElement(confirmModal.el);
   }
  }
  confirmModal.message = $('<p class="modal-message" />').text(message).appendTo(confirmModal.el.find(".modal-body:first"));
  confirmModal.success = confirmModal.el.find(".modal-footer .modal-success:last").click(function(e) {
   e.preventDefault();
   logging.debug("hapyak.overlay [confirm]: Confirmed");
   confirmModal.dismissed = false;
   if (confirmModal.callbacks && typeof confirmModal.callbacks.success === "function") {
    confirmModal.callbacks.success();
   }
   confirmModal.el.modal("hide");
  });
  confirmModal.el.on("hide", function() {
   if (!confirmModal.dismissed) {
    return;
   }
   logging.debug("hapyak.overlay [confirm]: Aborted");
   if (confirmModal.callbacks && typeof confirmModal.callbacks.failure === "function") {
    confirmModal.callbacks.failure();
   }
   confirmModal.el.remove();
  });
  confirmModal.el.modal(showOptions);
  confirmModal.el.appendTo(element);
  centerDialog();
 }
 function duration(o) {
  if (!element) {
   return;
  }
  var title = typeof o.title === "string" && o.title || durationNls.title, value = typeof o.value === "function" ? o.value() :o.value, format = typeof o.format === "function" ? o.format() :o.format, maxValue = typeof o.maxValue === "function" ? o.maxValue() :o.maxValue, parsed;
  value = $.isNumeric(value) && value > 0 && +value || 0;
  maxValue = $.isNumeric(maxValue) && maxValue > 0 && +maxValue || Number.MAX_VALUE;
  parsed = hms.fromSeconds(value);
  if (durationModal) {
   logging.debug("hapyak.overlay [duration]: Reuse built modal", o);
   durationModal.dismissed = true;
   durationModal.title.text(title);
   durationModal.maxDuration.prop("checked", format === "percent");
   durationModal.hours.val(parsed.hours);
   durationModal.minutes.val(parsed.minutes);
   durationModal.seconds.val(parsed.seconds + parsed.milliseconds / 1e3);
   if (format === "percent") {
    durationModal.hoursMinutesSecondsSection.hide();
   } else {
    durationModal.hoursMinutesSecondsSection.show();
   }
   durationModal.callbacks = o.callbacks;
   durationModal.el.modal(showOptions);
   centerDialog();
   return;
  }
  logging.debug("hapyak.overlay [duration]: Create new modal", o);
  durationModal = {
   dismissed:true,
   callbacks:o.callbacks
  };
  durationModal.el = modalDOM.clone().addClass("hapyak-overlay-duration");
  durationModal.title = $('<h3 class="modal-title" />').text(title).appendTo(durationModal.el.find(".modal-header:first"));
  durationModal.modalBody = durationModal.el.find(".modal-body:first");
  durationModal.maxDuration = $('<input type="checkbox" class="modal-checkbox-max"/> ').prop("checked", format === "percent").appendTo(durationModal.modalBody).change(function() {
   durationModal.hoursMinutesSecondsSection.toggle();
  });
  durationModal.hoursMinutesSecondsSection = $('<div class="hours-minutes-seconds-section"></div>').appendTo(durationModal.modalBody);
  durationModal.hours = $('<input class="modal-input-time" />').val(parsed.hours).appendTo(durationModal.hoursMinutesSecondsSection);
  durationModal.minutes = $('<input class="modal-input-time" />').val(parsed.minutes).appendTo(durationModal.hoursMinutesSecondsSection);
  durationModal.seconds = $('<input class="modal-input-time" />').val(parsed.seconds + parsed.milliseconds / 1e3).appendTo(durationModal.hoursMinutesSecondsSection);
  durationModal.maxDuration.wrap("<div><label>" + _.escape(durationNls.text.label.maxDuration) + "</label></div>");
  durationModal.hours.wrap("<label>" + _.escape(durationNls.text.label.hours) + "</label>");
  durationModal.minutes.wrap("<label>" + _.escape(durationNls.text.label.minutes) + "</label>");
  durationModal.seconds.wrap("<label>" + _.escape(durationNls.text.label.seconds) + "</label>");
  if (format === "percent") {
   durationModal.hoursMinutesSecondsSection.hide();
  }
  durationModal.success = durationModal.el.find(".modal-footer .modal-success:last").text(overlayNls.common.button.submit).click(function(e) {
   e.preventDefault();
   var duration, format;
   if (durationModal.maxDuration.is(":checked")) {
    duration = 100;
    format = "percent";
   } else {
    duration = Math.min(hms.toSeconds({
     hours:+durationModal.hours.val(),
     minutes:+durationModal.minutes.val(),
     seconds:+durationModal.seconds.val()
    }), maxValue);
    format = "seconds";
   }
   logging.debug("hapyak.overlay [duration]: Confirmed", duration, format);
   durationModal.dismissed = false;
   if (durationModal.callbacks && typeof durationModal.callbacks.success === "function") {
    durationModal.callbacks.success(duration, format);
   }
   durationModal.el.modal("hide");
  });
  durationModal.el.on("hide", function() {
   if (!durationModal.dismissed) {
    return;
   }
   logging.debug("hapyak.overlay [duration]: Aborted");
   if (durationModal.callbacks && typeof durationModal.callbacks.failure === "function") {
    durationModal.callbacks.failure();
   }
   durationModal.el.remove();
  });
  durationModal.el.modal(showOptions);
  durationModal.el.appendTo(element);
  centerDialog();
 }
 function textInput(o) {
  if (!element) {
   return;
  }
  var title = typeof o.title === "string" && o.title || "Update Text", value = typeof o.value === "function" ? o.value() :o.value;
  value = typeof value === "string" && value || "";
  if (textInputModal) {
   logging.debug("hapyak.overlay [textInput]: Reuse built modal", o);
   textInputModal.dismissed = true;
   textInputModal.title.text(title);
   textInputModal.input.val(value);
   textInputModal.callbacks = o.callbacks;
   textInputModal.el.modal(showOptions);
   centerDialog();
   return;
  }
  logging.debug("hapyak.overlay [textInput]: Create new modal", o);
  textInputModal = {
   dismissed:true,
   callbacks:o.callbacks
  };
  textInputModal.el = modalDOM.clone().addClass("hapyak-overlay-textinput");
  textInputModal.title = $('<h3 class="modal-title" />').text(title).appendTo(textInputModal.el.find(".modal-header:first"));
  textInputModal.input = $('<textarea class="modal-input" />').val(value).appendTo(textInputModal.el.find(".modal-body:first"));
  textInputModal.success = textInputModal.el.find(".modal-footer .modal-success:last").text("Submit").click(function(e) {
   e.preventDefault();
   logging.debug("hapyak.overlay [textInput]: Confirmed", textInputModal.input.val());
   textInputModal.dismissed = false;
   if (textInputModal.callbacks && typeof textInputModal.callbacks.success === "function") {
    textInputModal.callbacks.success(textInputModal.input.val());
   }
   textInputModal.el.modal("hide");
  });
  textInputModal.el.on("hide", function() {
   if (!textInputModal.dismissed) {
    return;
   }
   logging.debug("hapyak.overlay [textInput]: Aborted");
   if (textInputModal.callbacks && typeof textInputModal.callbacks.failure === "function") {
    textInputModal.callbacks.failure();
   }
   textInputModal.el.remove();
  });
  textInputModal.el.modal(showOptions);
  textInputModal.el.appendTo(element);
  centerDialog();
 }
 function tabs(o) {
  if (!element) {
   return;
  }
  var title = typeof o.title === "string" && o.title || "";
  function createTabs() {
   _.each(o.tabs, function(options, index) {
    var tabBody, tabHeader;
    tabBody = $("<section />").appendTo(tabsModal.body);
    tabHeader = $('<li class="hapyak-tab"><a><span>' + options.title + "</span></a></li>").appendTo(tabsModal.tabs);
    if (index === 0) {
     tabHeader.addClass("active");
     tabBody.addClass("active");
    }
    tabHeader.on("click", function() {
     $("li", tabsModal.tabs).removeClass("active");
     tabHeader.addClass("active");
     $("section", tabsModal.body).removeClass("active");
     tabBody.addClass("active");
     centerDialog();
    });
    if (options.callbacks && typeof options.callbacks.didInsertElement === "function") {
     options.callbacks.didInsertElement(tabsModal.el);
    }
   });
  }
  logging.debug("hapyak.overlay [tabs] Create new modal", o);
  tabsModal = {
   dismissed:true,
   callbacks:o.callbacks
  };
  tabsModal.el = modalDOM.clone().addClass("hapyak-overlay-tabs");
  tabsModal.body = tabsModal.el.find(".modal-body:first");
  tabsModal.title = $('<h3 class="modal-title" />').text(title).appendTo(tabsModal.el.find(".modal-header:first"));
  tabsModal.tabs = $('<ul class="nav nav-tabs" />').appendTo(tabsModal.body);
  createTabs();
  tabsModal.success = tabsModal.el.find(".modal-footer .modal-success:last").text("Submit").click(function(e) {
   e.preventDefault();
   _.each(o.tabs, function(options) {
    if (options.callbacks && typeof options.callbacks.success === "function") {
     options.callbacks.success();
    }
   });
   if (tabsModal.callbacks && typeof tabsModal.callbacks.success === "function") {
    tabsModal.callbacks.success();
   }
   tabsModal.dismissed = false;
   tabsModal.el.modal("hide");
  });
  tabsModal.el.on("hide", function() {
   if (!tabsModal.dismissed) {
    return;
   }
   logging.debug("hapyak.overlay [tabs]: Aborted");
   if (tabsModal.callbacks && typeof tabsModal.callbacks.failure === "function") {
    tabsModal.callbacks.failure();
   }
   tabsModal.el.remove();
  });
  tabsModal.el.modal(showOptions);
  tabsModal.el.appendTo(element);
  centerDialog();
 }
 return {
  setup:function(el, o) {
   if (el instanceof HTMLElement) {
    element = $(el);
   } else {
    throw new Error("First argument in setup() must be an HTML element");
   }
   if (typeof o === "object") {
    options = $.extend(setupOptions, o);
   } else if (typeof o !== "undefined") {
    throw new Error("Second argument in setup() must be an object");
   }
   logging.debug("hapyak.overlay: Setup");
   element.on("click", function(e) {
    e.stopPropagation();
   });
   $(window).on("resize", centerDialog);
   isSetup = true;
  },
  center:centerDialog,
  confirm:confirm,
  duration:duration,
  tabs:tabs,
  textInput:textInput
 };
});

(function(Popcorn, document) {
 function parseUri(str) {
  var o = parseUri.options, m = o.parser[o.strictMode ? "strict" :"loose"].exec(str), uri = {}, i = 14;
  while (i--) {
   uri[o.key[i]] = m[i] || "";
  }
  uri[o.q.name] = {};
  uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
   if ($1) {
    uri[o.q.name][$1] = $2;
   }
  });
  return uri;
 }
 parseUri.options = {
  strictMode:false,
  key:[ "source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor" ],
  q:{
   name:"queryKey",
   parser:/(?:^|&)([^&=]*)=?([^&]*)/g
  },
  parser:{
   strict:/^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
   loose:/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
  }
 };
 var _fakeTimeRanges = {
  length:0,
  start:Popcorn.nop,
  end:Popcorn.nop
 };
 window.MediaError = window.MediaError || function() {
  function MediaError(code, msg) {
   this.code = code || null;
   this.message = msg || "";
  }
  MediaError.MEDIA_ERR_NONE_ACTIVE = 0;
  MediaError.MEDIA_ERR_ABORTED = 1;
  MediaError.MEDIA_ERR_NETWORK = 2;
  MediaError.MEDIA_ERR_DECODE = 3;
  MediaError.MEDIA_ERR_NONE_SUPPORTED = 4;
  return MediaError;
 }();
 function MediaElementProto() {}
 MediaElementProto.prototype = {
  _util:{
   TIMEUPDATE_MS:250,
   MIN_WIDTH:300,
   MIN_HEIGHT:150,
   isAttributeSet:function(value) {
    return typeof value === "string" || value === true;
   },
   parseUri:parseUri
  },
  addEventListener:function(type, listener, useCapture) {
   document.addEventListener(this._eventNamespace + type, listener, useCapture);
  },
  removeEventListener:function(type, listener, useCapture) {
   document.removeEventListener(this._eventNamespace + type, listener, useCapture);
  },
  dispatchEvent:function(name) {
   var customEvent, detail = {
    type:name,
    target:this.parentNode,
    data:null
   };
   try {
    customEvent = document.createEvent("CustomEvent");
    customEvent.initCustomEvent(this._eventNamespace + name, false, false, detail);
   } catch (e) {
    customEvent = document.createEvent("HTMLEvents");
    customEvent.initEvent(this._eventNamespace + name, false, false);
    customEvent.type = name;
    customEvent.target = detail.target;
   }
   document.dispatchEvent(customEvent);
  },
  load:Popcorn.nop,
  canPlayType:function(url) {
   return "";
  },
  getBoundingClientRect:function() {
   return this.parentNode.getBoundingClientRect();
  },
  NETWORK_EMPTY:0,
  NETWORK_IDLE:1,
  NETWORK_LOADING:2,
  NETWORK_NO_SOURCE:3,
  HAVE_NOTHING:0,
  HAVE_METADATA:1,
  HAVE_CURRENT_DATA:2,
  HAVE_FUTURE_DATA:3,
  HAVE_ENOUGH_DATA:4
 };
 MediaElementProto.prototype.constructor = MediaElementProto;
 Object.defineProperties(MediaElementProto.prototype, {
  currentSrc:{
   get:function() {
    return this.src !== undefined ? this.src :"";
   }
  },
  preload:{
   get:function() {
    return "auto";
   },
   set:Popcorn.nop
  },
  controls:{
   get:function() {
    return true;
   },
   set:Popcorn.nop
  },
  poster:{
   get:function() {
    return "";
   },
   set:Popcorn.nop
  },
  crossorigin:{
   get:function() {
    return "";
   }
  },
  played:{
   get:function() {
    return _fakeTimeRanges;
   }
  },
  seekable:{
   get:function() {
    return _fakeTimeRanges;
   }
  },
  buffered:{
   get:function() {
    return _fakeTimeRanges;
   }
  },
  defaultMuted:{
   get:function() {
    return false;
   }
  },
  defaultPlaybackRate:{
   get:function() {
    return 1;
   }
  }
 });
 Popcorn._MediaElementProto = MediaElementProto;
})(Popcorn, window.document);

define("popcorn.mediaelementproto", function() {});

define("player.intersect", [ "jquery.noconflict" ], function($, undefined) {
 return function(child, parent, padding) {
  var o = {}, p = {
   top:0,
   right:0,
   bottom:0,
   left:0
  };
  var childPos, parentPos;
  if (!child) {
   return;
  }
  if (padding === undefined) {
   padding = 0;
  }
  if (child) {
   if (child instanceof HTMLElement) {
    child = $(child);
   }
   if (child.x !== undefined) {
    o.child = child;
   } else {
    childPos = child.position();
    o.child = {
     x:childPos && childPos.left || 0,
     y:childPos && childPos.top || 0,
     width:child.outerWidth() || 0,
     height:child.outerHeight() || 0
    };
   }
  }
  if (parent) {
   if (parent instanceof HTMLElement) {
    parent = $(parent);
   }
   if (parent.x !== undefined) {
    o.parent = parent;
   } else {
    parentPos = parent.position();
    o.parent = {
     x:parentPos && parentPos.left || 0,
     y:parentPos && parentPos.top || 0,
     width:parent.outerWidth() || 0,
     height:parent.outerHeight() || 0
    };
   }
  }
  if (padding) {
   if (typeof padding === "object") {
    $.extend(p, padding);
   } else {
    if (typeof padding === "string" && padding.indexOf("%") !== -1) {
     padding = padding.replace("%", "") / 100;
     p.top = p.bottom = o.parent.height * padding;
     p.left = p.right = o.parent.width * padding;
    } else if (typeof padding === "number") {
     p.top = p.right = p.bottom = p.left = padding;
    }
   }
  }
  if (o.child && o.parent) {
   o.relative = {
    top:o.child.y - p.top,
    right:o.child.x + o.child.width - o.parent.width + p.right,
    bottom:o.child.y + o.child.height - o.parent.height + p.bottom,
    left:o.child.x - p.left
   };
   o.exceed = {
    top:o.relative.top < 0,
    right:o.relative.right > 0,
    bottom:o.relative.bottom > 0,
    left:o.relative.left < 0
   };
  }
  return o;
 };
});

(function(root, factory) {
 if (typeof exports === "object") {
  module.exports = factory(require("jquery.noconflict"), require("player.intersect"), require("hapyak.overlay"), require("popcorn"), require("popcorn.filter"));
 } else if (typeof define === "function" && define.amd) {
  define("popcorn.close", [ "jquery.noconflict", "player.intersect", "hapyak.overlay", "popcorn", "popcorn.datafilter" ], factory);
 } else {
  factory(root.Popcorn);
 }
})(this, function($, intersect, overlay, Popcorn, popcornfilter, undefined) {
 var asked = {}, hiddenContainers = {};
 Popcorn.dataFilter([ "editMode" ], "close", [ "pop", "hotlink", "iframe" ], function(name, options, next, node, editMode) {
  var popcorn = this;
  var boundaries, close, container, playBoxContainer;
  function closeAnnotation(e) {
   e.preventDefault();
   e.stopPropagation();
   if (container) {
    hiddenContainers[node.uid] = container;
    container.addClass("closed");
   }
   if (asked[popcorn.id]) {
    delete asked[popcorn.id];
    overlay.confirm({
     title:"Disable annotations",
     message:"Do you want to disable all annotations?",
     callbacks:{
      success:function() {
       var key;
       for (key in hiddenContainers) {
        if (hiddenContainers.hasOwnProperty(key)) {
         hiddenContainers[key].removeClass("closed");
         delete hiddenContainers[key];
        }
       }
       popcorn.emit("disable");
      }
     }
    });
   } else {
    asked[popcorn.id] = true;
   }
  }
  function hasDynamicWidth() {
   return node.fakeTrackEvent._natives.plugin === "userfollow";
  }
  function relativeDim(value, prop) {
   var dim = prop === "width" ? playBoxContainer.outerWidth() :playBoxContainer.outerHeight();
   if (value === undefined || !dim) {
    return 0;
   }
   if (typeof value === "number") {
    return value;
   } else if (value.indexOf("px") !== -1) {
    return +value.replace("px", "");
   } else {
    return dim * (+value.replace("%", "") / 100);
   }
  }
  next(options);
  if (name === "iframe" && (!node.fakeTrackEvent || !node.fakeTrackEvent._natives || !(node.fakeTrackEvent._natives.plugin === "userfollow" || node.fakeTrackEvent._natives.plugin === "videopreview"))) {
   return;
  }
  if (editMode && hiddenContainers[node.uid]) {
   hiddenContainers[node.uid].removeClass("closed");
   delete hiddenContainers[node.uid];
  }
  container = $(node.fakeTrackEvent.container);
  playBoxContainer = $(container).closest(".hapyak-play-box, .hapyak-player");
  if (container && container.parent()) {
   close = $(container).find(".hapyak-el-close");
   if (!close.length) {
    close = $('<div class="hapyak-el-close"><div>&times;</div></div>').hide().appendTo(container);
    close.click(closeAnnotation);
   }
   close.hide();
   boundaries = intersect({
    x:relativeDim(options.left, "width"),
    y:relativeDim(options.top, "height"),
    width:relativeDim(hasDynamicWidth() ? container.outerWidth() * 1.93548 :options.width || container.outerWidth(), "width"),
    height:relativeDim(container.outerHeight(), "height")
   }, playBoxContainer, "4%");
   if (boundaries.exceed.right) {
    close.addClass("hapyak-el-close-left");
   } else {
    close.removeClass("hapyak-el-close-left");
   }
   if (boundaries.exceed.top) {
    close.addClass("hapyak-el-close-bottom");
   } else {
    close.removeClass("hapyak-el-close-bottom");
   }
   if (!editMode) {
    close.show();
   }
  }
 }, false, function(node) {
  if (hiddenContainers[node.uid]) {
   hiddenContainers[node.uid].removeClass("closed");
  }
  delete hiddenContainers[node.uid];
 });
});

(function(window, Popcorn, undefined) {
 var document = window.document, EMPTY_STRING = "", MIN_WIDTH = 300, MIN_HEIGHT = 200, apiScriptElement, apiReadyCallbacks = [], DM, htmlMode, readyStates = [ [ "loadstart" ], [ "durationchange", "loadedmetadata" ], [ "loadeddata" ], [ "loadeddata", "canplay" ], [ "canplaythrough" ] ];
 function isEmbedPlayer(src) {
  return [ window.DailymotionPlayer, window.DailymotionPlayerFlash, window.DailymotionPlayerHTML ].some(function(DMPlayer) {
   return DMPlayer && src instanceof DMPlayer;
  });
 }
 function findExistingPlayer(src) {
  var val = false;
  if (!DM) {
   DM = window.DM;
  }
  if (DM && DM.Player && DM.Player._INSTANCES) {
   for (var player in DM.Player._INSTANCES) {
    if (DM.Player._INSTANCES[player] === src) {
     val = true;
    }
   }
  }
  if (!val) {
   val = isEmbedPlayer(src);
  }
  return val;
 }
 function apiReadyPromise(fn) {
  if (!window.DM && !apiScriptElement) {
   apiScriptElement = document.createElement("script");
   apiScriptElement.async = true;
   apiScriptElement.src = (document.location.protocol === "file:" ? "http:" :document.location.protocol) + "//api.dmcdn.net/all.js";
   document.head.appendChild(apiScriptElement);
  }
  if (window.DM) {
   DM = window.DM;
   fn();
  } else {
   if (!apiReadyCallbacks.length) {
    if (typeof window.dmAsyncInit === "function") {
     apiReadyCallbacks.push(window.dmAsyncInit);
    }
    window.dmAsyncInit = function() {
     DM = window.DM;
     while (apiReadyCallbacks.length) {
      apiReadyCallbacks.shift()();
     }
    };
   }
   apiReadyCallbacks.push(fn);
  }
 }
 function HTMLDailymotionVideoElement(id, options) {
  options = options || {};
  var self = this, parent = typeof id === "string" ? Popcorn.dom.find(id) :id, elem, impl = {
   src:EMPTY_STRING,
   networkState:self.NETWORK_EMPTY,
   readyState:self.HAVE_NOTHING,
   seeking:false,
   autoplay:EMPTY_STRING,
   preload:EMPTY_STRING,
   controls:false,
   loop:false,
   poster:EMPTY_STRING,
   volume:1,
   muted:0,
   currentTime:0,
   duration:NaN,
   ended:false,
   paused:true,
   width:parent.width | 0 ? parent.width :MIN_WIDTH,
   height:parent.height | 0 ? parent.height :MIN_HEIGHT,
   error:null,
   progressAmount:null
  }, forceReadyState = options.forceReadyState, maxReadyState = 0, playEventPending = false, playingEventPending = false, playerReady = false, player, existingPlayer, playerEventObject, playerReadyCallbacks = [], stalledTimeout, targetCurrentTime, dmRegex = /video\/([a-z0-9]+)/i, firstPlayingEvent = false, embedPlayer = false, htmlEmbedPlayer = false, info, eventCallbacks = {};
  function playerReadyPromise(fn, unique) {
   var i;
   if (playerReady) {
    fn();
    return;
   }
   if (unique) {
    i = playerReadyCallbacks.indexOf(fn);
    if (i >= 0) {
     playerReadyCallbacks.splice(i, 1);
    }
   }
   playerReadyCallbacks.push(fn);
  }
  function registerEventListener(name, src) {
   var callback;
   callback = eventCallbacks[name];
   if (callback) {
    removeListener(name, callback);
   }
   if (typeof src === "function") {
    callback = function(evt) {
     if (src.call(this, evt)) {
      self.dispatchEvent(name);
     }
    };
   } else {
    callback = function() {
     self.dispatchEvent(name);
    };
   }
   eventCallbacks[name] = callback;
   addListener(name, callback);
  }
  function fireEventListener(name) {
   var callback = eventCallbacks[name];
   if (callback) {
    callback();
   }
  }
  function removeEventListeners() {
   Popcorn.forEach(eventCallbacks, function(name, callback) {
    removeListener(name, callback);
   });
  }
  function removeListener(name, callback) {
   if (player.removeEventListener) {
    player.removeEventListener(name, callback);
   } else {
    $(playerEventObject).off(name, callback);
   }
  }
  function addListener(name, callback) {
   if (player.addEventListener) {
    player.addEventListener(name, callback);
   } else {
    $(playerEventObject).on(name, callback);
   }
  }
  function setReadyState(state) {
   var i, queue;
   if (state <= impl.readyState) {
    return;
   }
   maxReadyState = Math.max(maxReadyState, state);
   if (state - impl.readyState > 1) {
    return;
   }
   impl.readyState++;
   queue = readyStates[impl.readyState];
   for (i = 0; i < queue.length; i++) {
    self.dispatchEvent(queue[i]);
   }
   setReadyState(maxReadyState);
  }
  function destroyPlayer() {
   clearTimeout(stalledTimeout);
   if (!(playerReady && player)) {
    return;
   }
   player.pause();
   removeEventListeners();
   parent.removeChild(elem);
   elem = null;
   playerReady = false;
  }
  function onDurationChange() {
   impl.duration = embedPlayer ? info.duration :player.duration;
   if (impl.readyState < self.HAVE_METADATA) {
    setReadyState(self.HAVE_METADATA);
   } else {
    self.dispatchEvent("durationchange");
   }
   if (playEventPending) {
    self.dispatchEvent("play");
   }
   if (playingEventPending) {
    playingEventPending = false;
    self.dispatchEvent("playing");
   }
   if (playEventPending) {
    playEventPending = false;
    if (impl.paused) {
     self.dispatchEvent("pause");
    }
   }
  }
  function onStalled() {
   if (!impl.duration || impl.progressAmount < impl.duration) {
    impl.networkState = self.NETWORK_IDLE;
    self.dispatchEvent("stalled");
   } else {
    monitorStalled();
   }
  }
  function monitorStalled() {
   clearTimeout(stalledTimeout);
   stalledTimeout = setTimeout(onStalled, 3e3);
  }
  function updateSize() {
   player.width = impl.width;
   player.height = impl.height;
  }
  function changeSrc(aSrc) {
   function getSrc() {
    if (info && info.url) {
     return info.url;
    } else if (player.contentInfo && player.contentInfo.url) {
     return player.contentInfo.url;
    }
    return player.src;
   }
   var playerParams;
   destroyPlayer();
   impl.readyState = -1;
   maxReadyState = -1;
   playEventPending = false;
   playingEventPending = false;
   if (impl.networkState !== self.NETWORK_EMPTY) {
    if (impl.networkState === self.NETWORK_LOADING || impl.networkState === self.NETWORK_IDLE) {
     self.dispatchEvent("abort");
    }
    self.dispatchEvent("emptied");
   }
   if (!impl.paused) {
    if (playerReady) {
     player.pause();
    }
    impl.paused = false;
   }
   impl.seeking = false;
   impl.duration = NaN;
   if (impl.currentTime) {
    impl.currentTime = 0;
    self.dispatchEvent("timeupdate");
   }
   impl.error = null;
   if (!aSrc) {
    impl.readyState = self.HAVE_NOTHING;
    return;
   }
   if (!self._canPlaySrc(aSrc)) {
    impl.error = {
     name:"MediaError",
     message:"Media Source Not Supported",
     code:window.MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED
    };
    impl.networkState = self.NETWORK_NO_SRC;
    self.dispatchEvent("error");
    return;
   }
   impl.src = aSrc;
   impl.networkState = self.NETWORK_LOADING;
   setReadyState(self.HAVE_NOTHING);
   apiReadyPromise(function() {
    function findHTMLPlayer(dmPlayer) {
     if (dmPlayer.implem) {
      if (dmPlayer.implem instanceof window.DailymotionPlayerHTML) {
       return dmPlayer.implem;
      }
      if (dmPlayer.implem.backend instanceof window.DailymotionPlayerHTML) {
       return dmPlayer.implem.backend;
      }
     }
     return false;
    }
    var videoId, ui;
    if (!impl.src && player) {
     destroyPlayer();
    }
    existingPlayer = findExistingPlayer(impl.src);
    if (!existingPlayer) {
     videoId = dmRegex.exec(impl.src)[1];
     elem = document.createElement("div");
     parent.appendChild(elem);
     playerParams = {
      autoplay:+impl.autoplay,
      annotations:0,
      info:0,
      related:0,
      controls:htmlMode && "html" || "flash",
      chromeless:impl.controls ? 0 :1,
      html:htmlMode,
      logo:!htmlMode && 1 || 0
     };
     if (forceReadyState) {
      playerParams["advertising-enable"] = 0;
     }
     player = DM.player(elem, {
      video:videoId,
      width:impl.width,
      height:impl.height,
      params:playerParams
     });
     playerEventObject = player;
    } else {
     embedPlayer = isEmbedPlayer(impl.src);
     htmlEmbedPlayer = embedPlayer && findHTMLPlayer(impl.src);
     player = embedPlayer ? htmlEmbedPlayer || impl.src.implem :impl.src;
     playerEventObject = impl.src.implem || player;
     info = embedPlayer ? impl.src.info || impl.src.contentInfo :null;
     ui = player.ui;
     impl.src = getSrc();
     if (ui && ui.root && ui.root[0]) {
      impl.width = ui.root[0].firstChild.offsetWidth || (hapyak.iframed ? document.body.offsetWidth :0), impl.height = ui.root[0].firstChild.offsetHeight || (hapyak.iframed ? document.body.offsetHeight :0);
     } else {
      impl.width = player.offsetWidth;
      impl.height = player.offsetHeight;
     }
     impl.duration = embedPlayer ? info.duration :player.duration;
     onDurationChange();
     if (player.autoplay) {
      impl.autoplay = true;
     } else if (player.options) {
      impl.autoplay = player.options.autoplay;
     } else if (player.params) {
      impl.autoplay = !!player.params.autoplay;
     } else if (/[?&]autoplay=/.test(impl.src)) {
      impl.autoplay = !!+impl.src.split("autoplay=")[1][0];
     } else {
      impl.autoplay = false;
     }
    }
    function apiReady() {
     playerReady = true;
     removeListener("apiready", apiReady);
     while (playerReadyCallbacks.length) {
      playerReadyCallbacks.shift()();
     }
    }
    if (existingPlayer) {
     if (embedPlayer && !htmlEmbedPlayer) {
      addListener("canplay", function embedPlayerCanPlay() {
       removeListener("canplay", embedPlayerCanPlay);
       apiReady();
      });
     } else {
      apiReady();
     }
    } else {
     addListener("apiready", apiReady);
    }
    playerReadyPromise(function() {
     registerEventListener("error");
     monitorStalled();
     function updateProgress() {
      if (!impl.duration && player.duration) {
       onDurationChange();
      }
      if (player.bufferedTime < Infinity) {
       impl.progressAmount = player.bufferedTime;
      }
      impl.progressAmount = Math.max(impl.progressAmount, player.currentTime);
      setReadyState(self.HAVE_CURRENT_DATA);
      if (impl.progressAmount >= impl.duration) {
       impl.networkState = self.NETWORK_IDLE;
       setReadyState(self.HAVE_CURRENT_DATA);
       setReadyState(self.HAVE_FUTURE_DATA);
       setReadyState(self.HAVE_ENOUGH_DATA);
      } else {
       impl.networkState = self.NETWORK_LOADING;
       monitorStalled();
      }
      return true;
     }
     updateProgress();
     registerEventListener("progress", updateProgress);
     registerEventListener("stalled", onStalled);
     registerEventListener("timeupdate", function() {
      var currentTime = embedPlayer ? player.currentTime() :player.currentTime;
      if (impl.currentTime !== currentTime) {
       impl.currentTime = currentTime;
       self.dispatchEvent("timeupdate");
      }
     });
     registerEventListener("durationchange", onDurationChange);
     registerEventListener("volumechange", function() {
      var volume = player.volume;
      if (impl.volume !== volume) {
       impl.volume = volume;
       return true;
      }
     });
     registerEventListener("canplay", function() {
      if (!impl.duration && player.duration) {
       onDurationChange();
      }
      setReadyState(self.HAVE_CURRENT_DATA);
      setReadyState(self.HAVE_FUTURE_DATA);
     });
     registerEventListener("canplaythrough", function() {
      setReadyState(self.HAVE_ENOUGH_DATA);
     });
     registerEventListener("play", function() {
      if (impl.paused) {
       impl.paused = false;
       if (!impl.duration) {
        playEventPending = true;
       } else {
        return true;
       }
      }
     });
     registerEventListener("seeking", function() {
      impl.seeking = true;
      if (impl.paused) {
       self.dispatchEvent("seeking");
       impl.seeking = false;
       self.dispatchEvent("seeked");
      }
      return true;
     });
     registerEventListener("seeked", function() {
      if (impl.seeking) {
       impl.seeking = false;
       return true;
      }
     });
     registerEventListener("playing", function() {
      if (!impl.duration && player.duration) {
       onDurationChange();
      }
      if (!firstPlayingEvent && !impl.autoplay) {
       firstPlayingEvent = true;
      }
      if (!impl.duration) {
       playingEventPending = true;
       return false;
      }
      setReadyState(self.HAVE_CURRENT_DATA);
      setReadyState(self.HAVE_FUTURE_DATA);
      if (impl.seeking) {
       impl.seeking = false;
       self.dispatchEvent("seeked");
      }
      return true;
     });
     registerEventListener("pause", function() {
      if (!impl.paused) {
       impl.paused = true;
       return !!impl.duration;
      }
     });
     registerEventListener("ended", function() {
      if (impl.loop) {
       player.seek(0);
       player.play();
      } else {
       impl.ended = true;
       return true;
      }
     });
     if (existingPlayer && htmlEmbedPlayer) {
      if (htmlEmbedPlayer.player.readyState >= self.HAVE_METADATA) {
       fireEventListener("durationchange");
       fireEventListener("loadedmetadata");
      }
      if (htmlEmbedPlayer.player.readyState >= self.HAVE_CURRENT_DATA) {
       fireEventListener("loadeddata");
      }
      if (htmlEmbedPlayer.player.readyState >= self.HAVE_FUTURE_DATA) {
       fireEventListener("canplay");
      }
      if (htmlEmbedPlayer.player.readyState >= self.HAVE_ENOUGH_DATA) {
       fireEventListener("canplaythrough");
      }
     }
     if (!impl.autoplay && !impl.duration) {
      player.play();
     }
    });
   }, true);
  }
  function setVolume() {
   player.setVolume(impl.volume);
  }
  function getVolume() {
   return impl.muted > 0 ? impl.muted :impl.volume;
  }
  function setMuted() {
   player.api(impl.muted > 0 ? "mute" :"unmute");
  }
  function getMuted() {
   return impl.muted > 0;
  }
  function setCurrentTime() {
   if (targetCurrentTime >= 0 && targetCurrentTime < impl.duration) {
    if (htmlEmbedPlayer) {
     player.currentTime(targetCurrentTime);
    }
    player.seek(targetCurrentTime);
    targetCurrentTime = -1;
   }
  }
  if (htmlMode === undefined) {
   elem = document.createElement("video");
   htmlMode = !!(elem.canPlayType && elem.canPlayType("video/mp4"));
   elem = null;
  }
  self._eventNamespace = Popcorn.guid("HTMLDailymotionVideoElement::");
  self.parentNode = parent;
  self._util = Popcorn.extend({}, self._util);
  self._util.type = "Dailymotion";
  self.play = function() {
   function play() {
    player.play();
   }
   playerReadyPromise(play, true);
  };
  self.pause = function() {
   function pause() {
    player.pause();
   }
   playerReadyPromise(pause, true);
  };
  self.load = function() {
   changeSrc(impl.src);
  };
  Object.defineProperties(self, {
   src:{
    get:function() {
     return impl.src;
    },
    set:function(aSrc) {
     if (aSrc !== impl.src) {
      changeSrc(aSrc);
     }
    }
   },
   autoplay:{
    get:function() {
     return impl.autoplay;
    },
    set:function(aValue) {
     impl.autoplay = self._util.isAttributeSet(aValue);
    }
   },
   loop:{
    get:function() {
     return impl.loop;
    },
    set:function(aValue) {
     impl.loop = self._util.isAttributeSet(aValue);
    }
   },
   width:{
    get:function() {
     if (player && player.player) {
      return player.player.offsetWidth || impl.width;
     }
     return impl.width;
    },
    set:function(aValue) {
     impl.width = aValue;
     playerReadyPromise(updateSize);
    }
   },
   height:{
    get:function() {
     if (player && player.player) {
      return player.player.offsetHeight || impl.height;
     }
     return impl.height;
    },
    set:function(aValue) {
     impl.height = aValue;
     playerReadyPromise(updateSize);
    }
   },
   currentTime:{
    get:function() {
     if (player) {
      if (embedPlayer) {
       return player.currentTime();
      }
      return player.currentTime;
     }
     return 0;
    },
    set:function(aValue) {
     aValue = parseFloat(aValue);
     targetCurrentTime = aValue;
     playerReadyPromise(setCurrentTime, true);
    }
   },
   currentSrc:{
    get:function() {
     return impl.src;
    }
   },
   duration:{
    get:function() {
     return impl.duration;
    }
   },
   ended:{
    get:function() {
     return impl.ended;
    }
   },
   paused:{
    get:function() {
     return impl.paused;
    }
   },
   seeking:{
    get:function() {
     return impl.seeking;
    }
   },
   readyState:{
    get:function() {
     return impl.readyState;
    }
   },
   networkState:{
    get:function() {
     return impl.networkState;
    }
   },
   volume:{
    get:function() {
     return getVolume();
    },
    set:function(aValue) {
     aValue = parseFloat(aValue);
     if (aValue < 0 || aValue > 1 || isNaN(aValue)) {
      throw new Error("Volume value must be between 0.0 and 1.0");
     }
     impl.volume = aValue;
     playerReadyPromise(setVolume, true);
     self.dispatchEvent("volumechange");
    }
   },
   muted:{
    get:function() {
     return getMuted();
    },
    set:function(aValue) {
     impl.muted = self._util.isAttributeSet(aValue) && 1 || 0;
     playerReadyPromise(setMuted, true);
     self.dispatchEvent("volumechange");
    }
   },
   error:{
    get:function() {
     return impl.error;
    }
   }
  });
 }
 HTMLDailymotionVideoElement.prototype = new Popcorn._MediaElementProto();
 HTMLDailymotionVideoElement.prototype.constructor = HTMLDailymotionVideoElement;
 HTMLDailymotionVideoElement.prototype._canPlaySrc = function(url) {
  return findExistingPlayer(url) || /dailymotion\.com\/(embed\/)?video\/([a-z0-9]+)/i.test(url) ? "probably" :EMPTY_STRING;
 };
 HTMLDailymotionVideoElement.prototype.canPlayType = function(type) {
  return type === "video/x-dailymotion" ? "probably" :EMPTY_STRING;
 };
 Popcorn.HTMLDailymotionVideoElement = function(id, options) {
  return new HTMLDailymotionVideoElement(id, options);
 };
 Popcorn.HTMLDailymotionVideoElement._canPlaySrc = HTMLDailymotionVideoElement.prototype._canPlaySrc;
})(this, this.Popcorn);

define("popcorn.htmldailymotionvideoelement", function() {});

define("player.profile.dailymotion", [ "player.wrappers", "popcorn.htmldailymotionvideoelement" ], function(wrappers) {
 wrappers.dailymotion = {
  id:"dailymotion",
  name:"Dailymotion",
  fn:"HTMLDailymotionVideoElement",
  pre:"//www.dailymotion.com/video/",
  args:function(video, options) {
   return [ options.playerParameters ];
  },
  container:function(container, wrapper) {
   var elem = container.parentNode || document.createElement("div");
   if (elem.parentNode) {
    return elem;
   }
   wrapper.addEventListener("canplay", function onDailymotionCanPlay() {
    wrapper.removeEventListener("canplay", onDailymotionCanPlay, false);
    if (container.player && container.player.parentNode) {
     container.player.parentNode.appendChild(elem);
    }
   }, false);
   elem.style.position = "static";
   container.ui.root[0].parentNode.appendChild(elem);
   return elem;
  }
 };
 return wrappers.dailymotion;
});

(function(window, Popcorn, undefined) {
 var document = window.document, EMPTY_STRING = "", MIN_WIDTH = 300, MIN_HEIGHT = 200, apiReadyCallbacks = [], htmlMode, readyStates = [ [ "loadstart" ], [ "durationchange", "loadedmetadata" ], [ "loadeddata" ], [ "loadeddata", "canplay", "canplaythrough" ] ], dataRegex = /dmcdn\.net([a-zA-Z0-9\/\-]+\.swf)/;
 function findExistingPlayer(src) {
  var data, Pg_Video, DM_Player;
  Pg_Video = window.Pg_Video;
  DM_Player = window.DM_Player;
  if (Pg_Video && Pg_Video.videoPlayer === src || DM_Player && DM_Player.players && DM_Player.players.indexOf(src) > -1) {
   return true;
  }
  if (src && src.tagName === "OBJECT" && src.getAttribute) {
   data = src.getAttribute("data");
   if (data && dataRegex.test(data)) {
    return true;
   }
  }
  return src && src.tagName === "OBJECT" && src.playVideo && "maybe";
 }
 function HTMLDailymotionVideoElementInternal(id) {
  var self = this, parent = typeof id === "string" ? Popcorn.dom.find(id) :id, elem, impl = {
   src:EMPTY_STRING,
   networkState:self.NETWORK_EMPTY,
   readyState:self.HAVE_NOTHING,
   seeking:false,
   autoplay:EMPTY_STRING,
   preload:EMPTY_STRING,
   controls:false,
   loop:false,
   poster:EMPTY_STRING,
   volume:1,
   muted:0,
   currentTime:0,
   duration:NaN,
   ended:false,
   paused:true,
   width:parent.width | 0 ? parent.width :MIN_WIDTH,
   height:parent.height | 0 ? parent.height :MIN_HEIGHT,
   error:null,
   progressAmount:null,
   mediaType:null
  }, maxReadyState = 0, requestedPlay = false, playEventPending = false, playingEventPending = false, playerReady = false, player, existingPlayer, playerReadyCallbacks = [], stalledTimeout, dmRegex = /video\/([a-z0-9]+)/i, eventCallbacks = {}, eventGuid = Popcorn.guid();
  window["hapyakDMCallbacks" + eventGuid] = {};
  function apiReadyPromise(fn) {
   function isApiReady() {
    if (window.Pg_Video || window.DM_Player && window.DM_Player.players || impl.src && impl.src.tagName === "OBJECT") {
     while (apiReadyCallbacks.length) {
      apiReadyCallbacks.shift()();
     }
     return true;
    }
    setTimeout(isApiReady, 100);
   }
   if (window.Pg_Video || window.DM_Player && window.DM_Player.players || impl.src && impl.src.tagName === "OBJECT") {
    fn();
   } else {
    apiReadyCallbacks.push(fn);
    setTimeout(isApiReady, 100);
   }
  }
  function playerReadyPromise(fn, unique) {
   var i;
   if (playerReady) {
    fn();
    return;
   }
   if (unique) {
    i = playerReadyCallbacks.indexOf(fn);
    if (i >= 0) {
     playerReadyCallbacks.splice(i, 1);
    }
   }
   playerReadyCallbacks.push(fn);
  }
  function registerEventListener(name, src, dest) {
   var callback;
   callback = eventCallbacks[name];
   if (callback) {
    player.removeEventListener(name, callback);
   }
   eventCallbacks[name] = src;
   player.addEventListener(name, eventCallbacks[name]);
  }
  function removeEventListeners() {
   Popcorn.forEach(eventCallbacks, function(name, callback) {
    player.removeEventListener(name, callback);
   });
  }
  function setReadyState(state) {
   var i, queue;
   if (state <= impl.readyState) {
    return;
   }
   maxReadyState = Math.max(maxReadyState, state);
   if (state - impl.readyState > 1) {
    return;
   }
   impl.readyState++;
   queue = readyStates[impl.readyState];
   for (i = 0; i < queue.length; i++) {
    self.dispatchEvent(queue[i]);
   }
   setReadyState(maxReadyState);
  }
  function destroyPlayer() {
   clearTimeout(stalledTimeout);
   if (!(playerReady && player)) {
    return;
   }
   player.pause();
   removeEventListeners();
   parent.removeChild(elem);
   elem = null;
  }
  function durationChange(newDuration) {
   var duration = newDuration || player.getDuration();
   if (!duration || duration === impl.duration) {
    return;
   }
   impl.duration = duration;
   if (impl.readyState < self.HAVE_METADATA) {
    setReadyState(self.HAVE_METADATA);
   } else {
    self.dispatchEvent("durationchange");
   }
   if (playEventPending) {
    self.dispatchEvent("play");
   }
   if (playingEventPending) {
    playingEventPending = false;
    setReadyState(self.HAVE_CURRENT_DATA);
    setReadyState(self.HAVE_FUTURE_DATA);
    self.dispatchEvent("playing");
   }
   if (playEventPending) {
    playEventPending = false;
    if (impl.paused) {
     self.dispatchEvent("pause");
    }
   }
  }
  window["hapyakDMCallbacks" + eventGuid].onDurationChange = function(evt) {
   durationChange(+evt.videoDuration.split("sc")[0].toFixed(2));
   impl.volume = evt.volume;
  };
  function onStalled() {
   if (!impl.duration || impl.progressAmount < 100) {
    impl.networkState = self.NETWORK_IDLE;
    self.dispatchEvent("stalled");
   } else {
    monitorStalled();
   }
  }
  function monitorStalled() {
   clearTimeout(stalledTimeout);
   stalledTimeout = setTimeout(onStalled, 3e3);
  }
  function updateSize() {
   player.width = impl.width;
   player.height = impl.height;
  }
  function changeSrc(aSrc) {
   destroyPlayer();
   impl.readyState = -1;
   maxReadyState = -1;
   playEventPending = false;
   playingEventPending = false;
   if (impl.networkState !== self.NETWORK_EMPTY) {
    if (impl.networkState === self.NETWORK_LOADING || impl.networkState === self.NETWORK_IDLE) {
     self.dispatchEvent("abort");
    }
    self.dispatchEvent("emptied");
   }
   if (!impl.paused) {
    if (playerReady) {
     player.pause();
    }
    impl.paused = false;
   }
   requestedPlay = !!impl.autoplay;
   impl.seeking = false;
   impl.duration = NaN;
   impl.error = null;
   if (!aSrc) {
    impl.readyState = self.HAVE_NOTHING;
    return;
   }
   if (!self._canPlaySrc(aSrc)) {
    impl.error = {
     name:"MediaError",
     message:"Media Source Not Supported",
     code:window.MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED
    };
    impl.networkState = self.NETWORK_NO_SRC;
    self.dispatchEvent("error");
    return;
   }
   impl.src = aSrc;
   impl.networkState = self.NETWORK_LOADING;
   setReadyState(self.HAVE_NOTHING);
   apiReadyPromise(function() {
    var videoId;
    if (!impl.src) {
     if (player) {
      destroyPlayer();
     }
    }
    existingPlayer = findExistingPlayer(impl.src);
    if (!existingPlayer) {} else {
     player = impl.src;
     impl.src = window.Pg_Video ? window.Pg_Video.urlFull :impl.src.data;
     impl.width = parent.offsetWidth;
     impl.height = parent.offsetHeight;
     if (/[?&]autoplay=/.test(impl.src)) {
      impl.autoplay = !!+impl.src.split("autoplay=")[1][0];
     } else {
      impl.autoplay = false;
     }
    }
    function apiReady() {
     var playVideoIsFunction = typeof player.playVideo === "function", isReady = window.Pg_Video && window.Pg_Video.playerIsReady || playVideoIsFunction;
     function playerIsReady() {
      playerReady = true;
      while (playerReadyCallbacks.length) {
       playerReadyCallbacks.shift()();
      }
     }
     if (isReady) {
      playerIsReady();
      return;
     }
     if (window.DM_Player) {
      isReady = window.DM_Player.players.some(function(obj) {
       return obj.object === player;
      });
      if (isReady && playVideoIsFunction) {
       playerIsReady();
       return;
      }
     }
     setTimeout(apiReady, 100);
    }
    if (existingPlayer) {
     requestedPlay = true;
     apiReady();
    }
    playerReadyPromise(function() {
     window["hapyakDMCallbacks" + eventGuid].onError = function() {
      self.dispatchEvent("error");
     };
     registerEventListener("onError", "window.hapyakDMCallbacks" + eventGuid + ".onError" + eventGuid);
     monitorStalled();
     window["hapyakDMCallbacks" + eventGuid].updateProgress = function(evt) {
      var volume = player.getVolume() / 100, muted = player.isMuted();
      impl.currentTime = evt.mediaTime;
      impl.progressAmount = evt.mediaProgress;
      impl.mediaType = evt.mediaType;
      if (evt.mediaDuration !== impl.duration) {
       window["hapyakDMCallbacks" + eventGuid].onDurationChange({
        videoDuration:evt.mediaDuration + "sc",
        volume:volume
       });
      }
      setReadyState(self.HAVE_CURRENT_DATA);
      if (impl.progressAmount === 100) {
       impl.networkState = self.NETWORK_IDLE;
       setReadyState(self.HAVE_FUTURE_DATA);
      } else {
       impl.networkState = self.NETWORK_LOADING;
       monitorStalled();
      }
      if (impl.volume !== volume || impl.muted !== muted) {
       impl.volume = volume;
       impl.muted = muted;
       self.dispatchEvent("volumeChange");
      }
      self.dispatchEvent("timeupdate");
      return true;
     };
     registerEventListener("onVideoProgress", "window.hapyakDMCallbacks" + eventGuid + ".updateProgress");
     registerEventListener("onVideoMetadata", "window.hapyakDMCallbacks" + eventGuid + ".onDurationChange");
     window["hapyakDMCallbacks" + eventGuid].onSeek = function() {
      impl.seeking = true;
      self.dispatchEvent("seeking");
      if (impl.seeking) {
       impl.seeking = false;
       self.dispatchEvent("seeked");
       return true;
      }
     };
     registerEventListener("onSeek", "window.hapyakDMCallbacks" + eventGuid + ".onSeek");
     window["hapyakDMCallbacks" + eventGuid].onStateChange = function(state) {
      if (state === 0) {
       if (impl.loop) {
        player.seek(0);
        player.playVideo();
       } else {
        impl.ended = true;
       }
       self.dispatchEvent("ended");
       return;
      }
      if (state === 1) {
       if (!impl.duration) {
        durationChange();
       }
       if (!impl.duration) {
        playingEventPending = true;
        return false;
       }
       setReadyState(self.HAVE_CURRENT_DATA);
       setReadyState(self.HAVE_FUTURE_DATA);
       self.dispatchEvent("playing");
       return;
      }
      if (state === 2) {
       impl.paused = true;
       self.dispatchEvent("paused");
      }
      if (state === 3) {}
     };
     registerEventListener("onStateChange", "window.hapyakDMCallbacks" + eventGuid + ".onStateChange");
     if (!impl.duration) {
      if (player.getPlayerState() === 1) {
       playingEventPending = true;
      }
      durationChange();
     }
    });
   }, true);
  }
  function setVolume() {
   player.setVolume(impl.volume * 100);
  }
  function getVolume() {
   return impl.muted > 0 ? impl.muted :impl.volume;
  }
  function setMuted() {
   impl.muted > 0 ? player.mute() :player.unMute();
  }
  function getMuted() {
   return impl.muted > 0;
  }
  function setCurrentTime() {
   player.seekTo(impl.currentTime);
  }
  self._eventNamespace = Popcorn.guid("HTMLDailymotionVideoElementInternal::");
  self.parentNode = parent;
  self._util = Popcorn.extend({}, self._util);
  self._util.type = "Dailymotion";
  self.play = function() {
   function play() {
    player.playVideo();
   }
   requestedPlay = true;
   playerReadyPromise(play, true);
  };
  self.pause = function() {
   function pause() {
    player.pauseVideo();
   }
   playerReadyPromise(pause, true);
  };
  self.load = function() {
   changeSrc(impl.src);
  };
  Object.defineProperties(self, {
   src:{
    get:function() {
     return impl.src;
    },
    set:function(aSrc) {
     if (aSrc !== impl.src) {
      changeSrc(aSrc);
     }
    }
   },
   autoplay:{
    get:function() {
     return impl.autoplay;
    },
    set:function(aValue) {
     impl.autoplay = self._util.isAttributeSet(aValue);
    }
   },
   loop:{
    get:function() {
     return impl.loop;
    },
    set:function(aValue) {
     impl.loop = self._util.isAttributeSet(aValue);
    }
   },
   width:{
    get:function() {
     return parent && parent.offsetWidth || impl.width;
    },
    set:function(aValue) {
     impl.width = aValue;
     playerReadyPromise(updateSize);
    }
   },
   height:{
    get:function() {
     return parent && parent.offsetHeight || impl.height;
    },
    set:function(aValue) {
     impl.height = aValue;
     playerReadyPromise(updateSize);
    }
   },
   currentTime:{
    get:function() {
     return impl.currentTime;
    },
    set:function(aValue) {
     aValue = parseFloat(aValue);
     impl.currentTime = aValue;
     playerReadyPromise(setCurrentTime, true);
    }
   },
   currentSrc:{
    get:function() {
     return impl.src;
    }
   },
   duration:{
    get:function() {
     return impl.duration;
    }
   },
   ended:{
    get:function() {
     return impl.ended;
    }
   },
   paused:{
    get:function() {
     return impl.paused;
    }
   },
   seeking:{
    get:function() {
     return impl.seeking;
    }
   },
   readyState:{
    get:function() {
     return impl.readyState;
    }
   },
   networkState:{
    get:function() {
     return impl.networkState;
    }
   },
   volume:{
    get:function() {
     return getVolume();
    },
    set:function(aValue) {
     aValue = parseFloat(aValue);
     if (aValue < 0 || aValue > 1 || isNaN(aValue)) {
      throw new Error("Volume value must be between 0.0 and 1.0");
     }
     impl.volume = aValue;
     playerReadyPromise(setVolume, true);
     self.dispatchEvent("volumechange");
    }
   },
   muted:{
    get:function() {
     return getMuted();
    },
    set:function(aValue) {
     impl.muted = self._util.isAttributeSet(aValue) && 1 || 0;
     playerReadyPromise(setMuted, true);
     self.dispatchEvent("volumechange");
    }
   },
   error:{
    get:function() {
     return impl.error;
    }
   },
   mediaType:{
    get:function() {
     return impl.mediaType;
    }
   }
  });
 }
 HTMLDailymotionVideoElementInternal.prototype = new Popcorn._MediaElementProto();
 HTMLDailymotionVideoElementInternal.prototype.constructor = HTMLDailymotionVideoElementInternal;
 HTMLDailymotionVideoElementInternal.prototype._canPlaySrc = function(url) {
  return findExistingPlayer(url);
 };
 HTMLDailymotionVideoElementInternal.prototype.canPlayType = function(type) {
  return type === "video/x-dailymotionInternal" ? "probably" :EMPTY_STRING;
 };
 Popcorn.HTMLDailymotionVideoElementInternal = function(id) {
  return new HTMLDailymotionVideoElementInternal(id);
 };
 Popcorn.HTMLDailymotionVideoElementInternal._canPlaySrc = HTMLDailymotionVideoElementInternal.prototype._canPlaySrc;
})(this, this.Popcorn);

define("popcorn.htmldailymotionvideoelement.internal", function() {});

define("player.profile.dailymotioninternal", [ "player.wrappers", "popcorn.htmldailymotionvideoelement.internal" ], function(wrappers) {
 wrappers.dailymotioninternal = {
  id:"dailymotioninternal",
  name:"Dailymotion",
  fn:"HTMLDailymotionVideoElementInternal",
  container:function(container) {
   return container.parentNode;
  }
 };
 return wrappers.dailymotioninternal;
});

define("virtualmediaelement", [ "lodash.noconflict", "rsvp" ], function(_, RSVP) {
 var registry = {}, guidCounter = 0, guid = function(prefix) {
  prefix = prefix || "";
  guidCounter++;
  return prefix + (Date.now() + guidCounter);
 }, apiPromises = {}, timeouts = [], vmeGuid = guid("VirtualMediaElement"), vmeRequire = requirejs.config({
  context:vmeGuid
 }), regex = {
  mimeStart:/^video\/x-/i,
  http:/^https?:/i
 }, readyStateNames = {
  none:1,
  current:2,
  future:3,
  enough:4
 }, properties = {
  volume:false,
  currentTime:false,
  ended:false,
  muted:false,
  paused:false,
  width:false,
  height:false,
  offsetWidth:false,
  offsetHeight:false,
  parentNode:null,
  pause:true,
  play:true,
  addEventListener:true,
  removeEventListener:true
 }, MediaError = function() {
  function MediaError(code) {
   this.code = code || null;
  }
  MediaError.MEDIA_ERR_NONE_ACTIVE = 0;
  MediaError.MEDIA_ERR_ABORTED = 1;
  MediaError.MEDIA_ERR_NETWORK = 2;
  MediaError.MEDIA_ERR_DECODE = 3;
  MediaError.MEDIA_ERR_NONE_SUPPORTED = 4;
  return MediaError;
 }();
 function parseQueryString(str, targetObject, noOverride) {
  var obj = targetObject || {};
  if (str && typeof str === "string") {
   if (str[0] === "?") {
    str = str.substring(1);
   }
   _.forEach(str.split("&"), function(param) {
    var pair = param.split("="), key = pair[0], val = pair[1];
    if (val !== "" && (!noOverride || !(key in obj))) {
     obj[key] = val;
    }
   });
  }
  return obj;
 }
 function nextTickCallback() {
  var fn = timeouts.shift();
  fn();
 }
 function nextTick(callback) {
  if (typeof callback === "function") {
   timeouts.push(callback);
   setTimeout(nextTickCallback, 0);
  }
 }
 function VirtualMediaElement(playerTypeId, definition, container, opts) {
  var options = opts || {}, that = this, wrapper, parent, eventNamespace, apiReadyPromises = apiPromises[playerTypeId], promises = {}, resolvePlayer, rejectPlayer, props = {}, pendingEvents = {}, errorQueue = [], loadCount = 0, listeners = {}, lastProgressEvent = -1, lastTimeUpdate = 0, previousCurrentTime, hasLoadeddata = false, state, eventCallbacks = {
   error:function() {
    if (errorQueue.length) {
     errorQueue.shift();
    }
   }
  };
  function fireError(errorCode) {
   var error = new MediaError(errorCode);
   state.error = error;
   errorQueue.push(error);
   that.dispatchEvent("error");
  }
  function fireProgress() {
   var now = Date.now();
   if (now - lastProgressEvent >= 350) {
    lastProgressEvent = now;
    that.dispatchEvent("progress");
   }
  }
  function fireTimeUpdate(seeked) {
   var now = Date.now();
   if ((seeked || now - lastTimeUpdate > 200) && state.currentTime !== previousCurrentTime) {
    that.dispatchEvent("timeupdate");
    previousCurrentTime = state.currentTime;
    lastTimeUpdate = now;
   }
  }
  function haveMetadata() {
   return state.duration && state.videoWidth && state.videoHeight;
  }
  function setReadyState(readyState) {
   var previousState;
   if (readyState === state.readyState || !haveMetadata()) {
    return;
   }
   if (readyState > that.HAVE_METADATA && !state.readyState) {
    setReadyState(that.HAVE_METADATA);
   }
   previousState = state.readyState;
   state.readyState = readyState;
   if (previousState === that.HAVE_NOTHING && readyState === that.HAVE_METADATA) {
    that.dispatchEvent("loadedmetadata");
   }
   if (previousState === that.HAVE_METADATA && readyState >= that.HAVE_CURRENT_DATA && !hasLoadeddata) {
    that.dispatchEvent("loadeddata");
   }
   if (previousState >= that.HAVE_FUTURE_DATA && readyState <= that.HAVE_CURRENT_DATA) {
    fireTimeUpdate();
    that.dispatchEvent("waiting");
   }
   if (previousState <= that.HAVE_CURRENT_DATA && readyState === that.HAVE_FUTURE_DATA) {
    that.dispatchEvent("canplay");
    if (!state.paused) {
     that.dispatchEvent("playing");
    }
   }
   if (readyState === that.HAVE_ENOUGH_DATA) {
    if (previousState <= that.HAVE_CURRENT_DATA) {
     that.dispatchEvent("canplay");
    }
    if (!state.paused) {
     that.dispatchEvent("playing");
    } else if (state.autoplay) {
     state.paused = false;
     that.play();
    }
    that.dispatchEvent("canplaythrough");
   }
  }
  function evaluateReadyState() {
   if (!haveMetadata()) {
    setReadyState(that.HAVE_NOTHING);
    return;
   }
   if (!state.readyState) {
    setReadyState(that.HAVE_METADATA);
   }
  }
  function destroy() {
   if (promises.playerReady) {
    if (rejectPlayer) {
     rejectPlayer();
    }
    resolvePlayer = null;
    rejectPlayer = null;
    delete promises.playerReady;
   }
   if (typeof wrapper.destroy === "function") {
    wrapper.destroy.call(that, state);
   }
   _.forEach(props, function(prop, key) {
    delete props[key];
   });
   delete state.player;
   state.readyState = that.HAVE_NOTHING;
   if (state.networkState !== that.NETWORK_EMPTY) {
    if (state.networkState === that.NETWORK_LOADING || state.networkState === that.NETWORK_IDLE) {
     that.dispatchEvent("abort");
    }
    that.dispatchEvent("emptied");
   }
   lastProgressEvent = -1;
   hasLoadeddata = false;
   evaluateReadyState();
  }
  function isPotentiallyPlaying() {
   return !state.paused && !state.ended && !state.error;
  }
  function changeSrc() {
   var src = state.src, currentLoadCount = loadCount;
   function loadFail(err, code) {
    if (_.isNumber(err)) {
     code = err;
    }
    if (loadCount === currentLoadCount) {
     state.networkState = that.NETWORK_NO_SOURCE;
     fireError(code || MediaError.MEDIA_ERR_NETWORK);
    }
   }
   if (state.currentSrc === src) {
    return;
   }
   if (state.networkState !== that.NETWORK_EMPTY) {
    if (state.networkState === that.NETWORK_LOADING || state.networkState === that.NETWORK_IDLE) {
     that.dispatchEvent("abort");
    }
    that.dispatchEvent("emptied");
   }
   destroy();
   state.paused = true;
   state.seeking = false;
   state.currentTime = 0;
   state.duration = NaN;
   state.playBackRate = 1;
   state.error = null;
   state.videoWidth = 0;
   state.videoHeight = 0;
   state.ended = false;
   errorQueue.length = 0;
   if (!src) {
    return;
   }
   if (!that._canPlaySrc(src)) {
    fireError(MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED);
    state.networkState = that.NETWORK_NO_SRC;
    return;
   }
   state.currentSrc = src;
   state.networkState = that.NETWORK_LOADING;
   that.dispatchEvent("loadstart");
   _.forEach(wrapper.apiRequires, function(url, key) {
    var path, protocol;
    if (!apiReadyPromises[key]) {
     protocol = window.location.protocol;
     if (protocol === "file:") {
      protocol = "http:";
     }
     if (typeof url === "function") {
      url = url(options);
     }
     if (typeof url === "string") {
      url = url.replace(regex.http, protocol);
     } else if (typeof url === "object" && url["isPath"]) {
      path = url = url["path"];
     } else if (url) {
      url = url[protocol.slice(0, -1)];
     }
     if (!url) {
      return;
     }
     apiReadyPromises[key] = new RSVP.Promise(function(resolve, reject) {
      var shim, sources;
      var paths = {};
      if (path) {
       paths[key] = path;
       url = null;
      }
      if (window[key]) {
       resolve(window[key]);
       return;
      }
      shim = {};
      if (url) {
       shim[url] = {
        exports:key
       };
      }
      vmeRequire = requirejs.config({
       context:vmeGuid,
       shim:shim,
       paths:paths
      });
      sources = Object.keys(paths);
      if (url) {
       sources.push(url);
      }
      vmeRequire(sources, function(obj) {
       fireProgress();
       resolve(obj);
      }, reject);
     });
    }
   });
   if (typeof registry[playerTypeId].loadApi === "function" && !apiReadyPromises[""]) {
    apiReadyPromises[""] = new RSVP.Promise(function(resolve, reject) {
     registry[playerTypeId].loadApi(vmeRequire, resolve, reject);
    });
   }
   promises.playerReady = new RSVP.Promise(function(resolve, reject) {
    resolvePlayer = function(player) {
     if (player && typeof player === "object") {
      state.player = player;
     }
     if (!state.player || typeof state.player !== "object") {
      rejectPlayer();
      return;
     }
     resolve(state.player);
    };
    rejectPlayer = reject;
   });
   RSVP.hash(apiReadyPromises).then(function(results) {
    fireProgress();
    if (typeof wrapper.player === "function") {
     if (typeof registry[playerTypeId].findExisting === "function") {
      state.existingPlayer = registry[playerTypeId].findExisting(state.src);
     }
     state.player = wrapper.player(results, resolvePlayer, rejectPlayer);
     if (wrapper.events) {
      that._util.events = wrapper.events;
     }
     _.forEach(properties, function(isMethod, property) {
      if (typeof wrapper[property] === "function") {
       props[property] = wrapper[property];
      }
     });
     if (state.player && typeof state.player === "object") {
      resolvePlayer(state.player);
     }
    }
   }, loadFail);
   promises.playerReady.then(function(player) {
    _.forEach(properties, function(isMethod, property) {
     var prop = wrapper[property] || property;
     if (typeof prop === "function") {
      props[property] = prop;
     } else if (typeof prop === "string" && prop) {
      if (typeof player[prop] === "function") {
       props[property] = function(val) {
        return player[prop](val);
       };
      } else if (prop in player) {
       if (isMethod) {
        props[property] = function() {
         return player[prop](arguments);
        };
       } else {
        props[property] = function(val) {
         if (val === undefined) {
          return player[prop];
         }
         player[prop] = val;
         return val;
        };
       }
      }
     }
    });
    if (!state.paused) {
     props.play();
    }
   }, loadFail);
  }
  parent = typeof container === "string" ? document.querySelector(container) :container;
  eventNamespace = vmeGuid + "::";
  state = {
   existingPlayer:null,
   player:null,
   src:"",
   currentSrc:"",
   networkState:that.NETWORK_EMPTY,
   readyState:that.HAVE_NOTHING,
   seeking:false,
   autoplay:false,
   preload:"",
   controls:false,
   loop:false,
   poster:"",
   volume:1,
   muted:0,
   currentTime:0,
   duration:NaN,
   ended:false,
   paused:true,
   playing:false,
   width:undefined,
   height:undefined,
   error:null,
   progressAmount:null,
   videoHeight:0,
   videoWidth:0,
   setDuration:function(duration) {
    if (state.duration !== duration) {
     state.duration = duration;
     that.dispatchEvent("durationchange");
     evaluateReadyState();
    }
   },
   setDimensions:function(width, height) {
    if (state.videoHeight !== height || state.videoWidth !== width) {
     state.videoHeight = height;
     state.videoWidth = width;
     that.dispatchEvent("resize");
     evaluateReadyState();
    }
   },
   setReadyState:function(readyState) {
    if (typeof readyState === "string") {
     readyState = readyStateNames[readyState];
    }
    if (_.isNumber(state.readyState) && readyState >= 1 && readyState <= 4) {
     setReadyState(readyState);
    }
   },
   setCurrentTime:function(currentTime) {
    if (_.isNaN(currentTime)) {
     currentTime = props.currentTime && props.currentTime();
     if (currentTime === undefined) {
      return;
     }
    }
    if (currentTime >= 0 && currentTime < state.duration && state.currentTime !== currentTime) {
     state.currentTime = currentTime;
     fireTimeUpdate();
    }
   },
   setVolume:function(volume) {
    if (volume >= 0 && volume <= 1 && state.volume !== volume) {
     state.volume = volume;
     that.dispatchEvent("volumechange");
    }
   },
   setMuted:function(muted) {
    if (muted !== state.muted) {
     state.muted = muted;
     that.dispatchEvent("volumechange");
    }
   },
   setPlay:function() {
    if (state.paused) {
     state.paused = false;
     that.dispatchEvent("play");
    }
   },
   setPaused:function() {
    if (!state.paused) {
     state.paused = true;
     that.dispatchEvent("pause");
    }
   },
   setSeeking:function() {
    if (!state.seeking) {
     state.seeking = true;
     that.dispatchEvent("seeking");
    }
   },
   setSeeked:function() {
    state.setSeeking();
    fireTimeUpdate(true);
    state.seeking = false;
    that.dispatchEvent("seeked");
   },
   setEnded:function() {
    state.ended = true;
    that.dispatchEvent("ended");
   }
  };
  this.play = function() {
   if (state.paused) {
    state.paused = false;
    that.dispatchEvent("play");
    if (props.play) {
     props.play();
    }
   }
  };
  this.pause = function() {
   if (!state.paused) {
    state.paused = true;
    that.dispatchEvent("pause");
    if (props.pause) {
     props.pause();
    }
   }
  };
  this.load = function() {
   if (state.src !== state.currentSrc) {
    loadCount++;
    changeSrc();
   }
  };
  this.addEventListener = function(type, listener, useCapture) {
   var listenersByType, list, i, obj;
   if (typeof listener === "function") {
    listenersByType = listeners[type];
    if (!listenersByType) {
     listenersByType = listeners[type] = [ [], [] ];
    }
    list = listenersByType[useCapture ? 1 :0];
    for (i = list.length - 1; i >= 0; i--) {
     if (list[i].listener === listener) {
      return;
     }
    }
    if (i < 0) {
     obj = {
      listener:listener,
      callback:function(evt) {
       if (obj.loadCount === loadCount) {
        listener(evt);
       }
      },
      loadCount:loadCount
     };
     list.push(obj);
     document.addEventListener(eventNamespace + type, obj.callback, useCapture);
    }
   }
  };
  this.removeEventListener = function(type, listener, useCapture) {
   var listenersByType, list, i, obj;
   if (typeof listener === "function") {
    listenersByType = listeners[type];
    if (!listenersByType) {
     return;
    }
    list = listenersByType[useCapture ? 1 :0];
    for (i = list.length - 1; i >= 0; i--) {
     obj = list[i];
     if (obj.listener === listener) {
      document.removeEventListener(eventNamespace + type, obj.callback, useCapture);
      list.splice(i, 1);
      return;
     }
    }
   }
  };
  this.dispatchEvent = function(name) {
   var customEvent, detail = {
    type:name,
    target:this.parentNode,
    data:null
   };
   function dispatch() {
    pendingEvents[name]--;
    document.dispatchEvent(customEvent);
    if (eventCallbacks[name]) {
     eventCallbacks[name](customEvent);
    }
   }
   try {
    customEvent = document.createEvent("CustomEvent");
    customEvent.initCustomEvent(eventNamespace + name, false, false, detail);
   } catch (e) {
    customEvent = document.createEvent("HTMLEvents");
    customEvent.initEvent(eventNamespace + name, false, false);
    customEvent.type = name;
    customEvent.target = detail.target;
   }
   if (pendingEvents[name]) {
    pendingEvents[name]++;
   } else {
    pendingEvents[name] = 1;
   }
   nextTick(dispatch);
  };
  this._util = {
   type:playerTypeId,
   destroy:function() {
    _.forEach(listeners, function(listenersByType, type) {
     _.forEach(listenersByType, function(list, useCapture) {
      _.forEach(list, function(obj) {
       document.removeEventListener(eventNamespace + type, obj.callback, !!useCapture);
      });
     });
     delete listeners[type];
    });
    destroy();
   },
   guid:guid,
   parseQueryString:parseQueryString,
   nextTick:nextTick
  };
  this.canPlayType = function(mimeType) {
   var result;
   if (!mimeType || typeof mimeType !== "string") {
    return "";
   }
   if (typeof wrapper.canPlayType === "function") {
    result = wrapper.canPlayType(mimeType);
    if (result) {
     return result;
    }
   } else if (wrapper.canPlayType instanceof RegExp) {
    if (wrapper.canPlayType.test(mimeType)) {
     return "probably";
    }
   } else if (typeof wrapper.canPlayType === "string" && mimeType === wrapper.canPlayType) {
    return "probably";
   }
   if (regex.mimeStart.test(mimeType) && mimeType.toLowerCase().substr(8) === playerTypeId.toLowerCase()) {
    return "probably";
   }
   return "";
  };
  Object.defineProperties(that, {
   src:{
    get:function() {
     return state.src;
    },
    set:function(src) {
     if (state.src !== src) {
      state.src = src;
     }
     if (!loadCount) {
      changeSrc();
     }
    }
   },
   autoplay:{
    get:function() {
     return state.autoplay;
    },
    set:function(val) {
     state.autoplay = !!val;
    }
   },
   loop:{
    get:function() {
     return state.loop;
    },
    set:function(val) {
     state.loop = !!val;
    }
   },
   controls:{
    get:function() {
     return state.controls;
    },
    set:function(val) {
     state.controls = !!val;
    }
   },
   width:{
    get:function() {
     return state.width === undefined ? 0 :state.width;
    },
    set:function(width) {
     width = parseInt(width, 10);
     if (isNaN(width) || width < 0) {
      width = 0;
     }
     state.width = width;
     if (props.width) {
      props.width(width);
     }
    }
   },
   height:{
    get:function() {
     return state.height === undefined ? 0 :state.height;
    },
    set:function(height) {
     height = parseInt(height, 10);
     if (isNaN(height) || height < 0) {
      height = 0;
     }
     state.height = height;
     if (props.height) {
      props.height(height);
     }
    }
   },
   currentTime:{
    get:function() {
     var currentTime;
     if (props.currentTime) {
      currentTime = props.currentTime();
      if (currentTime !== undefined) {
       state.currentTime = currentTime;
      }
     }
     return state.currentTime;
    },
    set:function(val) {
     if (state.readyState < that.HAVE_METADATA) {
      throw new Error("Cannot seek without metadata");
     }
     if (props.currentTime) {
      props.currentTime(val);
     }
    }
   },
   volume:{
    get:function() {
     var volume;
     if (props.volume) {
      volume = props.volume();
     }
     if (volume !== undefined) {
      state.volume = volume;
     }
     return state.volume;
    },
    set:function(val) {
     val = Math.min(Math.max(val, 0), 1);
     if (props.volume) {
      props.volume(val);
     }
    }
   },
   muted:{
    get:function() {
     return state.muted;
    },
    set:function(val) {
     if (props.muted) {
      props.muted(!!val);
     } else if (props.volume) {
      props.volume(0);
     }
    }
   },
   currentSrc:{
    get:function() {
     return state.currentSrc;
    }
   },
   duration:{
    get:function() {
     return state.duration;
    }
   },
   ended:{
    get:function() {
     return state.ended;
    }
   },
   paused:{
    get:function() {
     return state.paused;
    }
   },
   seeking:{
    get:function() {
     if (pendingEvents.seeked) {
      return true;
     }
     return state.seeking;
    }
   },
   readyState:{
    get:function() {
     return state.readyState;
    }
   },
   networkState:{
    get:function() {
     return state.networkState;
    }
   },
   videoWidth:{
    get:function() {
     return props.videoWidth ? props.videoWidth() :state.videoWidth;
    }
   },
   videoHeight:{
    get:function() {
     return props.videoHeight ? props.videoHeight() :state.videoHeight;
    }
   },
   offsetWidth:{
    get:function() {
     if (props.offsetWidth) {
      return props.offsetWidth();
     }
    }
   },
   offsetHeight:{
    get:function() {
     if (props.offsetHeight) {
      return props.offsetHeight();
     }
    }
   },
   error:{
    get:function() {
     return errorQueue.length && errorQueue[0] || state.error;
    }
   },
   parentNode:{
    get:function() {
     return props.parentNode ? props.parentNode() :parent;
    }
   }
  });
  wrapper = definition.call(this, state, parent, options);
 }
 VirtualMediaElement.prototype = {
  NETWORK_EMPTY:0,
  NETWORK_IDLE:1,
  NETWORK_LOADING:2,
  NETWORK_NO_SOURCE:3,
  HAVE_NOTHING:0,
  HAVE_METADATA:1,
  HAVE_CURRENT_DATA:2,
  HAVE_FUTURE_DATA:3,
  HAVE_ENOUGH_DATA:4,
  getBoundingClientRect:function() {
   return this.parentNode.getBoundingClientRect();
  }
 };
 VirtualMediaElement.register = function(playerTypeId, definition, opts) {
  var Wrapper, options = opts || {};
  if (playerTypeId) {
   Wrapper = function(container, opts) {
    var obj = new VirtualMediaElement(playerTypeId, definition, container, opts);
    obj._canPlaySrc = Wrapper._canPlaySrc;
    obj._utils = Wrapper._utils;
    return obj;
   };
   VirtualMediaElement[playerTypeId] = Wrapper;
   Wrapper._canPlaySrc = function(src) {
    var result;
    if (typeof options.findExisting === "function") {
     result = options.findExisting(src);
     if (result) {
      if (typeof result !== "string") {
       result = "probably";
      }
      return result;
     }
    }
    if (typeof options.canPlaySrc === "function") {
     result = options.canPlaySrc(src);
     if (result) {
      if (typeof result !== "string") {
       result = "probably";
      }
      return result;
     }
    } else if (options.canPlaySrc instanceof RegExp && options.canPlaySrc.test(src)) {
     return "probably";
    }
    return "";
   };
   if (_.isObject(options.utils)) {
    Wrapper._utils = options.utils;
   }
   registry[playerTypeId] = {
    wrapper:Wrapper,
    definition:definition,
    findExisting:options.findExisting,
    canPlaySrc:options.canPlaySrc,
    loadApi:options.loadApi
   };
   apiPromises[playerTypeId] = {};
   return Wrapper;
  }
 };
 return VirtualMediaElement;
});

define("player.dailymotionv5", [ "virtualmediaelement" ], function(VirtualMediaElement) {
 return VirtualMediaElement.register("dailymotionv5", function(state, parent, options) {
  options = options || {};
  var forceReadyState = options.forceReadyState, me = this, volumeBackup = 0;
  var player;
  function isHTMLMode() {
   var elem = document.createElement("video");
   return !!(elem.canPlayType && elem.canPlayType("video/mp4"));
  }
  function onCanPlay() {
   if (!state.duration && player.duration) {
    onDurationChange();
   }
  }
  function onDurationChange() {
   state.setDuration(player.duration);
   me._util.nextTick(function() {
    state.setReadyState(me.HAVE_ENOUGH_DATA);
   });
  }
  function updateProgress() {
   if (!state.duration && player.duration) {
    onDurationChange();
   }
  }
  function onTimeupdate() {
   state.setCurrentTime(player.currentTime);
  }
  function onVolumeChange() {
   if (!state.muted) {
    state.setVolume(player.volume);
    if (!player.volume) {
     state.setMuted(true);
    }
   }
  }
  function onPlay() {
   state.setPlay();
  }
  function onSeek() {
   state.setSeeking();
  }
  function onSeeked() {
   state.setCurrentTime(player.currentTime);
   state.setSeeked();
  }
  function onPause() {
   state.setPaused();
  }
  function onEnded() {
   state.setEnded();
  }
  return {
   apiRequires:{
    DM:"//api.dmcdn.net/all.js"
   },
   player:function(resources, resolve) {
    var DM = resources.DM, htmlMode = isHTMLMode();
    var height, playerParams, sacrificialContainer, width;
    function onPlayerReady() {
     player.removeEventListener("apiready", onPlayerReady);
     player.addEventListener("progress", updateProgress);
     player.addEventListener("durationchange", onDurationChange);
     player.addEventListener("canplay", onCanPlay);
     player.addEventListener("canplaythrough", onCanPlay);
     player.addEventListener("timeupdate", onTimeupdate);
     player.addEventListener("volumechange", onVolumeChange);
     player.addEventListener("playing", onPlay);
     player.addEventListener("seeking", onSeek);
     player.addEventListener("seeked", onSeeked);
     player.addEventListener("pause", onPause);
     player.addEventListener("ended", onEnded);
     state.volume = player.volume;
     updateProgress();
     if (forceReadyState) {
      player.addEventListener("playing", function onFirstPlay() {
       player.removeEventListener("playing", onFirstPlay);
       player.pause();
      });
      player.play();
     }
     width = parseInt(state.existingPlayer ? player.width :parent.offsetWidth, 10);
     height = parseInt(state.existingPlayer ? player.height :parent.offsetHeight, 10);
     state.setDimensions(width, height);
     resolve(player);
    }
    if (state.existingPlayer) {
     player = state.src;
     onPlayerReady();
    } else {
     sacrificialContainer = document.createElement("div");
     parent.appendChild(sacrificialContainer);
     playerParams = {
      autoplay:+state.autoplay,
      annotations:0,
      info:0,
      related:0,
      controls:htmlMode ? "html" :"flash",
      chromeless:state.controls ? 0 :1,
      html:htmlMode,
      logo:!htmlMode ? 1 :0,
      GK_PV5:1
     };
     if (forceReadyState) {
      playerParams["advertising-enable"] = 0;
     }
     player = DM.player(sacrificialContainer, {
      video:/video\/([a-z0-9]+)/i.exec(state.src)[1],
      width:state.width,
      height:state.height,
      params:playerParams
     });
     player.addEventListener("apiready", onPlayerReady);
    }
   },
   play:function() {
    if (player) {
     player.play();
    }
   },
   pause:function() {
    if (player) {
     player.pause();
    }
   },
   currentTime:function(time) {
    if (time !== undefined && player) {
     player.seek(time);
    }
   },
   volume:function(volume) {
    if (volume !== undefined && player) {
     player.setVolume(volume);
    }
   },
   muted:function(val) {
    if (player) {
     if (val) {
      volumeBackup = state.volume;
      player.setVolume(0);
      state.setMuted(true);
     } else if (val === false) {
      player.setVolume(volumeBackup);
      state.setMuted(false);
     }
     return state.muted;
    }
   },
   destroy:function() {
    if (player && player.removeEventListener) {
     player.removeEventListener("progress", updateProgress);
     player.removeEventListener("durationchange", onDurationChange);
     player.removeEventListener("canplay", onCanPlay);
     player.removeEventListener("canplaythrough", onCanPlay);
     player.removeEventListener("timeupdate", onTimeupdate);
     player.removeEventListener("volumechange", onVolumeChange);
     player.removeEventListener("playing", onPlay);
     player.removeEventListener("seeking", onSeek);
     player.removeEventListener("seeked", onSeeked);
     player.removeEventListener("pause", onPause);
     player.removeEventListener("ended", onEnded);
    }
   },
   width:function(width) {
    if (width !== undefined && player) {
     player.width = width;
    }
   },
   height:function(height) {
    if (height !== undefined && player) {
     player.height = height;
    }
   },
   offsetWidth:function() {
    return parent && parent.offsetWidth || 0;
   },
   offsetHeight:function() {
    return parent && parent.offsetHeight || 0;
   },
   parentNode:function() {
    var elem;
    if (player instanceof Element) {
     elem = player;
    } else if (player && player.id) {
     elem = document.getElementById(player.id).parentNode;
    }
    return elem;
   }
  };
 }, {
  findExisting:function(obj) {
   if (obj instanceof window.HTMLIFrameElement) {
    return "probably";
   }
   return "";
  },
  canPlaySrc:function(src) {
   return typeof src === "string";
  }
 });
});

define("player.profile.dailymotionv5", [ "popcorn", "player.wrappers", "player.dailymotionv5" ], function(Popcorn, wrappers, HTMLDailymotionV5VideoElement) {
 Popcorn.HTMLDailymotionV5VideoElement = HTMLDailymotionV5VideoElement;
 wrappers.dailymotionv5 = {
  id:"dailymotionv5",
  name:"Dailymotion V5",
  fn:"HTMLDailymotionV5VideoElement",
  pre:"//www.dailymotion.com/video/",
  args:function(video, options) {
   return [ options.playerParameters ];
  },
  container:function(container, wrapper) {
   var elem = container.parentNode || document.createElement("div");
   if (elem.parentNode) {
    return elem;
   }
   wrapper.addEventListener("canplay", function onDailymotionCanPlay() {
    wrapper.removeEventListener("canplay", onDailymotionCanPlay, false);
    if (container.player && container.player.parentNode) {
     container.player.parentNode.appendChild(elem);
    }
   }, false);
   elem.style.position = "static";
   container.ui.root[0].parentNode.appendChild(elem);
   return elem;
  }
 };
 return wrappers.dailymotionv5;
});

define("popcorn.hotlink", [ "popcorn", "player.playereval", "popcorn.base" ], function(Popcorn, playereval) {
 Popcorn.basePlugin("hotlink", function(options, base) {
  var container, img = document.createElement("img"), textContainer, templateEvaluator = new playereval.TemplateEvaluator(this, options);
  function setDimensions() {
   container.style.width = options.width = options.width || "40%";
   container.style.height = options.height = options.height || "40%";
   container.style.top = options.top = options.top || "10%";
   container.style.left = options.left = options.left || "10%";
  }
  function setText() {
   var text, i;
   text = templateEvaluator.evaluate(options.text);
   if (!text) {
    if (textContainer) {
     container.removeChild(textContainer);
     textContainer = null;
    }
    return;
   }
   if (textContainer) {
    textContainer.innerHTML = "";
   } else {
    textContainer = document.createElement("div");
    container.appendChild(textContainer);
   }
   text = String(text).split(/[\n\r]/);
   for (i = 0; i < text.length; i++) {
    if (i) {
     textContainer.appendChild(document.createElement("br"));
    }
    if (text[i]) {
     textContainer.appendChild(document.createTextNode(text[i]));
    }
   }
   textContainer.className = "popcorn-hotlink-text";
   base.addClass(textContainer, options.textPosition);
   textContainer.style.color = options.color;
  }
  container = base.makeContainer();
  options.container = container;
  setDimensions();
  container.style.opacity = options.opacity || "";
  container.style.backgroundColor = options.backgroundColor || "";
  container.style.borderColor = options.borderColor || "";
  container.style.borderRadius = options.borderRadius || "";
  if (options.borderWidth && options.borderWidth.replace("px", "") > 0) {
   container.style.borderStyle = "solid";
   container.style.borderWidth = options.borderWidth;
  }
  img.style.width = "100%";
  img.style.height = "100%";
  img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
  container.appendChild(img);
  setText();
  templateEvaluator.watchTemplateVars(options.text, setText);
  if (options.pause) {
   base.pause(options.pause === true ? 2 :options.pause);
  }
  return {
   start:function() {
    base.addClass(container, "active");
   },
   end:function() {
    base.removeClass(container, "active");
   },
   _update:function(trackEvent, changes) {
    var modifyText = false;
    templateEvaluator.watchTemplateVars(options.text, setText);
    if (changes.hasOwnProperty("opacity") && changes.opacity !== options.opacity) {
     options.opacity = changes.opacity;
     container.style.opacity = options.opacity || "";
    }
    if (changes.hasOwnProperty("text") && changes.text !== options.text) {
     if (!options.text) {
      modifyText = true;
     }
     options.text = changes.text;
     modifyText = true;
    }
    if (changes.hasOwnProperty("textPosition") && changes.textPosition !== options.textPosition) {
     options.textPosition = changes.textPosition;
     modifyText = true;
    }
    if (changes.hasOwnProperty("color") && changes.color !== options.color) {
     options.color = changes.color;
     modifyText = true;
    }
    if (modifyText) {
     setText();
    }
    if (changes.hasOwnProperty("backgroundColor") && changes.backgroundColor !== options.backgroundColor) {
     options.backgroundColor = changes.backgroundColor;
     container.style.backgroundColor = options.backgroundColor || "";
    }
    if (changes.hasOwnProperty("borderColor") && changes.borderColor !== options.borderColor) {
     options.borderColor = changes.borderColor;
     container.style.borderColor = options.borderColor || "";
    }
    if (changes.hasOwnProperty("borderRadius") && changes.borderRadius !== options.borderRadius) {
     options.borderRadius = changes.borderRadius;
     container.style.borderRadius = options.borderRadius || "";
    }
    if (changes.hasOwnProperty("borderWidth") && changes.borderWidth !== options.borderWidth) {
     options.borderWidth = changes.borderWidth;
     if (options.borderWidth && options.borderWidth.replace("px", "") > 0) {
      container.style.borderStyle = "solid";
      container.style.borderWidth = options.borderWidth;
     }
    }
    if (changes.hasOwnProperty("top") && changes.top !== options.top) {
     options.top = changes.top;
    }
    if (changes.hasOwnProperty("left") && changes.left !== options.left) {
     options.left = changes.left;
    }
    if (changes.hasOwnProperty("height") && changes.height !== options.height) {
     options.height = changes.height;
    }
    if (changes.hasOwnProperty("width") && changes.width !== options.width) {
     options.width = changes.width;
    }
    if (changes.hasOwnProperty("pause") && changes.pause !== options.pause) {
     if (changes.pause) {
      base.pause(changes.pause === true ? 2 :changes.pause);
     } else {
      base.cancelPause();
     }
     options.pause = changes.pause;
    }
    setDimensions();
   }
  };
 });
});

define("popcorn.profile.hotlink", [ "utils.parsecolor", "player.normalizeonclick", "player.normalizecolor", "popcorn.hotlink" ], function(parseColor, normalizeonclick, normalizeColor) {
 return {
  id:"hotlink",
  title:"Hot Spot",
  icon:"&#xE001;",
  editor:[ "popcorn.quickedit.hotlink" ],
  sortIndex:2,
  zIndex:6,
  normalize:{
   "onClick.gotoLink":normalizeonclick.gotoLink,
   "onClick.gotoTrack":normalizeonclick.gotoTrack,
   "onClick.addClasses":normalizeonclick.addClasses,
   "onClick.setVariables":normalizeonclick.setVariables,
   onClick:normalizeonclick.onClick,
   textPosition:function(value) {
    if (!value) {
     return "middle";
    }
    if (value === "top" || value === "middle" || value === "bottom") {
     return value;
    }
    return false;
   },
   backgroundColor:normalizeColor,
   "background-color":normalizeColor,
   color:normalizeColor
  },
  filter:function(trackEvent) {
   var color;
   if (!trackEvent.backgroundColor || isNaN(trackEvent.opacity) || trackEvent.opacity >= 1) {
    return trackEvent;
   }
   color = parseColor(trackEvent.backgroundColor);
   if (color && color.a === undefined) {
    trackEvent.backgroundColor = "rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + trackEvent.opacity + ")";
    delete trackEvent.opacity;
   }
   return trackEvent;
  }
 };
});

(function(root, factory) {
 if (typeof exports === "object") {
  var Popcorn = require("popcorn");
  require("popcorn.filter");
  require("popcorn.data");
  module.exports = factory(Popcorn);
 } else if (typeof define === "function" && define.amd) {
  define("popcorn.gates", [ "popcorn", "popcorn.filter", "popcorn.data" ], factory);
 } else {
  factory(root.Popcorn);
 }
})(this, function(Popcorn, popcornfilter, undefined) {
 var instances = {};
 function checkGates(instance, update) {
  var popcorn = instance.popcorn;
  var gatedClass = "hapyak-is-gated", hapyakPlayer = popcorn.options && popcorn.options.hapyakPlayer;
  if (update) {
   instance.minGate = Infinity;
   Popcorn.forEach(popcorn.getTrackEvents(), function(trackEvent) {
    if (trackEvent && trackEvent.gate && !popcorn.getData(trackEvent._id, "condition")) {
     instance.minGate = Math.min(instance.minGate, trackEvent.start);
    }
   });
  }
  if (instance.editMode) {
   if (hapyakPlayer) {
    hapyakPlayer.removeClass(gatedClass);
   }
   return false;
  }
  if (popcorn.currentTime() >= instance.minGate) {
   if (hapyakPlayer) {
    hapyakPlayer.addClass(gatedClass);
   }
   instance.gateLocked = true;
   popcorn.pause();
   if (popcorn.currentTime() - instance.minGate >= .4) {
    popcorn.currentTime(instance.minGate);
   }
   return true;
  }
  if (instance.gateLocked) {
   if (hapyakPlayer) {
    hapyakPlayer.removeClass(gatedClass);
   }
   instance.gateLocked = false;
   popcorn.play();
  }
  return false;
 }
 Popcorn.dataFilter([ "editMode", "condition" ], "gates", "", function(name, options, next, node, editMode) {
  var instance = instances[this.id];
  if (instance) {
   instance.editMode = editMode;
  } else {
   instance = {
    popcorn:this,
    minGate:Infinity,
    gateLocked:false,
    editMode:editMode,
    timeupdate:function() {
     checkGates(instance);
    }
   };
   instances[this.id] = instance;
   this.on("timeupdate", instance.timeupdate);
  }
  next(options);
  checkGates(instance, true);
 }, true, function() {
  var instance = instances[this.id];
  if (!instance) {
   return;
  }
  if (this.data.trackEvents.byStart.length < 2 || this.data.trackEvents.byStart.length === 2 && !this.data.trackEvents.byStart[1]._natives) {
   this.off("timeupdate", instance.timeupdate);
   checkGates(instance, true);
   delete instances[this.id];
   return;
  }
  checkGates(instance, true);
 });
 Popcorn.p.checkGates = function(update) {
  var instance = instances[this.id];
  if (instance) {
   return checkGates(instance, update);
  }
  return false;
 };
});

(function(window, Popcorn, undefined) {
 var document = window.document;
 Popcorn.basePlugin("image", function(options, base) {
  var popcorn, video, container, img, pause, link, linkClickHandler;
  function setImageDimensions() {
   if (container.style.width) {
    img.style.width = "100%";
   } else {
    img.style.width = "";
   }
   if (container.style.height) {
    img.style.height = "100%";
   } else {
    img.style.height = "";
   }
  }
  if (!base.target) {
   return;
  }
  popcorn = this;
  video = popcorn.media;
  container = base.makeContainer();
  options.container = container;
  img = document.createElement("img");
  img.src = options.url || "";
  img.removeAttribute("width");
  img.removeAttribute("height");
  img.addEventListener("load", function() {
   if (typeof options.onLoad === "function") {
    options.onLoad(options);
   }
  }, true);
  base.animate();
  container.appendChild(img);
  if (options.pause) {
   pause = options.pause;
   base.pause(pause === true ? 2 :pause);
  }
  return {
   start:function() {
    if (base.options.url) {
     base.addClass(base.container, "active");
     setImageDimensions();
    }
   },
   _update:function(trackEvent, changes) {
    if (changes.hasOwnProperty("url") && changes.url !== options.url) {
     img.src = changes.url;
    }
    if (changes.hasOwnProperty("pause") && options.pause !== changes.pause || changes.end !== options.end || changes.start !== options.start) {
     options.pause = changes.pause;
     if (options.pause) {
      base.pause(options.pause === true ? 2 :options.pause);
     } else {
      base.cancelPause();
     }
    }
    setImageDimensions();
   },
   end:function() {
    base.removeClass(base.container, "active");
   }
  };
 }, {
  about:{
   name:"Popcorn Image Plugin",
   version:"0.1",
   author:"Hapyak",
   website:"http://www.hapyak.com"
  },
  options:{
   start:{
    elem:"input",
    type:"number",
    label:"Start",
    units:"seconds"
   },
   end:{
    elem:"input",
    type:"number",
    label:"End",
    units:"seconds"
   },
   url:{
    elem:"input",
    type:"url",
    label:"Source URL"
   },
   width:{
    elem:"input",
    type:"number",
    label:"Width",
    "default":100,
    units:"%",
    hidden:true
   },
   height:{
    elem:"input",
    type:"number",
    label:"Height",
    "default":100,
    units:"%",
    hidden:true
   },
   top:{
    elem:"input",
    type:"number",
    label:"Top",
    "default":0,
    units:"%",
    hidden:true
   },
   left:{
    elem:"input",
    type:"number",
    label:"Left",
    "default":0,
    units:"%",
    hidden:true
   },
   link:{
    elem:"input",
    type:"url",
    label:"Link URL"
   },
   linkTarget:{
    elem:"input",
    type:"text",
    label:"Link Target"
   }
  }
 });
})(this, this.Popcorn);

define("popcorn.image", function() {});

define("popcorn.profile.image", [ "player.normalizeonclick", "player.normalizetransition", "popcorn.image" ], function(normalizeonclick, normalizeTransition) {
 return function(options) {
  var uploadAuth = options.uploadAuth;
  return {
   id:"image",
   title:"Image",
   icon:"&#x1F304;",
   editor:[ "popcorn.quickedit.image" ],
   sortIndex:2,
   zIndex:3,
   commit:true,
   normalize:{
    "onClick.gotoLink":normalizeonclick.gotoLink,
    "onClick.gotoTrack":normalizeonclick.gotoTrack,
    "onClick.addClasses":normalizeonclick.addClasses,
    "onClick.setVariables":normalizeonclick.setVariables,
    onClick:normalizeonclick.onClick,
    transitionClass:normalizeTransition
   },
   filter:function(trackEvent) {
    if (!trackEvent.url) {
     return false;
    }
   },
   create:function(id, annotation, editor) {
    var commentId = annotation.get("id");
    if (uploadAuth) {
     editor.setting(id, "uploadUrl", "/api/comments/" + commentId + "/uploads?" + uploadAuth);
    }
   }
  };
 };
});

!function(e, n) {
 function r(e, n) {
  var r, t, u = e.toLowerCase();
  for (n = [].concat(n), r = 0; n.length > r; r += 1) if (t = n[r]) {
   if (t.test && t.test(e)) return !0;
   if (t.toLowerCase() === u) return !0;
  }
 }
 var t = n.prototype.trim, u = n.prototype.trimRight, i = n.prototype.trimLeft, l = function(e) {
  return 1 * e || 0;
 }, o = function(e, n) {
  if (1 > n) return "";
  for (var r = ""; n > 0; ) 1 & n && (r += e), n >>= 1, e += e;
  return r;
 }, a = [].slice, c = function(e) {
  return null == e ? "\\s" :e.source ? e.source :"[" + g.escapeRegExp(e) + "]";
 }, s = {
  lt:"<",
  gt:">",
  quot:'"',
  amp:"&",
  apos:"'"
 }, f = {};
 for (var p in s) f[s[p]] = p;
 f["'"] = "#39";
 var h = function() {
  function e(e) {
   return Object.prototype.toString.call(e).slice(8, -1).toLowerCase();
  }
  var r = o, t = function() {
   return t.cache.hasOwnProperty(arguments[0]) || (t.cache[arguments[0]] = t.parse(arguments[0])), t.format.call(null, t.cache[arguments[0]], arguments);
  };
  return t.format = function(t, u) {
   var i, l, o, a, c, s, f, p = 1, g = t.length, d = "", m = [];
   for (l = 0; g > l; l++) if (d = e(t[l]), "string" === d) m.push(t[l]); else if ("array" === d) {
    if (a = t[l], a[2]) for (i = u[p], o = 0; a[2].length > o; o++) {
     if (!i.hasOwnProperty(a[2][o])) throw new Error(h('[_.sprintf] property "%s" does not exist', a[2][o]));
     i = i[a[2][o]];
    } else i = a[1] ? u[a[1]] :u[p++];
    if (/[^s]/.test(a[8]) && "number" != e(i)) throw new Error(h("[_.sprintf] expecting number but found %s", e(i)));
    switch (a[8]) {
    case "b":
     i = i.toString(2);
     break;

    case "c":
     i = n.fromCharCode(i);
     break;

    case "d":
     i = parseInt(i, 10);
     break;

    case "e":
     i = a[7] ? i.toExponential(a[7]) :i.toExponential();
     break;

    case "f":
     i = a[7] ? parseFloat(i).toFixed(a[7]) :parseFloat(i);
     break;

    case "o":
     i = i.toString(8);
     break;

    case "s":
     i = (i = n(i)) && a[7] ? i.substring(0, a[7]) :i;
     break;

    case "u":
     i = Math.abs(i);
     break;

    case "x":
     i = i.toString(16);
     break;

    case "X":
     i = i.toString(16).toUpperCase();
    }
    i = /[def]/.test(a[8]) && a[3] && i >= 0 ? "+" + i :i, s = a[4] ? "0" == a[4] ? "0" :a[4].charAt(1) :" ", f = a[6] - n(i).length, 
    c = a[6] ? r(s, f) :"", m.push(a[5] ? i + c :c + i);
   }
   return m.join("");
  }, t.cache = {}, t.parse = function(e) {
   for (var n = e, r = [], t = [], u = 0; n; ) {
    if (null !== (r = /^[^\x25]+/.exec(n))) t.push(r[0]); else if (null !== (r = /^\x25{2}/.exec(n))) t.push("%"); else {
     if (null === (r = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(n))) throw new Error("[_.sprintf] huh?");
     if (r[2]) {
      u |= 1;
      var i = [], l = r[2], o = [];
      if (null === (o = /^([a-z_][a-z_\d]*)/i.exec(l))) throw new Error("[_.sprintf] huh?");
      for (i.push(o[1]); "" !== (l = l.substring(o[0].length)); ) if (null !== (o = /^\.([a-z_][a-z_\d]*)/i.exec(l))) i.push(o[1]); else {
       if (null === (o = /^\[(\d+)\]/.exec(l))) throw new Error("[_.sprintf] huh?");
       i.push(o[1]);
      }
      r[2] = i;
     } else u |= 2;
     if (3 === u) throw new Error("[_.sprintf] mixing positional and named placeholders is not (yet) supported");
     t.push(r);
    }
    n = n.substring(r[0].length);
   }
   return t;
  }, t;
 }(), g = {
  VERSION:"2.3.0",
  isBlank:function(e) {
   return null == e && (e = ""), /^\s*$/.test(e);
  },
  stripTags:function(e) {
   return null == e ? "" :n(e).replace(/<\/?[^>]+>/g, "");
  },
  capitalize:function(e) {
   return e = null == e ? "" :n(e), e.charAt(0).toUpperCase() + e.slice(1);
  },
  chop:function(e, r) {
   return null == e ? [] :(e = n(e), r = ~~r, r > 0 ? e.match(new RegExp(".{1," + r + "}", "g")) :[ e ]);
  },
  clean:function(e) {
   return g.strip(e).replace(/\s+/g, " ");
  },
  count:function(e, r) {
   if (null == e || null == r) return 0;
   e = n(e), r = n(r);
   for (var t = 0, u = 0, i = r.length; ;) {
    if (u = e.indexOf(r, u), -1 === u) break;
    t++, u += i;
   }
   return t;
  },
  chars:function(e) {
   return null == e ? [] :n(e).split("");
  },
  swapCase:function(e) {
   return null == e ? "" :n(e).replace(/\S/g, function(e) {
    return e === e.toUpperCase() ? e.toLowerCase() :e.toUpperCase();
   });
  },
  escapeHTML:function(e) {
   return null == e ? "" :n(e).replace(/[&<>"']/g, function(e) {
    return "&" + f[e] + ";";
   });
  },
  unescapeHTML:function(e) {
   return null == e ? "" :n(e).replace(/\&([^;]+);/g, function(e, r) {
    var t;
    return r in s ? s[r] :(t = r.match(/^#x([\da-fA-F]+)$/)) ? n.fromCharCode(parseInt(t[1], 16)) :(t = r.match(/^#(\d+)$/)) ? n.fromCharCode(~~t[1]) :e;
   });
  },
  escapeRegExp:function(e) {
   return null == e ? "" :n(e).replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
  },
  splice:function(e, n, r, t) {
   var u = g.chars(e);
   return u.splice(~~n, ~~r, t), u.join("");
  },
  insert:function(e, n, r) {
   return g.splice(e, n, 0, r);
  },
  include:function(e, r) {
   return "" === r ? !0 :null == e ? !1 :-1 !== n(e).indexOf(r);
  },
  join:function() {
   var e = a.call(arguments), n = e.shift();
   return null == n && (n = ""), e.join(n);
  },
  lines:function(e) {
   return null == e ? [] :n(e).split("\n");
  },
  reverse:function(e) {
   return g.chars(e).reverse().join("");
  },
  startsWith:function(e, r) {
   return "" === r ? !0 :null == e || null == r ? !1 :(e = n(e), r = n(r), e.length >= r.length && e.slice(0, r.length) === r);
  },
  endsWith:function(e, r) {
   return "" === r ? !0 :null == e || null == r ? !1 :(e = n(e), r = n(r), e.length >= r.length && e.slice(e.length - r.length) === r);
  },
  succ:function(e) {
   return null == e ? "" :(e = n(e), e.slice(0, -1) + n.fromCharCode(e.charCodeAt(e.length - 1) + 1));
  },
  titleize:function(e) {
   return null == e ? "" :(e = n(e).toLowerCase(), e.replace(/(?:^|\s|-)\S/g, function(e) {
    return e.toUpperCase();
   }));
  },
  camelize:function(e) {
   return g.trim(e).replace(/[-_\s]+(.)?/g, function(e, n) {
    return n ? n.toUpperCase() :"";
   });
  },
  underscored:function(e) {
   return g.trim(e).replace(/([a-z\d])([A-Z]+)/g, "$1_$2").replace(/[-\s]+/g, "_").toLowerCase();
  },
  dasherize:function(e) {
   return g.trim(e).replace(/([A-Z])/g, "-$1").replace(/[-_\s]+/g, "-").toLowerCase();
  },
  classify:function(e) {
   return g.titleize(n(e).replace(/[\W_]/g, " ")).replace(/\s/g, "");
  },
  humanize:function(e) {
   return g.capitalize(g.underscored(e).replace(/_id$/, "").replace(/_/g, " "));
  },
  trim:function(e, r) {
   return null == e ? "" :!r && t ? t.call(e) :(r = c(r), n(e).replace(new RegExp("^" + r + "+|" + r + "+$", "g"), ""));
  },
  ltrim:function(e, r) {
   return null == e ? "" :!r && i ? i.call(e) :(r = c(r), n(e).replace(new RegExp("^" + r + "+"), ""));
  },
  rtrim:function(e, r) {
   return null == e ? "" :!r && u ? u.call(e) :(r = c(r), n(e).replace(new RegExp(r + "+$"), ""));
  },
  truncate:function(e, r, t) {
   return null == e ? "" :(e = n(e), t = t || "...", r = ~~r, e.length > r ? e.slice(0, r) + t :e);
  },
  prune:function(e, r, t) {
   if (null == e) return "";
   if (e = n(e), r = ~~r, t = null != t ? n(t) :"...", r >= e.length) return e;
   var u = function(e) {
    return e.toUpperCase() !== e.toLowerCase() ? "A" :" ";
   }, i = e.slice(0, r + 1).replace(/.(?=\W*\w*$)/g, u);
   return i = i.slice(i.length - 2).match(/\w\w/) ? i.replace(/\s*\S+$/, "") :g.rtrim(i.slice(0, i.length - 1)), (i + t).length > e.length ? e :e.slice(0, i.length) + t;
  },
  words:function(e, n) {
   return g.isBlank(e) ? [] :g.trim(e, n).split(n || /\s+/);
  },
  pad:function(e, r, t, u) {
   e = null == e ? "" :n(e), r = ~~r;
   var i = 0;
   switch (t ? t.length > 1 && (t = t.charAt(0)) :t = " ", u) {
   case "right":
    return i = r - e.length, e + o(t, i);

   case "both":
    return i = r - e.length, o(t, Math.ceil(i / 2)) + e + o(t, Math.floor(i / 2));

   default:
    return i = r - e.length, o(t, i) + e;
   }
  },
  lpad:function(e, n, r) {
   return g.pad(e, n, r);
  },
  rpad:function(e, n, r) {
   return g.pad(e, n, r, "right");
  },
  lrpad:function(e, n, r) {
   return g.pad(e, n, r, "both");
  },
  sprintf:h,
  vsprintf:function(e, n) {
   return n.unshift(e), h.apply(null, n);
  },
  toNumber:function(e, n) {
   return e ? (e = g.trim(e), e.match(/^-?\d+(?:\.\d+)?$/) ? l(l(e).toFixed(~~n)) :0 / 0) :0;
  },
  numberFormat:function(e, n, r, t) {
   if (isNaN(e) || null == e) return "";
   e = e.toFixed(~~n), t = "string" == typeof t ? t :",";
   var u = e.split("."), i = u[0], l = u[1] ? (r || ".") + u[1] :"";
   return i.replace(/(\d)(?=(?:\d{3})+$)/g, "$1" + t) + l;
  },
  strRight:function(e, r) {
   if (null == e) return "";
   e = n(e), r = null != r ? n(r) :r;
   var t = r ? e.indexOf(r) :-1;
   return ~t ? e.slice(t + r.length, e.length) :e;
  },
  strRightBack:function(e, r) {
   if (null == e) return "";
   e = n(e), r = null != r ? n(r) :r;
   var t = r ? e.lastIndexOf(r) :-1;
   return ~t ? e.slice(t + r.length, e.length) :e;
  },
  strLeft:function(e, r) {
   if (null == e) return "";
   e = n(e), r = null != r ? n(r) :r;
   var t = r ? e.indexOf(r) :-1;
   return ~t ? e.slice(0, t) :e;
  },
  strLeftBack:function(e, n) {
   if (null == e) return "";
   e += "", n = null != n ? "" + n :n;
   var r = e.lastIndexOf(n);
   return ~r ? e.slice(0, r) :e;
  },
  toSentence:function(e, n, r, t) {
   n = n || ", ", r = r || " and ";
   var u = e.slice(), i = u.pop();
   return e.length > 2 && t && (r = g.rtrim(n) + r), u.length ? u.join(n) + r + i :i;
  },
  toSentenceSerial:function() {
   var e = a.call(arguments);
   return e[3] = !0, g.toSentence.apply(g, e);
  },
  slugify:function(e) {
   if (null == e) return "";
   var r = "", t = "aaaaaaaaaceeeeeiiiilnoooooosstuuuunczz", u = new RegExp(c(r), "g");
   return e = n(e).toLowerCase().replace(u, function(e) {
    var n = r.indexOf(e);
    return t.charAt(n) || "-";
   }), g.dasherize(e.replace(/[^\w\s-]/g, ""));
  },
  surround:function(e, n) {
   return [ n, e, n ].join("");
  },
  quote:function(e, n) {
   return g.surround(e, n || '"');
  },
  unquote:function(e, n) {
   return n = n || '"', e[0] === n && e[e.length - 1] === n ? e.slice(1, e.length - 1) :e;
  },
  exports:function() {
   var e = {};
   for (var n in this) this.hasOwnProperty(n) && !n.match(/^(?:include|contains|reverse)$/) && (e[n] = this[n]);
   return e;
  },
  repeat:function(e, r, t) {
   if (null == e) return "";
   if (r = ~~r, null == t) return o(n(e), r);
   for (var u = []; r > 0; u[--r] = e) ;
   return u.join(t);
  },
  naturalCmp:function(e, r) {
   if (e == r) return 0;
   if (!e) return -1;
   if (!r) return 1;
   for (var t = /(\.\d+)|(\d+)|(\D+)/g, u = n(e).toLowerCase().match(t), i = n(r).toLowerCase().match(t), l = Math.min(u.length, i.length), o = 0; l > o; o++) {
    var a = u[o], c = i[o];
    if (a !== c) {
     var s = parseInt(a, 10);
     if (!isNaN(s)) {
      var f = parseInt(c, 10);
      if (!isNaN(f) && s - f) return s - f;
     }
     return c > a ? -1 :1;
    }
   }
   return u.length === i.length ? u.length - i.length :r > e ? -1 :1;
  },
  levenshtein:function(e, r) {
   if (null == e && null == r) return 0;
   if (null == e) return n(r).length;
   if (null == r) return n(e).length;
   e = n(e), r = n(r);
   for (var t, u, i = [], l = 0; r.length >= l; l++) for (var o = 0; e.length >= o; o++) u = l && o ? e.charAt(o - 1) === r.charAt(l - 1) ? t :Math.min(i[o], i[o - 1], t) + 1 :l + o, 
   t = i[o], i[o] = u;
   return i.pop();
  },
  toBoolean:function(e, n, t) {
   return "number" == typeof e && (e = "" + e), "string" != typeof e ? !!e :(e = g.trim(e), r(e, n || [ "true", "1" ]) ? !0 :r(e, t || [ "false", "0" ]) ? !1 :void 0);
  }
 };
 g.strip = g.trim, g.lstrip = g.ltrim, g.rstrip = g.rtrim, g.center = g.lrpad, g.rjust = g.lpad, g.ljust = g.rpad, g.contains = g.include, 
 g.q = g.quote, g.toBool = g.toBoolean, "undefined" != typeof exports && ("undefined" != typeof module && module.exports && (module.exports = g), 
 exports._s = g), "function" == typeof define && define.amd && define("underscore.string", [], function() {
  return g;
 }), e._ = e._ || {}, e._.string = e._.str = g;
}(this, String);

define("lodash.extended.noconflict", [ "lodash", "underscore.string" ], function(_, _str) {
 _.str = _str;
 return _.noConflict();
});

define("popcorn.iframe", [ "popcorn", "player.playereval", "logging", "popcorn.base", "popcorn.gates" ], function(Popcorn, playereval, logging) {
 var hapyakUrlRegex = /^(https?:\/\/([a-z]+\.)?hapyak\.com|\/)/i, queryRegex = /(?:\?|&)([^&=]*)=?([^&]*)/g, dimensionRegex = /(\d+(?:\.\d*)?)(px|%)?/i;
 Popcorn.basePlugin("iframe", function(options, base) {
  var iframe, loadStarted = false, popcorn = this, pause, current = false, updateDataTimeout = 0, innerDiv, srcTimeout, templateEvaluator = new playereval.TemplateEvaluator(this, options);
  function loadFrame() {
   var src, hasQuery, hasVersion, parse, version;
   function changeSrc() {
    if (iframe) {
     iframe.src = src;
    }
   }
   if (options.src) {
    src = templateEvaluator.evaluate(options.src, true);
    if (hapyakUrlRegex.test(src)) {
     queryRegex.test("");
     while ((parse = queryRegex.exec(src)) !== null) {
      hasQuery = true;
      if (parse[1] === "v") {
       hasVersion = true;
       break;
      }
     }
     if (!hasVersion) {
      version = hapyak && hapyak.version || 1;
      src += hasQuery ? "&v=" + version :"?v=" + version;
     }
    }
    if (iframe.src !== src) {
     if (window.chrome) {
      clearTimeout(srcTimeout);
      srcTimeout = setTimeout(changeSrc, 20);
     } else {
      iframe.src = src;
     }
    }
   } else {
    iframe.src = "about:blank";
   }
   loadStarted = true;
  }
  function updateSrc() {
   loadStarted = false;
   if (options.defer && !current) {
    iframe.src = "about:blank";
   } else {
    loadFrame();
   }
  }
  function processMessage(evt) {
   var command, id;
   if (evt.source === iframe.contentWindow) {
    try {
     command = JSON.parse(evt.data);
    } catch (e) {
     return;
    }
    if (!command || command.context !== "hapyak") {
     return;
    }
    if (command.event === "setData") {
     if (command.key && typeof command.key === "string") {
      if (command.mode !== "track") {
       id = options.dataId || options.id;
      }
      popcorn.setData(id, command.key, command.value, command.temp);
     }
     return;
    }
    if (command.event === "clearData") {
     if (command.key && typeof command.key === "string") {
      popcorn.clearData(command.key);
     }
     return;
    }
    if (command.event === "gotoTrack") {
     if (popcorn.options.loadTrackTime) {
      popcorn.options.loadTrackTime(command.track, command.time);
     }
     return;
    }
    if (command.event === "addClasses" && command.classes) {
     base.addClass(base.container, command.classes);
    }
    if (command.event === "removeClasses" && command.classes) {
     base.removeClass(base.container, command.classes);
    }
    if (command.event === "play") {
     popcorn.play();
     return;
    }
    if (command.event === "pause") {
     popcorn.pause();
     return;
    }
    if (command.event === "auth") {
     hapyak.auth({
      partner:command.auth
     });
     return;
    }
    if (command.event === "trackAction" && command.action) {
     logging.tracking.annotationActionById(options.annotationId, "iframe", command.action, Popcorn.extend({
      ExternalContext:iframe.src
     }, command.data || {}));
    }
   }
  }
  function sendData() {
   var keys, obj, json, id, i, k;
   if (!iframe || !iframe.src || iframe.src === "about:blank" || !iframe.contentWindow) {
    return;
   }
   obj = {
    context:"hapyak",
    event:"data",
    values:{}
   };
   id = options.dataId || options.id;
   keys = popcorn.dataKeys(id);
   for (i = 0; i < keys.length; i++) {
    k = keys[i];
    obj.values[k] = popcorn.getData(id, k);
   }
   try {
    json = JSON.stringify(obj);
   } catch (e) {
    return;
   }
   iframe.contentWindow.postMessage(json, "*");
   updateDataTimeout = 0;
  }
  function updateData() {
   var id = options.dataId || options.id, hapyakIframeWidth = popcorn.getData(id, "hapyakIframeWidth"), hapyakIframeHeight = popcorn.getData(id, "hapyakIframeHeight"), parsed;
   if (base.container) {
    parsed = hapyakIframeWidth && dimensionRegex.exec(hapyakIframeWidth);
    if (parsed) {
     base.container.style.width = parsed[1] + (parsed[2] || "px");
    }
    parsed = hapyakIframeHeight && dimensionRegex.exec(hapyakIframeHeight);
    if (parsed) {
     base.container.style.height = parsed[1] + (parsed[2] || "px");
    }
   }
   if (!updateDataTimeout) {
    updateDataTimeout = setTimeout(sendData, 0);
   }
  }
  function updateVariables() {
   var key, id;
   if (!options.variables) {
    return;
   }
   id = options.dataId || options.id;
   for (key in options.variables) {
    if (options.variables.hasOwnProperty(key)) {
     popcorn.setData(id, key, options.variables[key], true);
    }
   }
  }
  function fireEvent(event, data) {
   var msg;
   if (!iframe || !iframe.src || iframe.src === "about:blank" || !iframe.contentWindow) {
    return;
   }
   msg = {
    context:"hapyak",
    event:event
   };
   Popcorn.extend(msg, data);
   try {
    iframe.contentWindow.postMessage(JSON.stringify(msg), "*");
   } catch (e) {
    return;
   }
  }
  function onPlay() {
   fireEvent("play");
  }
  function onPause() {
   fireEvent("pause");
  }
  function timeUpdate() {
   fireEvent("timeupdate", {
    currentTime:popcorn.currentTime()
   });
  }
  function resized() {
   fireEvent("resized", {
    width:popcorn.media.width,
    height:popcorn.media.height
   });
  }
  function updateAuth(auth) {
   fireEvent("authchange", {
    auth:auth.partner
   });
  }
  function updateMetaData() {
   fireEvent("loadedmetadata", {
    duration:popcorn.duration(),
    currentTime:popcorn.currentTime(),
    paused:popcorn.paused(),
    width:popcorn.media.width,
    height:popcorn.media.height
   });
  }
  options.container = base.makeContainer();
  innerDiv = document.createElement("div");
  options.container.appendChild(innerDiv);
  iframe = document.createElement("iframe");
  iframe.setAttribute("allowtransparency", true);
  innerDiv.appendChild(iframe);
  iframe.addEventListener("load", function() {
   if (current) {
    fireEvent("iframeshow", {
     editMode:popcorn.options.hapyakPlayer.editMode()
    });
   }
   updateAuth(hapyak.auth());
   if (popcorn.duration()) {
    updateMetaData();
   }
   sendData();
  }, false);
  updateDataTimeout = 1;
  popcorn.on("authchange", updateAuth);
  popcorn.on("loadedmetadata", updateMetaData);
  popcorn.on("timeupdate", timeUpdate);
  popcorn.on("resized", resized);
  popcorn.on("play", onPlay);
  popcorn.on("pause", onPause);
  updateVariables();
  popcorn.watchData(options.dataId || options.id, "", updateData);
  if (!options.width) {
   iframe.width = "100%";
  } else if (!isNaN(options.width)) {
   iframe.width = options.width;
  }
  if (!options.height) {
   iframe.height = "100%";
  } else if (!isNaN(options.height)) {
   iframe.height = options.height;
  }
  if (options.id && typeof options.id === "string") {
   iframe.id = options.id;
  }
  updateSrc();
  templateEvaluator.watchTemplateVars(options.src, loadFrame);
  base.animate("width", function(val) {
   if (isNaN(val)) {
    iframe.style.width = val;
   } else {
    iframe.width = val;
   }
  });
  base.animate("height", function(val) {
   if (isNaN(val)) {
    iframe.style.height = val;
   } else {
    iframe.height = val;
   }
  });
  base.animate(base.container);
  base.animate("scroll", function(val) {
   var scrollHeight;
   if (base.popcorn.paused()) {
    return;
   }
   try {
    scrollHeight = iframe.contentDocument.documentElement.scrollHeight || iframe.contentDocument.body.scrollHeight;
    iframe.contentWindow.scrollTo(0, val * scrollHeight);
   } catch (e) {}
  });
  window.addEventListener("message", processMessage, false);
  if (options.pause) {
   pause = options.pause;
   if (Popcorn.isArray(pause)) {
    pause = pause[0];
   }
   base.pause(pause === true ? 2 :pause);
  }
  if (options.noscale) {
   base.addClass(base.container, "noscale");
  }
  return {
   start:function() {
    if (!current) {
     fireEvent("iframeshow", {
      editMode:popcorn.options.hapyakPlayer.editMode()
     });
    }
    current = true;
    base.addClass(base.container, "active");
    if (!loadStarted) {
     loadFrame();
    }
   },
   _update:function(trackEvent, changes) {
    templateEvaluator.watchTemplateVars(options.src, loadFrame);
    if (changes.hasOwnProperty("variables")) {
     trackEvent.variables = changes.variables;
     updateVariables();
    }
    if (changes.hasOwnProperty("defer")) {
     options.defer = changes.defer;
    }
    if (changes.hasOwnProperty("src") && options.src !== changes.src || changes.hasOwnProperty("html") && options.html !== changes.html) {
     options.src = changes.src;
     options.html = changes.html;
     updateSrc();
    }
    if (changes.hasOwnProperty("pause") && options.pause !== changes.pause || changes.end !== options.end || changes.start !== options.start) {
     options.pause = changes.pause;
     if (options.pause) {
      base.pause(options.pause === true ? 2 :options.pause);
     } else {
      base.cancelPause();
     }
    }
    if (trackEvent.noscale !== changes.noscale) {
     if (changes.noscale) {
      logging.debug("[popcorn.iframe] Move to unscaled container");
     } else {
      logging.debug("[popcorn.iframe] Move to scaled container");
     }
    }
   },
   end:function() {
    if (current) {
     fireEvent("iframehide");
    }
    current = false;
    base.removeClass(base.container, "active");
   },
   _teardown:function() {
    iframe = null;
    popcorn.off("authchange", updateAuth);
    popcorn.off("loadedmetadata", updateMetaData);
    popcorn.off("timeupdate", timeUpdate);
    popcorn.off("play", onPlay);
    popcorn.off("pause", onPause);
    window.removeEventListener("message", processMessage, false);
   }
  };
 }, {
  about:{
   name:"Popcorn iframe Plugin",
   version:"0.1",
   author:"Brian Chirls, @bchirls",
   website:"http://github.com/brianchirls"
  }
 });
});

(function(root, factory) {
 if (typeof exports === "object") {
  var Popcorn = require("popcorn");
  require("popcorn.filter");
  require("popcorn.gates");
  module.exports = factory(Popcorn);
 } else if (typeof define === "function" && define.amd) {
  define("popcorn.userfollow", [ "popcorn", "popcorn.filter", "popcorn.gates", "configuration" ], factory);
 } else {
  factory(root.Popcorn);
 }
})(this, function(Popcorn, popcornfilter, popcorngates, configuration, undefined) {
 var parseUnit = /(\d+(?:\.\d*)?)(px|%)?/i;
 Popcorn.dataFilter([ "editMode", "autoHapyakIframeWidth", "autoHapyakIframeHeight", "hapyakIframeWidth", "hapyakIframeHeight" ], "userfollow", "userfollow", function(name, options, next, node, editMode, autoHapyakIframeWidth, autoHapyakIframeHeight, hapyakIframeWidth, hapyakIframeHeight) {
  var dailymotionConfig = configuration.integrations && configuration.integrations.dailymotion, enableDefer = configuration.provisioning && configuration.provisioning.deferIframeLoad, envConfig = dailymotionConfig[hapyak.environment] || dailymotionConfig, userFollowUrl = envConfig && envConfig.userfollow || "http://www.dailymotion.com/card/user/", parsedWidth, parsedHeight;
  if (!hapyakIframeWidth) {
   parsedWidth = parseUnit.exec(autoHapyakIframeWidth);
  }
  if (parsedWidth) {
   options.width = parsedWidth[1] + (parsedWidth[2] || "px");
  }
  parseUnit.lastIndex = 0;
  if (!hapyakIframeHeight) {
   parsedHeight = parseUnit.exec(autoHapyakIframeHeight);
  }
  if (parsedHeight) {
   options.height = parsedHeight[1] + (parsedHeight[2] || "px");
  }
  parseUnit.lastIndex = 0;
  if (options.userId) {
   if (options.noscale) {
    options.target = document.querySelectorAll(".hapyak-annotation-noscale-container")[0];
   }
   if (enableDefer) {
    options.defer = true;
   }
   options.src = userFollowUrl + options.userId;
   next(options, "iframe");
  } else if (editMode) {
   options.src = "data:text/html,%3Cbody%20style%3D%22background-color%3Argba(0%2C0%2C0%2C0.5)%3Bfont-family%3AArial%2CHelvetica%2Csan-serif%3Bfont-size%3A12px%3Bmargin%3A0%3Bpadding%3A0%3Btext-align%3Acenter%3Bwidth%3A180px%3B%22%3E%3Cdiv%20style%3D%22margin%3A14%25%20auto%3Bcolor%3Argba(255%2C255%2C255%2C0.6)%3B%22%3EPlease%20select%20a%20channel%3C%2Fdiv%3E%3C%2Fbody%3E";
   next(options, "iframe");
  } else {
   options.src = "";
   next(null, "iframe");
  }
  if (node.fakeTrackEvent && node.fakeTrackEvent.container) {
   Popcorn.basePlugin.addClass(node.fakeTrackEvent.container, "hapyak-userfollow");
  }
 }, false);
});

define("popcorn.profile.userfollow", [ "jquery.noconflict", "utils", "lodash.extended.noconflict", "popcorn.iframe", "popcorn.userfollow" ], function($, utils, _) {
 var userRegex = /^(?:https?:\/\/(?:[a-z0-9\-]+\.)?dailymotion\.com\/(?:card\/)?(?:user\/)?)?([a-z0-9\-\_\.]+)\s*(?:\/|\?|#|$)/i, users = {};
 return {
  id:"userfollow",
  plugin:"userfollow",
  title:"Channel",
  icon:'<svg xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMin meet" viewBox="0 0 27 21"><path transform="scale(1.8)" d="M10.87 10.811c-.564-.238-1.191-.516-1.755-.746l-.483-.132c-.193-.133-.381-.572-.483-.79l-.308-.044c.017-.338.225-.355.308-.615.073-.228.008-.524.122-.735.08-.146.259-.148.35-.273.081-.114.135-.313.161-.452.046-.255.087-.604-.035-.857-.069-.146-.113-.16-.133-.336-.022-.214.064-.911.068-1.062.008-.391-.001-.745-.096-1.126 0 0-.115-.345-.294-.449l-.359-.062-.223-.205c-.895-.551-1.854-.165-2.367.043-.74.24-1.208 1.287-.881 2.835.056.265-.146.383-.132.528.028.316.035 1.074.333 1.261.027.018.24.07.238.056l.087.921c.075.204.253.228.305.517l-.228.055c-.103.218-.291.657-.483.79l-.483.132c-.563.23-1.19.508-1.755.746-.514.217-1.13.295-1.317.833 0 .367-.034 1.232-.024 1.713h11.211c.009-.48-.025-1.346-.025-1.713-.187-.539-.803-.617-1.319-.833zM14.042 10.761l-1.251-.532-.345-.094c-.137-.094-.271-.407-.344-.563l-.22-.031c.012-.241.16-.254.22-.438.052-.162.006-.372.087-.523l.25-.194c.058-.081.097-.223.114-.322.033-.182.062-.431-.024-.611-.049-.104-.081-.113-.094-.239-.018-.152.044-.649.047-.757.006-.279-.001-.531-.068-.803 0 0-.082-.246-.21-.32l-.257-.044-.157-.149c-.638-.393-1.321-.118-1.688.031-.527.171-.861.917-.627 2.021.039.188-.104.273-.095.375.021.225.025.766.238.899l.169.04.063.657c.053.145.181.161.217.367l-.163.04c-.052.111-.136.302-.229.436l.608.26.692.297.337.125c.442.152.942.326 1.129.867l.015.043v.045l.011.605.009.326h2.522c.007-.342-.018-.959-.018-1.221-.131-.383-.57-.438-.938-.593z"/></svg>',
  editor:[ "popcorn.quickedit.userfollow" ],
  normalize:{
   userId:function(userId, trackEvent, callback) {
    var parsed;
    if (!userId || typeof userId !== "string") {
     return "";
    }
    userId = _.str.trim(userId);
    if (utils.regex.templateVarsRegex().test(userId)) {
     callback({
      userId:userId
     });
     return;
    }
    parsed = userRegex.exec(userId);
    if (!parsed || !parsed.length) {
     return false;
    }
    userId = parsed[1];
    if (typeof users[userId] === "string") {
     return {
      userId:userId,
      userName:users[userId]
     };
    }
    if (users[userId] === false) {
     return false;
    }
    if (!users[userId]) {
     users[userId] = [];
     $.ajax({
      url:"https://api.dailymotion.com/user/" + encodeURIComponent(userId),
      dataType:"jsonp",
      success:function(response) {
       var userName = response.screenname || false, callbacks = users[userId], cb;
       users[userId] = userName;
       while (callbacks.length) {
        cb = callbacks.shift();
        if (userName) {
         cb({
          userId:userId,
          userName:userName
         });
        } else {
         cb(false);
        }
       }
      },
      error:function() {
       var callbacks = users[userId], cb;
       delete users[userId];
       while (callbacks.length) {
        cb = callbacks.shift();
        cb(null, "Error validating user account");
       }
      }
     });
    }
    users[userId].push(callback);
   }
  },
  sortIndex:11,
  zIndex:1,
  defaults:{
   left:"3%",
   top:function(video, popcorn, defaults, elements) {
    var elHeight = 71 * 1.93548, height = elements.annotationContainer.offsetHeight, overlayControlHeight = 40, top = 65;
    var scaleRatio = elements.editorContainer.offsetHeight / height;
    if (height) {
     top = Math.round((1 - overlayControlHeight / scaleRatio / height - elHeight / height - 20 / scaleRatio / height) * 100);
    }
    return top + "%";
   },
   width:"180px",
   height:"71px",
   _duration:function(video, popcorn) {
    return popcorn.duration();
   },
   end:function(video, popcorn) {
    return popcorn.currentTime() + popcorn.duration();
   }
  }
 };
});

(function(root, factory) {
 if (typeof exports === "object") {
  var Popcorn = require("popcorn");
  require("popcorn.filter");
  require("popcorn.gates");
  module.exports = factory(Popcorn);
 } else if (typeof define === "function" && define.amd) {
  define("popcorn.videopreview", [ "popcorn", "popcorn.filter", "popcorn.gates", "configuration" ], factory);
 } else {
  factory(root.Popcorn);
 }
})(this, function(Popcorn, popcornfilter, popcorngates, configuration, undefined) {
 Popcorn.dataFilter([ "editMode" ], "videopreview", "videopreview", function(name, options, next, node, editMode) {
  var dailymotionConfig = configuration.integrations && configuration.integrations.dailymotion, enableDefer = configuration.provisioning && configuration.provisioning.deferIframeLoad, envConfig = dailymotionConfig[hapyak.environment] || dailymotionConfig, dailymotionHost = envConfig && envConfig.host || "www.dailymotion.com", protocol;
  if (options.videoId) {
   protocol = window.location.protocol === "file:" ? "http:" :window.location.protocol;
   if (enableDefer) {
    options.defer = true;
   }
   options.src = protocol + "//" + dailymotionHost + "/externalpreview/video/" + options.videoId;
   if (options.noscale) {
    options.target = document.querySelectorAll(".hapyak-annotation-noscale-container")[0];
   }
   next(options, "iframe");
  } else if (editMode) {
   options.src = "data:text/html,%3Cbody%20style%3D%22background-color%3Argba(0%2C0%2C0%2C0.5)%3Bfont-family%3AArial%2CHelvetica%2Csan-serif%3Bfont-size%3A12px%3Bmargin%3A0%3Bpadding%3A0%3Btext-align%3Acenter%3Bwidth%3A150px%3B%22%3E%3Cdiv%20style%3D%22margin%3A24%25%20auto%3Bcolor%3Argba(255%2C255%2C255%2C0.6)%3B%22%3EPlease%20select%20a%20video%3C%2Fdiv%3E%3C%2Fbody%3E";
   next(options, "iframe");
  } else {
   options.src = "";
   next(null, "iframe");
  }
  if (node.fakeTrackEvent && node.fakeTrackEvent.container) {
   Popcorn.basePlugin.addClass(node.fakeTrackEvent.container, "hapyak-videopreview");
  }
 }, false);
});

define("popcorn.profile.videopreview", [ "jquery.noconflict", "utils", "lodash.extended.noconflict", "popcorn.iframe", "popcorn.videopreview" ], function($, utils, _) {
 var videoRegex = /^https?:\/\/(?:[a-z0-9\-]+\.)?dailymotion\.com\/(?:embed\/|externalpreview\/)?video\/(?:annotations\/)?([a-z0-9]+)/i, videos = {};
 return {
  id:"videopreview",
  plugin:"videopreview",
  title:"Video Preview",
  icon:'<svg xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMin meet" viewBox="0 0 27 21"><path transform="scale(1.8)" d="M10.939 6.34v3.32l4.061 2.622v-8.564l-4.061 2.622zm-1.483-2.111h-7.79c-.368 0-.666.298-.666.667v6.209c0 .368.298.667.666.667h7.79c.368 0 .667-.299.667-.667v-6.209c0-.369-.299-.667-.667-.667z"/></svg>',
  editor:[ "popcorn.quickedit.videopreview" ],
  normalize:{
   videoId:function(videoId, trackEvent, callback) {
    var parsed;
    if (!videoId || typeof videoId !== "string") {
     return "";
    }
    videoId = _.str.trim(videoId);
    if (utils.regex.templateVarsRegex().test(videoId)) {
     callback({
      videoId:videoId
     });
     return;
    }
    parsed = videoRegex.exec(videoId);
    if (!parsed || !parsed.length) {
     return false;
    }
    videoId = parsed[1];
    if (typeof videos[videoId] === "string") {
     return {
      videoId:videoId,
      videoName:videos[videoId]
     };
    }
    if (videos[videoId] === false) {
     return false;
    }
    if (!videos[videoId]) {
     videos[videoId] = [];
     $.ajax({
      url:"https://api.dailymotion.com/video/" + encodeURIComponent(videoId),
      dataType:"jsonp",
      success:function(response) {
       var videoName = response.title || false, callbacks = videos[videoId], cb;
       videos[videoId] = videoName;
       while (callbacks.length) {
        cb = callbacks.shift();
        if (videoName) {
         cb({
          videoId:videoId,
          videoName:videoName
         });
        } else {
         cb(false);
        }
       }
      },
      error:function() {
       var callbacks = videos[videoId], cb;
       delete videos[videoId];
       while (callbacks.length) {
        cb = callbacks.shift();
        cb(null, "Error validating video url");
       }
      }
     });
    }
    videos[videoId].push(callback);
   }
  },
  sortIndex:11,
  zIndex:1,
  defaults:{
   left:function(video, popcorn, defaults, elements) {
    var elWidth = 150 * 1.93548, left = 73, width = elements.annotationContainer.offsetWidth;
    var scaleRatio = elements.editorContainer.offsetWidth / width;
    if (width) {
     left = Math.round((1 - elWidth / width - 20 / scaleRatio / width) * 100);
    }
    return left + "%";
   },
   top:function(video, popcorn, defaults, elements) {
    var elHeight = 86 * 1.93548, height = elements.annotationContainer.offsetHeight, overlayControlHeight = 40, top = 61;
    var scaleRatio = elements.editorContainer.offsetHeight / height;
    if (height) {
     top = Math.round((1 - overlayControlHeight / scaleRatio / height - elHeight / height - 20 / scaleRatio / height) * 100);
    }
    return top + "%";
   },
   width:"150px",
   height:"86px"
  }
 };
});

(function(root, factory) {
 if (typeof exports == "object") module.exports = factory(); else if (typeof define == "function" && define.amd) define("spin", factory); else root.Spinner = factory();
})(this, function() {
 var prefixes = [ "webkit", "Moz", "ms", "O" ], animations = {}, useCssAnimations;
 function createEl(tag, prop) {
  var el = document.createElement(tag || "div"), n;
  for (n in prop) el[n] = prop[n];
  return el;
 }
 function ins(parent) {
  for (var i = 1, n = arguments.length; i < n; i++) parent.appendChild(arguments[i]);
  return parent;
 }
 var sheet = function() {
  var el = createEl("style", {
   type:"text/css"
  });
  ins(document.getElementsByTagName("head")[0], el);
  return el.sheet || el.styleSheet;
 }();
 function addAnimation(alpha, trail, i, lines) {
  var name = [ "opacity", trail, ~~(alpha * 100), i, lines ].join("-"), start = .01 + i / lines * 100, z = Math.max(1 - (1 - alpha) / trail * (100 - start), alpha), prefix = useCssAnimations.substring(0, useCssAnimations.indexOf("Animation")).toLowerCase(), pre = prefix && "-" + prefix + "-" || "";
  if (!animations[name]) {
   sheet.insertRule("@" + pre + "keyframes " + name + "{" + "0%{opacity:" + z + "}" + start + "%{opacity:" + alpha + "}" + (start + .01) + "%{opacity:1}" + (start + trail) % 100 + "%{opacity:" + alpha + "}" + "100%{opacity:" + z + "}" + "}", sheet.cssRules.length);
   animations[name] = 1;
  }
  return name;
 }
 function vendor(el, prop) {
  var s = el.style, pp, i;
  prop = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (i = 0; i < prefixes.length; i++) {
   pp = prefixes[i] + prop;
   if (s[pp] !== undefined) return pp;
  }
  if (s[prop] !== undefined) return prop;
 }
 function css(el, prop) {
  for (var n in prop) el.style[vendor(el, n) || n] = prop[n];
  return el;
 }
 function merge(obj) {
  for (var i = 1; i < arguments.length; i++) {
   var def = arguments[i];
   for (var n in def) if (obj[n] === undefined) obj[n] = def[n];
  }
  return obj;
 }
 function pos(el) {
  var o = {
   x:el.offsetLeft,
   y:el.offsetTop
  };
  while (el = el.offsetParent) o.x += el.offsetLeft, o.y += el.offsetTop;
  return o;
 }
 function getColor(color, idx) {
  return typeof color == "string" ? color :color[idx % color.length];
 }
 var defaults = {
  lines:12,
  length:7,
  width:5,
  radius:10,
  rotate:0,
  corners:1,
  color:"#000",
  direction:1,
  speed:1,
  trail:100,
  opacity:1 / 4,
  fps:20,
  zIndex:2e9,
  className:"spinner",
  top:"auto",
  left:"auto",
  position:"relative"
 };
 function Spinner(o) {
  if (typeof this == "undefined") return new Spinner(o);
  this.opts = merge(o || {}, Spinner.defaults, defaults);
 }
 Spinner.defaults = {};
 merge(Spinner.prototype, {
  spin:function(target) {
   this.stop();
   var self = this, o = self.opts, el = self.el = css(createEl(0, {
    className:o.className
   }), {
    position:o.position,
    width:0,
    zIndex:o.zIndex
   }), mid = o.radius + o.length + o.width, ep, tp;
   if (target) {
    target.insertBefore(el, target.firstChild || null);
    tp = pos(target);
    ep = pos(el);
    css(el, {
     left:(o.left == "auto" ? tp.x - ep.x + (target.offsetWidth >> 1) :parseInt(o.left, 10) + mid) + "px",
     top:(o.top == "auto" ? tp.y - ep.y + (target.offsetHeight >> 1) :parseInt(o.top, 10) + mid) + "px"
    });
   }
   el.setAttribute("role", "progressbar");
   self.lines(el, self.opts);
   if (!useCssAnimations) {
    var i = 0, start = (o.lines - 1) * (1 - o.direction) / 2, alpha, fps = o.fps, f = fps / o.speed, ostep = (1 - o.opacity) / (f * o.trail / 100), astep = f / o.lines;
    (function anim() {
     i++;
     for (var j = 0; j < o.lines; j++) {
      alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity);
      self.opacity(el, j * o.direction + start, alpha, o);
     }
     self.timeout = self.el && setTimeout(anim, ~~(1e3 / fps));
    })();
   }
   return self;
  },
  stop:function() {
   var el = this.el;
   if (el) {
    clearTimeout(this.timeout);
    if (el.parentNode) el.parentNode.removeChild(el);
    this.el = undefined;
   }
   return this;
  },
  lines:function(el, o) {
   var i = 0, start = (o.lines - 1) * (1 - o.direction) / 2, seg;
   function fill(color, shadow) {
    return css(createEl(), {
     position:"absolute",
     width:o.length + o.width + "px",
     height:o.width + "px",
     background:color,
     boxShadow:shadow,
     transformOrigin:"left",
     transform:"rotate(" + ~~(360 / o.lines * i + o.rotate) + "deg) translate(" + o.radius + "px" + ",0)",
     borderRadius:(o.corners * o.width >> 1) + "px"
    });
   }
   for (;i < o.lines; i++) {
    seg = css(createEl(), {
     position:"absolute",
     top:1 + ~(o.width / 2) + "px",
     transform:o.hwaccel ? "translate3d(0,0,0)" :"",
     opacity:o.opacity,
     animation:useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + " " + 1 / o.speed + "s linear infinite"
    });
    if (o.shadow) ins(seg, css(fill("#000", "0 0 4px " + "#000"), {
     top:2 + "px"
    }));
    ins(el, ins(seg, fill(getColor(o.color, i), "0 0 1px rgba(0,0,0,.1)")));
   }
   return el;
  },
  opacity:function(el, i, val) {
   if (i < el.childNodes.length) el.childNodes[i].style.opacity = val;
  }
 });
 function initVML() {
  function vml(tag, attr) {
   return createEl("<" + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', attr);
  }
  sheet.addRule(".spin-vml", "behavior:url(#default#VML)");
  Spinner.prototype.lines = function(el, o) {
   var r = o.length + o.width, s = 2 * r;
   function grp() {
    return css(vml("group", {
     coordsize:s + " " + s,
     coordorigin:-r + " " + -r
    }), {
     width:s,
     height:s
    });
   }
   var margin = -(o.width + o.length) * 2 + "px", g = css(grp(), {
    position:"absolute",
    top:margin,
    left:margin
   }), i;
   function seg(i, dx, filter) {
    ins(g, ins(css(grp(), {
     rotation:360 / o.lines * i + "deg",
     left:~~dx
    }), ins(css(vml("roundrect", {
     arcsize:o.corners
    }), {
     width:r,
     height:o.width,
     left:o.radius,
     top:-o.width >> 1,
     filter:filter
    }), vml("fill", {
     color:getColor(o.color, i),
     opacity:o.opacity
    }), vml("stroke", {
     opacity:0
    }))));
   }
   if (o.shadow) for (i = 1; i <= o.lines; i++) seg(i, -2, "progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)");
   for (i = 1; i <= o.lines; i++) seg(i);
   return ins(el, g);
  };
  Spinner.prototype.opacity = function(el, i, val, o) {
   var c = el.firstChild;
   o = o.shadow && o.lines || 0;
   if (c && i + o < c.childNodes.length) {
    c = c.childNodes[i + o];
    c = c && c.firstChild;
    c = c && c.firstChild;
    if (c) c.opacity = val;
   }
  };
 }
 var probe = css(createEl("group"), {
  behavior:"url(#default#VML)"
 });
 if (!vendor(probe, "transform") && probe.adj) initVML(); else useCssAnimations = vendor(probe, "animation");
 return Spinner;
});